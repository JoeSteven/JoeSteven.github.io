[{"title":"What's inside?-LiveData","url":"https://joesteven.github.io/what-s-inside-livedata/","content":"<p>距离上一次更新博客已经过去很久了，其实中间也有写一些东西但是没有认真发布到博客上，希望能坚持初心，把博客当作学习记录来激励自己持续学习。</p>\n<ul>\n<li>当 LiveData 更新 value 的时候实际发生了什么？</li>\n<li>LiveData 是如何绑定观察者的生命周期的？</li>\n<li>当我们订阅 LiveData 时，为什么只有当前观察者收到数据？</li>\n</ul>\n<p>也许在使用 LiveData 时还有其他的问题，而所有问题的答案几乎都清楚的写在源码里。本篇文章中阅读的为<code>androidx.lifecyle:lifecycle-livedata-core:2.2.0</code> 中的 LiveData</p>\n<h3 id=\"一、构造-LiveData\"><a href=\"#一、构造-LiveData\" class=\"headerlink\" title=\"一、构造 LiveData\"></a>一、构造 LiveData</h3><p>构造 LiveData 有两种方式，一种使用默认构造函数，另一种可以在构造时初始化value的值。构造函数的内容很简单，初始化了<code>mData</code> 和 <code>mVersion</code>，我们这里先记住这个 <code>mVersion</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LiveData</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        mData = NOT_SET;</div><div class=\"line\">        mVersion = START_VERSION;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LiveData</span><span class=\"params\">(T value)</span> </span>&#123;</div><div class=\"line\">        mData = value;</div><div class=\"line\">        mVersion = START_VERSION + <span class=\"number\">1</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> START_VERSION = -<span class=\"number\">1</span>;</div></pre></td></tr></table></figure>\n<h3 id=\"二、订阅-LiveData\"><a href=\"#二、订阅-LiveData\" class=\"headerlink\" title=\"二、订阅 LiveData\"></a>二、订阅 LiveData</h3><p>订阅通常也有两种方式，一种是<code>observe</code>传入 <code>LifecycleOwner</code> 另一种是<code>observerForever</code>。 先从 observe 开始看：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@MainThread</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">observe</span><span class=\"params\">(@NonNull LifecycleOwner owner, @NonNull Observer&lt;? <span class=\"keyword\">super</span> T&gt; observer)</span> </span>&#123;</div><div class=\"line\"> </div><div class=\"line\">  \t<span class=\"comment\">// 首先检查是否在主线程调用的该函数</span></div><div class=\"line\">    assertMainThread(<span class=\"string\">\"observe\"</span>);</div><div class=\"line\">  \t</div><div class=\"line\">  \t<span class=\"comment\">// 如果传入的 lifecycle owner 的状态是 destoryed，就取消本次订阅</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (owner.getLifecycle().getCurrentState() == DESTROYED) &#123;</div><div class=\"line\">        <span class=\"comment\">// ignore</span></div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">  <span class=\"comment\">// 使用传入的两个参数构造了一个 LifecycleBoundObserver， 即一个包装类</span></div><div class=\"line\">    LifecycleBoundObserver wrapper = <span class=\"keyword\">new</span> LifecycleBoundObserver(owner, observer);</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 将传入的observer 和刚刚构造的 wrapper 存入到 mObservers 中</span></div><div class=\"line\">    ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper);</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 如果existing 不为空，并且没有绑定到传入的owner上，说明之前已经绑定了另一个生命周期宿主</span></div><div class=\"line\">  <span class=\"comment\">// 不允许同时绑定多个宿主，抛错误</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (existing != <span class=\"keyword\">null</span> &amp;&amp; !existing.isAttachedTo(owner)) &#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Cannot add the same observer\"</span></div><div class=\"line\">                + <span class=\"string\">\" with different lifecycles\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">  </div><div class=\"line\">    <span class=\"keyword\">if</span> (existing != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">      <span class=\"comment\">// 到这一步就说明之前已经成功订阅过了，直接返回，不进行后续操作</span></div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 将wrapper和宿主的生命周期进行绑定</span></div><div class=\"line\">    owner.getLifecycle().addObserver(wrapper);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面的代码逻辑很简单，里面出现了几个我们可能关心的类或变量：<code>mObservers</code>， <code>LifecycleBoundObserver</code>。</p>\n<p>其中 <code>mObservers</code> 是 <code>SafeIterableMap</code>， 实际是个链表假装的 Map，这里不展开。key 是 observer，也就是上面方法中传进来的第二个参数，value 是<code>ObserverWrapper</code>。</p>\n<p>另一个 <code>LifecycleBoundObserver</code>  就比较关键了，从上面的信息可以推出它是<code>ObserverWrapper</code>  的一个子类。我们先从 <code>owner.getLifecycle().addObserver(wrapper);</code> 这个代码作为入口来看：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 这里面还有一些 lifecycle 的逻辑，这里先去掉不看</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dispatchEvent</span><span class=\"params\">(LifecycleOwner owner, Event event)</span> </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// 最终调用到  ObserverWithState 的 dispatchEvent 方法中来</span></div><div class=\"line\">  <span class=\"comment\">//...</span></div><div class=\"line\">  \t\t\t\t<span class=\"comment\">// 调用 lifecycleObserver 的onStateChanged 方法</span></div><div class=\"line\">            mLifecycleObserver.onStateChanged(owner, event);</div><div class=\"line\">            mState = newState;</div><div class=\"line\">  <span class=\"comment\">//...</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>既然 <code>addObserver</code> 可以把 <code>wrapper</code> 作为参数传入，那就说明它实现了 <code>LifecycleEventObserver</code> 接口，<strong>这里就解释了开头的第二个问题</strong>，让我们进入到<code>LifecycleBoundObserver</code> 类中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onStateChanged</span><span class=\"params\">(@NonNull LifecycleOwner source,</span></span></div><div class=\"line\">        @NonNull Lifecycle.Event event) &#123;</div><div class=\"line\">  <span class=\"comment\">// 当宿主的生命周期发生改变时或者刚刚绑定时会回调这个方法</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (mOwner.getLifecycle().getCurrentState() == DESTROYED) &#123;</div><div class=\"line\">      <span class=\"comment\">// 如果宿主的状态时 destroyed， 移除观察者</span></div><div class=\"line\">        removeObserver(mObserver);</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">  <span class=\"comment\">// 关键代码</span></div><div class=\"line\">    activeStateChanged(shouldBeActive());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>先看<code>shouldBeActive()</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">shouldBeActive</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">  <span class=\"comment\">//  状态至少要大于等于 STARTED， 进入到 State 这个枚举类中可以发现这里指的状态</span></div><div class=\"line\">  <span class=\"comment\">// 其实就只有两种，处于 STARTED 或者 RESUMED 才认为当前的观察者是 active</span></div><div class=\"line\">    <span class=\"keyword\">return</span> mOwner.getLifecycle().getCurrentState().isAtLeast(STARTED);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>再来看<code>activeStateChanged()</code>， 这个方法在抽象类 <code>ObserverWrapper</code>  中</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">activeStateChanged</span><span class=\"params\">(<span class=\"keyword\">boolean</span> newActive)</span> </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// 判断当前状态是否改变，没有改变就不执行后面的逻辑</span></div><div class=\"line\">  <span class=\"comment\">// mActive 初始化状态为false，因此刚订阅的时候会跳过这个判断</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (newActive == mActive) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">// immediately set active state, so we'd never dispatch anything to inactive</span></div><div class=\"line\">    <span class=\"comment\">// owner</span></div><div class=\"line\">  <span class=\"comment\">// 上面的英文注释为原代码中的注释，很好理解，这里就是先立马同步状态</span></div><div class=\"line\">    mActive = newActive;</div><div class=\"line\">  <span class=\"comment\">// 判断当前 LiveData 是否为未激活状态，这里不理解没关系，继续往后看</span></div><div class=\"line\">    <span class=\"keyword\">boolean</span> wasInactive = LiveData.<span class=\"keyword\">this</span>.mActiveCount == <span class=\"number\">0</span>;</div><div class=\"line\">  <span class=\"comment\">// 如果当前这个观察者的状态为 active，就给 LiveData 的 mActiveCount 加一，否则就减一</span></div><div class=\"line\">    LiveData.<span class=\"keyword\">this</span>.mActiveCount += mActive ? <span class=\"number\">1</span> : -<span class=\"number\">1</span>;</div><div class=\"line\">  <span class=\"comment\">// 如果 LiveData 之前的状态是未激活，而当前这个观察者的状态为激活，</span></div><div class=\"line\">  <span class=\"comment\">// 说明LiveData的状态马上要变成激活状态了， 回调 onActive 函数</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (wasInactive &amp;&amp; mActive) &#123;</div><div class=\"line\">        onActive();</div><div class=\"line\">    &#125;</div><div class=\"line\">  <span class=\"comment\">// 和上面的逻辑相反，同理当 LiveData 所有的观察者都进入为激活状态后，</span></div><div class=\"line\">  <span class=\"comment\">// 这个 LiveData 的状态也进入未激活，回调 onInactive 函数</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (LiveData.<span class=\"keyword\">this</span>.mActiveCount == <span class=\"number\">0</span> &amp;&amp; !mActive) &#123;</div><div class=\"line\">        onInactive();</div><div class=\"line\">    &#125;</div><div class=\"line\">  <span class=\"comment\">// 上面的代码都是为了回调一些状态函数，可以类比为 LiveData 的生命周期函数</span></div><div class=\"line\">  <span class=\"comment\">// 下面才进入到和这个观察者切身相关的代码</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (mActive) &#123;</div><div class=\"line\">      <span class=\"comment\">// 从函数名字可以看出这里是在分发数据，并且传入了this即这个ObserverWrapper</span></div><div class=\"line\">        dispatchingValue(<span class=\"keyword\">this</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面的代码我们可以知道一个 LiveData 很关键的点，当回调 <code>onInactive</code> 或者 Livedata 的 <code>mActiveCount</code> 为 0 的时候，并不是说 LiveData 没有观察者，而是它所有的观察者当前都处于未激活状态，这里千万不要搞混淆了。</p>\n<p>另外可以看到这里可能会触发一次<code>value</code> 的分发，这里就解释了开篇第三个问题的一半，<strong>当我们第一次订阅LiveData的时候，会去绑定生命周期，然后会回调到 onStateChanged，当处于active后就会触发一次value的分发</strong></p>\n<h3 id=\"三、当-setValue的时候发生了什么\"><a href=\"#三、当-setValue的时候发生了什么\" class=\"headerlink\" title=\"三、当 setValue的时候发生了什么\"></a>三、当 setValue的时候发生了什么</h3><p>第二个部分我们已经可以得出分发<code>value</code>是通过<code>dispatchingValue();</code>方法来实现的，那<code>setValue</code> 和<code>postValue</code> 应该最终都会调用这个函数，我们先看 <code>setValue</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@MainThread</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">setValue</span><span class=\"params\">(T value)</span> </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// 该方法只能在主线程调用</span></div><div class=\"line\">    assertMainThread(<span class=\"string\">\"setValue\"</span>);</div><div class=\"line\">  <span class=\"comment\">// 更新版本号</span></div><div class=\"line\">    mVersion++;</div><div class=\"line\">  <span class=\"comment\">// 更新 mData 的值</span></div><div class=\"line\">    mData = value;</div><div class=\"line\">  <span class=\"comment\">// 分发数据</span></div><div class=\"line\">    dispatchingValue(<span class=\"keyword\">null</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面的代码很简单，所以核心在 <code>dispatchingValue(null);</code> 中，大家细心一点可以发现这里传入的参数为<code>null</code> ，而上面<code>ObserverWrapper</code> 传入的参数为 <code>this</code>:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 参数为 ObserverWraper</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dispatchingValue</span><span class=\"params\">(@Nullable ObserverWrapper initiator)</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 先看后面，最后再返回来看这里</span></div><div class=\"line\">      <span class=\"keyword\">if</span> (mDispatchingValue) &#123;</div><div class=\"line\">        <span class=\"comment\">// 如果当前正在分发，就标记当前分发失效</span></div><div class=\"line\">          mDispatchInvalidated = <span class=\"keyword\">true</span>;</div><div class=\"line\">          <span class=\"keyword\">return</span>;</div><div class=\"line\">      &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">// 标记当前正在分发数据</span></div><div class=\"line\">      mDispatchingValue = <span class=\"keyword\">true</span>;</div><div class=\"line\">    <span class=\"comment\">// do..while 这个循环至少会执行一次</span></div><div class=\"line\">      do &#123;</div><div class=\"line\">        <span class=\"comment\">// 标记为正常分发状态</span></div><div class=\"line\">          mDispatchInvalidated = <span class=\"keyword\">false</span>;</div><div class=\"line\">        </div><div class=\"line\">          <span class=\"keyword\">if</span> (initiator != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            <span class=\"comment\">// 关键点：如果传入的参数不为空</span></div><div class=\"line\">            <span class=\"comment\">// 字面理解：考虑通知这个观察者</span></div><div class=\"line\">              considerNotify(initiator);</div><div class=\"line\">              initiator = <span class=\"keyword\">null</span>;</div><div class=\"line\">          &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"comment\">// 如果传入的参数为空，遍历之前我们订阅时存储观察者的那个map</span></div><div class=\"line\">              <span class=\"keyword\">for</span> (Iterator&lt;Map.Entry&lt;Observer&lt;? <span class=\"keyword\">super</span> T&gt;, ObserverWrapper&gt;&gt; iterator =</div><div class=\"line\">                      mObservers.iteratorWithAdditions(); iterator.hasNext(); ) &#123;</div><div class=\"line\">                <span class=\"comment\">//考虑通知这个观察者</span></div><div class=\"line\">                  considerNotify(iterator.next().getValue());</div><div class=\"line\">                </div><div class=\"line\">                <span class=\"comment\">// 如果分发状态被标记为失效了，跳出这次遍历通知的逻辑</span></div><div class=\"line\">                  <span class=\"keyword\">if</span> (mDispatchInvalidated) &#123;</div><div class=\"line\">                      <span class=\"keyword\">break</span>;</div><div class=\"line\">                  &#125;</div><div class=\"line\">              &#125;</div><div class=\"line\">          &#125;</div><div class=\"line\">        <span class=\"comment\">// 当分发状态标记为失效时 循环do中的逻辑</span></div><div class=\"line\">      &#125; <span class=\"keyword\">while</span> (mDispatchInvalidated);</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">// 标记分发完成</span></div><div class=\"line\">      mDispatchingValue = <span class=\"keyword\">false</span>;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<p>上面的代码主要有三个点</p>\n<ul>\n<li>当传入了 wrapper 就会只通知这个观察者，也就解释了开头第三个问题</li>\n<li>这个分发考虑一个多次分发value的问题，而处理的方式是停止前一次的分发，立即进入下一次的分发。比如第一次分发开始，紧接着更新了value，调用 <code>dispatchingValue</code>，这时候会发现当前正在分发，于是将<code>mDispatchInvalidated</code> 标记为 true， 第一次分发在for循环中发现本次分发失效了，跳出for循环，然后while循环判断通过将再一次执行do中的代码，这时候会将<code>mDispatchInvalidated</code>标记为false，顺利的走完for循环中的逻辑，跳出while循环，最后标记分发完成。</li>\n<li>无论是通知一个还是通知全部，都进入到了<code>considerNotify(wrapper)</code>; 这个函数中</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">considerNotify</span><span class=\"params\">(ObserverWrapper observer)</span> </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// 这里面的代码就很好理解了，保留了原代码中的英文注释</span></div><div class=\"line\"> </div><div class=\"line\">    <span class=\"keyword\">if</span> (!observer.mActive) &#123;</div><div class=\"line\">      <span class=\"comment\">// 如果当前observer 的状态为未激活 CREATED, STOPED, PAUSED </span></div><div class=\"line\">      <span class=\"comment\">// 注意 DESTORYED 不在未激活状态中，会直接移除 observer</span></div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">// Check latest state b4 dispatch. Maybe it changed state but we didn't get the event yet.</span></div><div class=\"line\">    <span class=\"comment\">//</span></div><div class=\"line\">    <span class=\"comment\">// we still first check observer.active to keep it as the entrance for events. So even if</span></div><div class=\"line\">    <span class=\"comment\">// the observer moved to an active state, if we've not received that event, we better not</span></div><div class=\"line\">    <span class=\"comment\">// notify for a more predictable notification order.</span></div><div class=\"line\">  <span class=\"comment\">// 英文注释解释得很清楚了，有可能宿主进入了未激活状态，但是并没有回调 onStateChanged</span></div><div class=\"line\">  <span class=\"comment\">// 或者因为某些原因导致没有收到event，所以这里需要手动调用一次来进行判断</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (!observer.shouldBeActive()) &#123;</div><div class=\"line\">        observer.activeStateChanged(<span class=\"keyword\">false</span>);</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">  <span class=\"comment\">// 对比当前分发数据的版本号和该观察者当前持有的版本号</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (observer.mLastVersion &gt;= mVersion) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">  <span class=\"comment\">// 更新观察者的版本号</span></div><div class=\"line\">    observer.mLastVersion = mVersion;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 回调给观察者 value</span></div><div class=\"line\">    observer.mObserver.onChanged((T) mData);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong>上面的代码就解释了开头的第一个问题</strong></p>\n<h3 id=\"四、扩展问题\"><a href=\"#四、扩展问题\" class=\"headerlink\" title=\"四、扩展问题\"></a>四、扩展问题</h3><h4 id=\"postValue-是如何实现的？\"><a href=\"#postValue-是如何实现的？\" class=\"headerlink\" title=\"postValue 是如何实现的？\"></a>postValue 是如何实现的？</h4><p>从源码可以看出来，当多次调用postValue时，如果主线程还没来得及处理前面的更新，则只会更新最后一次的value，并不会 post 多次runable到主线程去执行</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">postValue</span><span class=\"params\">(T value)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">boolean</span> postTask;</div><div class=\"line\">    <span class=\"keyword\">synchronized</span> (mDataLock) &#123;</div><div class=\"line\">      <span class=\"comment\">// 当 mPendingData 为 NOT_SET 标记 postTask 为true</span></div><div class=\"line\">        postTask = mPendingData == NOT_SET;</div><div class=\"line\">      <span class=\"comment\">// 将 mPendingData 的值更新为 value</span></div><div class=\"line\">        mPendingData = value;</div><div class=\"line\">    &#125;</div><div class=\"line\">  <span class=\"comment\">// 如果 postTask 为false， 即在postValue 之前mPendingData 的值不是NOT_SET</span></div><div class=\"line\">  <span class=\"comment\">// 说明上一次postValue的任务还没有执行完，不需要重复提交</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (!postTask) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">  <span class=\"comment\">// post 一个runnable到主线程执行，深入到 postToMainThread 方法可以知道就是通过一个</span></div><div class=\"line\">  <span class=\"comment\">// 绑定了主线程looper的handler来实现的</span></div><div class=\"line\">    ArchTaskExecutor.getInstance().postToMainThread(mPostValueRunnable);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Runnable mPostValueRunnable = <span class=\"keyword\">new</span> Runnable() &#123;</div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">            Object newValue;</div><div class=\"line\">            <span class=\"keyword\">synchronized</span> (mDataLock) &#123;</div><div class=\"line\">                newValue = mPendingData;</div><div class=\"line\">              <span class=\"comment\">// 将 mPendingData 重置为 NOT_SET 来标记本次任务完成</span></div><div class=\"line\">                mPendingData = NOT_SET;</div><div class=\"line\">            &#125;</div><div class=\"line\">          <span class=\"comment\">// setValue</span></div><div class=\"line\">            setValue((T) newValue);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;;</div></pre></td></tr></table></figure>\n<h4 id=\"MutableLiveData-和-LiveData-的区别\"><a href=\"#MutableLiveData-和-LiveData-的区别\" class=\"headerlink\" title=\"MutableLiveData 和 LiveData 的区别\"></a>MutableLiveData 和 LiveData 的区别</h4><p>这个甚至不用看源码，熟悉kotlin就知道跟 List 和 MutableList 的区别一样。LiveData 中 <code>setValue</code> 和 <code>postValue</code> 都是 <code>protected</code>， 而MutableLiveData 把它们变成了 <code>public</code>。</p>\n<p>推荐 MutableLiveData 只提供给有修改data权限的类使用，对于一些只取值的类（UI等）则提供 LiveData，避免被错误修改。</p>\n<h4 id=\"Transformations-map-和-switchMap\"><a href=\"#Transformations-map-和-switchMap\" class=\"headerlink\" title=\"Transformations.map 和 switchMap\"></a>Transformations.map 和 switchMap</h4><p>如果之前对 RxJava 比较熟悉的同学基本都能理解这两个方法的区别和原理。本质上和 RxJava 的 map 和 flatmap类似</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;X, Y&gt; <span class=\"function\">LiveData&lt;Y&gt; <span class=\"title\">map</span><span class=\"params\">(</span></span></div><div class=\"line\">        @NonNull LiveData&lt;X&gt; source,</div><div class=\"line\">        @NonNull <span class=\"keyword\">final</span> Function&lt;X, Y&gt; mapFunction) &#123;</div><div class=\"line\">    <span class=\"keyword\">final</span> MediatorLiveData&lt;Y&gt; result = <span class=\"keyword\">new</span> MediatorLiveData&lt;&gt;();</div><div class=\"line\">  <span class=\"comment\">// 利用MediatorLiveData 的特性订阅原LiveData</span></div><div class=\"line\">    result.addSource(source, <span class=\"keyword\">new</span> Observer&lt;X&gt;() &#123;</div><div class=\"line\">        <span class=\"meta\">@Override</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onChanged</span><span class=\"params\">(@Nullable X x)</span> </span>&#123;</div><div class=\"line\">          <span class=\"comment\">// 然后将原LiveData 通过传进来的mapFunction转换后回调给观察者</span></div><div class=\"line\">            result.setValue(mapFunction.apply(x));</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\">    <span class=\"keyword\">return</span> result;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;X, Y&gt; <span class=\"function\">LiveData&lt;Y&gt; <span class=\"title\">switchMap</span><span class=\"params\">(</span></span></div><div class=\"line\">        @NonNull LiveData&lt;X&gt; source,</div><div class=\"line\">        @NonNull <span class=\"keyword\">final</span> Function&lt;X, LiveData&lt;Y&gt;&gt; switchMapFunction) &#123;</div><div class=\"line\">    <span class=\"keyword\">final</span> MediatorLiveData&lt;Y&gt; result = <span class=\"keyword\">new</span> MediatorLiveData&lt;&gt;();</div><div class=\"line\">    result.addSource(source, <span class=\"keyword\">new</span> Observer&lt;X&gt;() &#123;</div><div class=\"line\">        LiveData&lt;Y&gt; mSource;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"meta\">@Override</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onChanged</span><span class=\"params\">(@Nullable X x)</span> </span>&#123;</div><div class=\"line\">          <span class=\"comment\">// 和map一样，核心也是传进来的这个转换函数</span></div><div class=\"line\">          <span class=\"comment\">// 不同的是 map的转换函数是将原livedata的值处理/转换另外一个类型的值（当然也可以同类型）</span></div><div class=\"line\">          <span class=\"comment\">// 而这里的转换函数是将原Livedata 的值处理后包装到另一个Livedata中并返回</span></div><div class=\"line\">            LiveData&lt;Y&gt; newLiveData = switchMapFunction.apply(x);</div><div class=\"line\">            <span class=\"keyword\">if</span> (mSource == newLiveData) &#123;</div><div class=\"line\">                <span class=\"keyword\">return</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">if</span> (mSource != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                result.removeSource(mSource);</div><div class=\"line\">            &#125;</div><div class=\"line\">            mSource = newLiveData;</div><div class=\"line\">            <span class=\"keyword\">if</span> (mSource != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                result.addSource(mSource, <span class=\"keyword\">new</span> Observer&lt;Y&gt;() &#123;</div><div class=\"line\">                    <span class=\"meta\">@Override</span></div><div class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onChanged</span><span class=\"params\">(@Nullable Y y)</span> </span>&#123;</div><div class=\"line\">                        result.setValue(y);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\">    <span class=\"keyword\">return</span> result;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>事实上我们完全可以自己去根据项目需求来自定义一些类似RxJava的操作符。</p>\n<h3 id=\"五、总结\"><a href=\"#五、总结\" class=\"headerlink\" title=\"五、总结\"></a>五、总结</h3><p>没有总结，以后关于源码的文章都不写总结了。希望自己和看到这篇文章的人都能静下来认真看完源码学习的过程，然后得出自己的理解和总结，而不是看了两段就直接跳到后面来背总结。</p>\n","categories":["Android源码学习"],"tags":[]},{"title":"Gson 反序列化 Kotlin 数据类默认值失效","url":"https://joesteven.github.io/gson_kotlin_data_class/","content":"<h3 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h3><p>最近开发的时候遇到一个问题，服务端的一个接口返回的 Json 中去掉了一个字段，客户端在使用 <code>Gson</code> 解析出的这个数据类的时候报空崩溃了。我在排查这个问题的时候发现这个数据类的这个字段是给了默认值的，但是解析的时候却赋值为 <code>null</code>，而另外一个接口也有少了几个字段的情况，但是这个接口的数据类的这些变量默认值却是生效的。</p>\n<p>为什么呢？</p>\n<h3 id=\"找不同\"><a href=\"#找不同\" class=\"headerlink\" title=\"找不同\"></a>找不同</h3><p>不知道有多少工程师在碰到问题时候会使用这个办法，努力的去对比一个运行正常的代码和出现bug的代码到底哪里不同？</p>\n<p>然后，我真的发现了不同，如下示例：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 默认值生效</span></div><div class=\"line\"><span class=\"keyword\">data</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span></span>(<span class=\"meta\">@SerializedName(<span class=\"meta-string\">\"name\"</span>)</span><span class=\"keyword\">val</span> name:String = <span class=\"string\">\"no_name\"</span>,</div><div class=\"line\">                    <span class=\"meta\">@SerializedName(<span class=\"meta-string\">\"age\"</span>)</span><span class=\"keyword\">val</span> age:<span class=\"built_in\">Int</span> = <span class=\"number\">-1</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 默认值不生效</span></div><div class=\"line\"><span class=\"keyword\">data</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dog</span></span>(<span class=\"meta\">@SerializedName(<span class=\"meta-string\">\"name\"</span>)</span><span class=\"keyword\">val</span> name:String = <span class=\"string\">\"no_name\"</span>,</div><div class=\"line\">                    <span class=\"meta\">@SerializedName(<span class=\"meta-string\">\"age\"</span>)</span><span class=\"keyword\">val</span> age:<span class=\"built_in\">Int</span>)</div></pre></td></tr></table></figure>\n<p>上面的两个数据类，当服务端下发的 Json 中没有 <code>name</code> 字段时，解析出的 <code>Person</code> 对象的 <code>name</code> 值是<code>&quot;no_name&quot;</code> ， 而同样的情况下，<code>Dog</code> 的 <code>name</code> 为 <code>null</code>。</p>\n<p>有什么不同呢？你应该也发现了，<code>Person</code> 类的 <code>age</code> 也设置了默认值，而 <code>Dog</code> 类只有 <code>name</code> 设置了默认值，会是这个原因吗？</p>\n<p>经过修改，给 <code>age</code> 也设置上默认值，结果符合预期。</p>\n<h3 id=\"为什么\"><a href=\"#为什么\" class=\"headerlink\" title=\"为什么\"></a>为什么</h3><p>现在我们已经知道是什么地方导致了这个问题，那么深究一下为什么会出现这个问题。 </p>\n<p>如何深究？看源码。</p>\n<p>看谁的源码？既然是用 <code>Gson</code> 解析的，那就先看看 <code>Gson</code> 是怎么解析的吧。</p>\n<p>Gson 反序列化最后都会调用这个函数 <code>fromJson()</code> ，为了方便阅读省略了很多代码，关键点在于 typeAdapter.read(reader) 这行代码。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\">T <span class=\"title\">fromJson</span><span class=\"params\">(JsonReader reader, Type typeOfT)</span> <span class=\"keyword\">throws</span> JsonIOException, JsonSyntaxException </span>&#123;</div><div class=\"line\">  <span class=\"comment\">//.... 省略</span></div><div class=\"line\">    reader.peek();</div><div class=\"line\">    isEmpty = <span class=\"keyword\">false</span>;</div><div class=\"line\">    TypeToken&lt;T&gt; typeToken = (TypeToken&lt;T&gt;) TypeToken.get(typeOfT);</div><div class=\"line\">    TypeAdapter&lt;T&gt; typeAdapter = getAdapter(typeToken);</div><div class=\"line\">    T object = typeAdapter.read(reader);</div><div class=\"line\">    <span class=\"keyword\">return</span> object;</div><div class=\"line\">  <span class=\"comment\">//...省略</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>点进去一看，是个接口，再一看，这个接口的子类贼多…</p>\n<p>咋整？ 很简单，我们可以依靠断点调试来帮我们找到此刻执行的是哪个子类中的代码，这也是一种阅读源码的技巧，在不清楚下游逻辑的情况下，断点跑一遍，把相关的类和方法理清楚。</p>\n<p>断点可以发现这个类是：<code>ReflectiveTypeAdapterFactory</code> ，这段代码不复杂，也就分为两个部分</p>\n<ul>\n<li>创建对象</li>\n<li>为对象的成员变量赋值</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">read</span><span class=\"params\">(JsonReader in)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (in.peek() == JsonToken.NULL) &#123;</div><div class=\"line\">    in.nextNull();</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 构造对象</span></div><div class=\"line\">  T instance = constructor.construct();</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">    in.beginObject();</div><div class=\"line\">    <span class=\"comment\">// 变量赋值</span></div><div class=\"line\">    <span class=\"keyword\">while</span> (in.hasNext()) &#123;</div><div class=\"line\">      String name = in.nextName();</div><div class=\"line\">      BoundField field = boundFields.get(name);</div><div class=\"line\">      <span class=\"keyword\">if</span> (field == <span class=\"keyword\">null</span> || !field.deserialized) &#123;</div><div class=\"line\">        in.skipValue();</div><div class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        field.read(in, instance);</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125; <span class=\"keyword\">catch</span> (IllegalStateException e) &#123;</div><div class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> JsonSyntaxException(e);</div><div class=\"line\">  &#125; <span class=\"keyword\">catch</span> (IllegalAccessException e) &#123;</div><div class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> AssertionError(e);</div><div class=\"line\">  &#125;</div><div class=\"line\">  in.endObject();</div><div class=\"line\">  <span class=\"keyword\">return</span> instance;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>到这里该怎么继续查呢？也可以利用断点，断点可以发现，两种数据类，在构造 <code>instance</code> 实例的时候，<code>Person</code> 对象每个变量都有默认值，而<code>Dog</code> 对象的每个变量的值都是 <code>null</code> 或者 <code>0</code>(基本数据类型)。</p>\n<p>所以问题出在构造对象的时候！继续追可以追到一个类<code>ConstructorConstructor</code> 中，找到<code>get</code>方法，同样省略掉了从缓存中获取的代码，只看第一次构造这个对象的代码。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\">ObjectConstructor&lt;T&gt; <span class=\"title\">get</span><span class=\"params\">(TypeToken&lt;T&gt; typeToken)</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">final</span> Type type = typeToken.getType();</div><div class=\"line\">  <span class=\"keyword\">final</span> Class&lt;? <span class=\"keyword\">super</span> T&gt; rawType = typeToken.getRawType();</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// .. 省略..</span></div><div class=\"line\">  </div><div class=\"line\">  <span class=\"comment\">// 获取无参构造函数构造对象</span></div><div class=\"line\">  ObjectConstructor&lt;T&gt; defaultConstructor = newDefaultConstructor(rawType);</div><div class=\"line\">  <span class=\"keyword\">if</span> (defaultConstructor != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> defaultConstructor;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"comment\">//...省略集合构造...</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// unsafe 方式去构造对象</span></div><div class=\"line\">  <span class=\"keyword\">return</span> newUnsafeAllocator(type, rawType);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>有意思，所以在构造对象的时候会先获取无参构造函数来构造对象，否则用 unSafe 的方式去构造对象。</p>\n<p><strong>反射小知识：unSafe 方式去构造对象，会绕过构造函数，只会在堆中去分配一个对象实例</strong></p>\n<p>那么我们大胆预测一下：<code>Person</code> 类通过无参构造函数来构造对象，执行了对象的初始化代码，给变量设置了默认值，而<code>Dog</code>类是通过 unSafe 的方式来构造的对象，没有给变量进行默认值设置，回到 adapter 解析json字段进行赋值的时候，json中有的字段就会覆盖变量的原始值，而没有的字段则不会覆盖，因此<code>Dog</code> 中的<code>name</code> 变量的值依然是<code>null</code> !</p>\n<p>经过断点验证推理是正确的。</p>\n<h3 id=\"那么问题来了\"><a href=\"#那么问题来了\" class=\"headerlink\" title=\"那么问题来了\"></a>那么问题来了</h3><p>为什么 <code>Person</code> 和 <code>Dog</code> 的构造方式不一样呢？我们利用 Android Studio 的工具来把这两个类变成 java 文件</p>\n<blockquote>\n<p>Tools &gt; Kotlin &gt; show kotlin byte code &gt; Decompile</p>\n</blockquote>\n<p>省略掉其他的代码，先看 <code>Dog</code>:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@SerializedName</span>(<span class=\"string\">\"name\"</span>)</div><div class=\"line\"> <span class=\"meta\">@NotNull</span></div><div class=\"line\"> <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String name;</div><div class=\"line\"></div><div class=\"line\"> <span class=\"meta\">@SerializedName</span>(<span class=\"string\">\"age\"</span>)</div><div class=\"line\"> <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> age;</div><div class=\"line\"></div><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Dog</span><span class=\"params\">(@NotNull String name, <span class=\"keyword\">int</span> age)</span> </span>&#123;</div><div class=\"line\">    Intrinsics.checkParameterIsNotNull(name, <span class=\"string\">\"name\"</span>);</div><div class=\"line\">    <span class=\"keyword\">super</span>();</div><div class=\"line\">    <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">    <span class=\"keyword\">this</span>.age = age;</div><div class=\"line\"> &#125;</div><div class=\"line\"></div><div class=\"line\"> <span class=\"comment\">// $FF: synthetic method</span></div><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Dog</span><span class=\"params\">(String var1, <span class=\"keyword\">int</span> var2, <span class=\"keyword\">int</span> var3, DefaultConstructorMarker var4)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> ((var3 &amp; <span class=\"number\">1</span>) != <span class=\"number\">0</span>) &#123;</div><div class=\"line\">       var1 = <span class=\"string\">\"no_name\"</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">this</span>(var1, var2);</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<p>再看 <code>Person</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@SerializedName</span>(<span class=\"string\">\"name\"</span>)</div><div class=\"line\"><span class=\"meta\">@NotNull</span></div><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String name;</div><div class=\"line\"><span class=\"meta\">@SerializedName</span>(<span class=\"string\">\"age\"</span>)</div><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> age;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Person</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">   <span class=\"keyword\">this</span>((String)<span class=\"keyword\">null</span>, <span class=\"number\">0</span>, <span class=\"number\">3</span>, (DefaultConstructorMarker)<span class=\"keyword\">null</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Person</span><span class=\"params\">(@NotNull String name, <span class=\"keyword\">int</span> age)</span> </span>&#123;</div><div class=\"line\">   Intrinsics.checkParameterIsNotNull(name, <span class=\"string\">\"name\"</span>);</div><div class=\"line\">   <span class=\"keyword\">super</span>();</div><div class=\"line\">   <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">   <span class=\"keyword\">this</span>.age = age;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// $FF: synthetic method</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Person</span><span class=\"params\">(String var1, <span class=\"keyword\">int</span> var2, <span class=\"keyword\">int</span> var3, DefaultConstructorMarker var4)</span> </span>&#123;</div><div class=\"line\">   <span class=\"keyword\">if</span> ((var3 &amp; <span class=\"number\">1</span>) != <span class=\"number\">0</span>) &#123;</div><div class=\"line\">      var1 = <span class=\"string\">\"no_name\"</span>;</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\">   <span class=\"keyword\">if</span> ((var3 &amp; <span class=\"number\">2</span>) != <span class=\"number\">0</span>) &#123;</div><div class=\"line\">      var2 = -<span class=\"number\">1</span>;</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\">   <span class=\"keyword\">this</span>(var1, var2);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>Person</code> 比 <code>Dog</code> 多一个无参的构造函数，这个构造函数调用的是 synthetic constructor， 即为变量赋上默认的值。而 <code>Dog</code> 因为有一个变量没有默认值，因此无法生成无参构造函数（必须要在构造的时候给它赋值）。</p>\n<h3 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h3><p>到这里就真相大白了。所以这种默认值应该怎么去处理，简单的说就是要想办法让这个类能有一个无参构造函数。我们已经知道第一种方案了：</p>\n<ul>\n<li>构造函数中的所有变量都设置默认值</li>\n</ul>\n<p>还有一种方案</p>\n<ul>\n<li>就是像Java一样去写：</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span></span>&#123;</div><div class=\"line\">  <span class=\"meta\">@SerializedName(<span class=\"meta-string\">\"name\"</span>)</span><span class=\"keyword\">var</span> name:String = <span class=\"string\">\"no_name\"</span></div><div class=\"line\">  <span class=\"meta\">@SerializedName(<span class=\"meta-string\">\"age\"</span>)</span><span class=\"keyword\">var</span> age:<span class=\"built_in\">Int</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这样，即便没有给 <code>age</code> 默认值，<code>name</code> 的默认值也一样会生效的。</p>\n","categories":["Android"],"tags":[]},{"title":"The End Of 2018","url":"https://joesteven.github.io/the_end_of_2018/","content":"<p>今年我跟很多朋友喝酒聊天的时候讲到过，17年到18年上半年过得很快，当我回想着一年半的时候除了工作似乎什么也想不起来。</p>\n<p>而18年下半年开始对我来说是奇妙的半年。</p>\n<h3 id=\"新\"><a href=\"#新\" class=\"headerlink\" title=\"新\"></a>新</h3><p>5月份我提交了离职申请，老大很诧异，这一年可以说是我职业生涯上升的黄金时期，技术上做基础框架开发，业务上带团队，公司在大家看来也以不可思议的速度在发展，我想没有多少人会做这个决定吧。但我还是做了，而且很坚决，直到现在还是会有人问我，你为什么要离开北京呢？甚至面试新公司的面试官也无法理解。</p>\n<p>原因有很多，最为重要的是去保护好另一个人对我的信任，这，很重要。</p>\n<blockquote>\n<p>新的一切都从回到重庆的那天开始，一切都熟悉，但是又很新，新的天气，朋友，食物和生活</p>\n</blockquote>\n<h3 id=\"四月\"><a href=\"#四月\" class=\"headerlink\" title=\"四月\"></a>四月</h3><p>一一跟北京的好朋友们道别。阿妹，语哥，东哥，周舸，崔老师，李志刚，熊老师，绍开… 很开心在北京的日子能认识这些优秀的朋友。</p>\n<h3 id=\"五月\"><a href=\"#五月\" class=\"headerlink\" title=\"五月\"></a>五月</h3><p>回到重庆的感觉真好，见了很多老友，喝了很多酒，说了很多话。</p>\n<p>用在头条拿到的还算丰厚的年终奖买了人生的第一辆车。</p>\n<p>毕业以后解散的乐队，终于在这个时候组建了起来，排练，写歌。</p>\n<h3 id=\"六月\"><a href=\"#六月\" class=\"headerlink\" title=\"六月\"></a>六月</h3><p>六月十五号 - 我们在一起整整七年的那天，她答应了我的求婚。</p>\n<p>在双方家长按照习俗挑选吉日在新家做完一顿饭后，我们搬进了属于自己的房子。</p>\n<p>一次性拔掉了两颗智齿，那期间很痛苦，之后很轻松。</p>\n<p>这个月的21号是我的生日，那天刚好是在新家做饭，也拔完牙，以至于我现在不太能想起来那天具体是怎么过的。</p>\n<h3 id=\"七月\"><a href=\"#七月\" class=\"headerlink\" title=\"七月\"></a>七月</h3><p>在休息了接近三个月后，重新开始工作，到现在为止，基本上朝九晚六，这可是在头条加班时候梦寐以求的，但人也许就是矛盾的，去北京不就是学习想要成为优秀的工程师吗？可这样的工作似乎让那段经历也可有可无。</p>\n<p>最好的兄弟，一个研究生毕业离开了重庆去了南京，一个工作去了安徽。离别的情绪是复杂的，不希望他们离开，但又为他们能开启自己新的人生而高兴。</p>\n<h3 id=\"八月\"><a href=\"#八月\" class=\"headerlink\" title=\"八月\"></a>八月</h3><p>毕业后就没再见面的室友赶回重庆，喝酒聊天到深夜</p>\n<h3 id=\"九月\"><a href=\"#九月\" class=\"headerlink\" title=\"九月\"></a>九月</h3><p>乐队因为成员无法拿出相同的时间精力，宣布解散。</p>\n<p>三儿这一年忙于生活工作，在音乐这条路上暂时停止和我一起前进。</p>\n<p>和二百成立害羞的梨音乐工作室，开始尝试以其他的形式去做音乐。</p>\n<p>itsCoder 有史以来最大的一次聚会，大家从各地赶往上海，住在一起，喝酒，游戏，聊天到深夜。</p>\n<p>组织参与策划猴哥求婚，那种感觉，很温暖。</p>\n<h3 id=\"十月\"><a href=\"#十月\" class=\"headerlink\" title=\"十月\"></a>十月</h3><p>工作去了安徽的兄弟，回河北邯郸结婚，这是我参加的第一个婚礼，很远但是很开心。</p>\n<p>参加完婚礼后和女朋友去西安玩儿，想想，已经两年没有出门旅游过了。</p>\n<p>我通过审核成为了网易云音乐人。</p>\n<p>十月底，发布了工作室的第一首歌。</p>\n<p>三弟来重庆，聊了很久，很开心。</p>\n<h3 id=\"十一月\"><a href=\"#十一月\" class=\"headerlink\" title=\"十一月\"></a>十一月</h3><p>自驾去了川西毕棚沟，很美，温泉很舒服。</p>\n<p>出差去上海，和 itsCoder 上海分部的大佬们聚会，第二天在猴哥的安排下去看了凌空soho。</p>\n<p>看着那些怀揣着梦想的年轻人们，突然怀念起了在北京的日子。</p>\n<h3 id=\"十二月\"><a href=\"#十二月\" class=\"headerlink\" title=\"十二月\"></a>十二月</h3><p>工作室发布了第二首歌，经过一段时间的学习和尝试，甩开了乐队对编曲方式的限制，开始尝试更多元的音乐。</p>\n<p>组织了一次大型的圣诞趴体，不仅开心，更希望在老友聚会的时候也能尝试更多元的方式。</p>\n<p>终于买到了喜欢了很久的 suhr 吉他，在这一年结束的时候送给自己的礼物。</p>\n<h3 id=\"旧\"><a href=\"#旧\" class=\"headerlink\" title=\"旧\"></a>旧</h3><p>写流水帐的感觉很好，因为不需要思考，这对我来说很好，填补了一些空白的时间线。回忆需要思考吗？回忆不需要思考，回忆的时候才需要思考。</p>\n<p>十二月之前我都以为自己是24岁，以为了很久，直到女朋友告诉我已经25了，那一刻，我竟然真的有一点难过，因为看起来，24和25是有很大的不同的，原本我站着20岁那边，很理直气壮的去继续相信我对人生的可能性的看法，而现在我站着独木桥的中间，从现在开始，我要三思而后行了吗？</p>\n<p>现在我开始思考了。</p>\n<p>越发的觉得人际交往的成本很高，也越发的觉得时间和精力的有限。学生时代的时候，会觉得很多情感事物是难以舍弃的，而现在却越发坦然的意识到，舍弃不一定是件坏事。这样会显得冷漠和无情吗？我想不会，只是不那么多情而已。</p>\n<p>对了，今年和两个朋友谈起过，人的压力来自哪里？是不是来自于那些盯着我们的眼睛呢？</p>\n<blockquote>\n<p>如果没有人看着我，我该多快乐  — 黑色信封</p>\n</blockquote>\n<p>我时常在想，人只被允许往高处走，当然，应该往高处走，可是，高处为什么只能有一处呢？路为什么只能有一条呢？当一个废物，在废物的领域往高处走，算不算呢？</p>\n<p>回来跟还在高三的弟弟聊天，我跟他说</p>\n<blockquote>\n<p>没有人，也不应该有人去规定你要过什么样的人生</p>\n</blockquote>\n<p>那我呢？我不知道。</p>\n<p>回首毕业的三年半，不知道是仗着年少还是生来如此，我体验了太多不同的意料之外，以后，我是否会过着一切都在意料之中的生活，谁知道呢？但是我应该会不停去试探我到底还有多少可能吧。</p>\n<h3 id=\"未来\"><a href=\"#未来\" class=\"headerlink\" title=\"未来\"></a>未来</h3><p>有一些现在已经计划要做的事情</p>\n<p>筹备制作一张个人专辑。</p>\n<p>想要尝试远程工作。</p>\n<p>健身，为了穿西装好看一点。</p>\n<p>结婚，为了穿西装。</p>\n","categories":["杂谈"],"tags":[]},{"title":"说说观察者模式和发布/订阅模式的区别","url":"https://joesteven.github.io/different_between_observe_and_publish/","content":"<blockquote>\n<p>文章来源：itsCoder 的 <a href=\"https://github.com/itsCoder/weeklyblog\" target=\"_blank\" rel=\"external\">WeeklyBolg</a> 项目</p>\n<p>itsCoder主页：<a href=\"http://itscoder.com/\" target=\"_blank\" rel=\"external\">http://itscoder.com/</a></p>\n<p>作者：<a href=\"http://extremej.itscoder.com/about/\" target=\"_blank\" rel=\"external\">阿风</a></p>\n<p>审阅者：<a href=\"https://ljuns.itscoder.com/\" target=\"_blank\" rel=\"external\">小山</a>，<a href=\"http://hymane.itscoder.com/\" target=\"_blank\" rel=\"external\">hymanme</a></p>\n</blockquote>\n<h3 id=\"为什么\"><a href=\"#为什么\" class=\"headerlink\" title=\"为什么\"></a>为什么</h3><p>为什么要写这篇文章？</p>\n<p>网上有相关的文章吗？当然有</p>\n<p>那你为什么还要写？我就是要写</p>\n<p>女票最近在学习设计模式，学到了观察者模式和发布/订阅模式，她看完了书以后对我说这有什么区别？于是我跟她说，这当然有区别，抄起笔就给她讲有什么区别。</p>\n<p>那讲懂了吗？当然没有</p>\n<p>为什么呢？她在乎的是你的态度（参考女票车发动不了的梗）</p>\n<p>所以我要写这篇文章。别问为什么，问就右上角。</p>\n<h3 id=\"直观对比\"><a href=\"#直观对比\" class=\"headerlink\" title=\"直观对比\"></a>直观对比</h3><p>废话不多说，先上图，看图是帮助理解最直观的方式。</p>\n<p><img src=\"https://github.com/JoeSteven/Note/blob/master/Tech/observe_publish_subscribe.png?raw=true\" alt=\"对比图\"></p>\n<p>这个图，应该说很直观的告诉了你，这两种设计模式有什么区别。</p>\n<p>那有什么区别呢？右…右边多了个方框？对啊，就是多了个方框。</p>\n<p>关键的问题是，为什么要比观察者模式多一个方框？</p>\n<h3 id=\"观察者模式\"><a href=\"#观察者模式\" class=\"headerlink\" title=\"观察者模式\"></a>观察者模式</h3><p>既然发布/订阅是比观察者模式多了一些东西，那么我们就先来看观察者模式。</p>\n<p>你可以去Google，可以在很多不同的文章看到这么一句话：<strong>定义对象间一种一对多的依赖关系</strong>。</p>\n<blockquote>\n<p><strong>观察者模式</strong>是<a href=\"https://zh.wikipedia.org/wiki/%E8%BB%9F%E4%BB%B6%E8%A8%AD%E8%A8%88%E6%A8%A1%E5%BC%8F\" target=\"_blank\" rel=\"external\">软件设计模式</a>的一种。在此种模式中，一个目标对象管理所有相依于它的观察者对象，并且在它本身的状态改变时主动发出通知。这通常透过呼叫各观察者所提供的方法来实现。此种模式通常被用来实时事件处理系统。 —— 维基百科</p>\n</blockquote>\n<p>简单来说就是，A 对象依赖 B 对象的某个状态变化来执行一些逻辑，那么 A 就需要观察 B 的某个状态，B 会在这个状态发生改变时通知 A，并且可以把描述这个状态的数据给A。</p>\n<p>能看明白不？我举个栗子</p>\n<blockquote>\n<p>大家都上过学吧，假设你是个学渣，你同桌是个学霸，今天要考试了，卷子发下来，你几乎一道题都不会做，于是你对同桌说：<strong>你做完了给我抄一下</strong>，你同桌做完了，拿胳膊肘捅你一下，把试卷往你这边挪。</p>\n</blockquote>\n<p>你是观察者，你同桌是被观察者，你观察的状态是你同桌做完了，你同桌的试卷是你要的数据，这个状态发生的时候你要处理的逻辑是抄答案。</p>\n<p>抄过作业的都知道，你不可能一直盯着你同桌或者一直问他写完没吧？<strong>在程序中，如果对象 A 一直不停的去获取 B 的某个状态来看有没有发生改变，这不是观察者模式，这是轮询。</strong></p>\n<p>那什么是一对多的依赖关系？</p>\n<blockquote>\n<p>你同桌是学霸，你同桌前后左右都跟你一样是学渣，你们都得抄他的，不然全不及格。明白了吗？</p>\n</blockquote>\n<p>维基百科那段话，最后一句— 此种模式通常被用来实时事件处理系统。</p>\n<p>我们回到程序中来，做为前端/客户端工程师最为常见的一种场景：一个按钮被点击了，程序打开一个页面。所谓的监听这个按钮的点击事件不就是一种观察者模式吗？</p>\n<h3 id=\"发布-订阅模式\"><a href=\"#发布-订阅模式\" class=\"headerlink\" title=\"发布/订阅模式\"></a>发布/订阅模式</h3><p>我们还是先看维基百科</p>\n<blockquote>\n<p>在<a href=\"https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84\" target=\"_blank\" rel=\"external\">软件架构</a>中，<strong>发布-订阅</strong>是一种<a href=\"https://zh.wikipedia.org/wiki/%E6%B6%88%E6%81%AF\" target=\"_blank\" rel=\"external\">消息</a><a href=\"https://zh.wikipedia.org/wiki/%E8%8C%83%E5%BC%8F\" target=\"_blank\" rel=\"external\">范式</a>，消息的发送者（称为发布者）不会将消息直接发送给特定的接收者（称为订阅者）。而是将发布的消息分为不同的类别，无需了解哪些订阅者（如果有的话）可能存在。同样的，订阅者可以表达对一个或多个类别的兴趣，只接收感兴趣的消息，无需了解哪些发布者（如果有的话）存在。</p>\n<p>发布/订阅是<a href=\"https://zh.wikipedia.org/wiki/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97\" target=\"_blank\" rel=\"external\">消息队列</a>范式的兄弟，通常是更大的<a href=\"https://zh.wikipedia.org/w/index.php?title=%E9%9D%A2%E5%90%91%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6&amp;action=edit&amp;redlink=1\" target=\"_blank\" rel=\"external\">面向消息中间件</a>系统的一部分。 —— 维基百科</p>\n</blockquote>\n<p>能看明白不？网上有很多类似下面的例子，在我看来并不是发布/订阅模式</p>\n<blockquote>\n<p>你在淘宝上看上了一款键盘，但是没货了，于是你给店家说到货了告诉我，店家说好的，到货了告诉你。</p>\n</blockquote>\n<p>我再举个栗子</p>\n<blockquote>\n<p>你看上了一款键盘，你找了个代购跟他说找到这个键盘就买给我，这个代购路子野有很多渠道，键盘到货后这些渠道商会告诉这个代购键盘到货了，代购买下来发给你</p>\n</blockquote>\n<p>前者和后者有什么区别？这两个例子中消息都是键盘，而第一个消息的发布者是店家，你是消息的接收方，你明确的知道这个键盘是这个店家的，店家也明确知道你买了这个键盘，键盘出了问题你能找这个店家售后。</p>\n<p>而后者消息的发布者是那个代购的某一个渠道商，代购是中间件，你是消息的接收方，你并不清楚这个键盘到底是哪家店的，那家店也并不清楚这个键盘最后是被谁买走了，键盘出了问题你都找不到店家售后。（不要跟我抬杠说现在代购也知道是在哪家店买的，我这个栗子是要说清楚发布/订阅的关键点）</p>\n<p>所以前者应该是观察者模式，后者才是发布订阅模式。</p>\n<p>回到程序中来，比方说一个应用区分登录状态和未登录状态的UI，很多不同的页面都可以实现登录的逻辑，在登录成功后，所有当前被打开的页面都需要更新UI。这种情况就可以使用发布/订阅模式，在某个页面登录成功后发布登录成功的事件，有中间件将这个事件分发给其他页面更新UI，<strong>注意其他页面关心的只是登录状态改变这件事，而不关心用户具体在哪个页面登录的</strong></p>\n<h3 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h3><p>这两种模式区别可以简单归结为是观察状态还是事件。</p>\n<p>观察者模式中</p>\n<ul>\n<li>状态发布者维护了一个观察者的列表，明确的知道有哪些观察者存在，将状态变化直接通知给观察者</li>\n<li>状态的观察者也明确的知道自己观察的状态是描述的哪一个对象</li>\n<li>甚至需要这种相互知道的关系来处理逻辑（比如需要明确知道哪一个按钮被点击，处理对应的逻辑）</li>\n</ul>\n<p>发布/订阅模式中</p>\n<ul>\n<li>事件的发布者只发布事件，不关心这个事件被谁获取了，通常将事件发给一个中间件，由中间件再去分发事件</li>\n<li>事件的订阅者只关心事件本身，不关心这个事件是谁发布的，通常在中间件中去注册观察某个事件</li>\n<li>中间件中去维护事件类别对应的订阅者列表，当收到事件后，去对应列表中通知订阅者们</li>\n</ul>\n<h3 id=\"场景\"><a href=\"#场景\" class=\"headerlink\" title=\"场景\"></a>场景</h3><p>最重要的是知道什么场景应该用什么设计模式。可以按以下原则来判断</p>\n<ul>\n<li>是否观察的是状态（明确知道状态源）</li>\n</ul>\n<p>如果被观察和观察双方需要明确知道对方，那就观察者模式，否则发布订阅模式</p>\n<ul>\n<li>一对一或者一对多的关系</li>\n</ul>\n<p>这个事件或者状态只有一个发布者，两种都可以用，再参考第一条</p>\n<ul>\n<li>多对多的关系</li>\n</ul>\n<p>首先所谓对多对的关系基本就可以确定传递的是事件，而不是状态，因为不同对象不应该发布相同的状态，不要犹豫选发布/订阅，如果你一定要用观察者模式来实现事件的传递，那么看下面这个图，耦合明白吗？另外考虑内存泄露反注册，用观察者模式你确定你都反注册完了？</p>\n<p><img src=\"https://github.com/JoeSteven/Note/blob/master/Tech/publish_apply.png?raw=true\" alt=\"多对多应用场景\"></p>\n<h3 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h3><p>设计模式的学习不要局限在书本概念上，在写代码的过程中，学习优秀源码的过程中都可能在默默的接触不同的设计模式。设计模式本身就是在解决程序中的场景合理化问题，在实践中去理解不同的设计模式，甚至去思考现有模式的变种去解决实际的场景问题。</p>\n","categories":["设计模式"],"tags":[]},{"title":"Android 中的长图片处理","url":"https://joesteven.github.io/android_long_picture_process/","content":"<blockquote>\n<p>作者：<a href=\"http://extremej.itscoder.com/about/\" target=\"_blank\" rel=\"external\">阿风</a></p>\n<p>审阅者：<a href=\"https://itsmelo.github.io/\" target=\"_blank\" rel=\"external\">Melo</a>，<a href=\"http://yongyu.itscoder.com/\" target=\"_blank\" rel=\"external\">用语</a></p>\n</blockquote>\n<p>最近太忙了，好久没有写东西了，itsCoder 也缺席了一期，感觉自己也好久没有学习新的东西了。不管再忙还是应该抽出时间来学习和锻炼，不然时刻感觉身体被掏空啊～</p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>图片处理在 Android 开发中是一个比较重要的技术，处理稍有不慎就可能会出现 oom 等情况，网上也有很多图片处理相关的文章，我在<a href=\"http://extremej.itscoder.com/volley_imageloader_source/\" target=\"_blank\" rel=\"external\">Volley 中的ImageLoader源码学习笔记</a>这篇文章中也分析了一些解决方案。同时开源社区也有一些优秀的图片处理框架－Glide,Fresco,Picasso 等。这篇文章不会再讲这些解决方案。</p>\n<p>我自己在业余时间做了一款图片应用，在实际的开发中我发现有一种特殊的情况，加载超长或者超宽的图片，并且随着拼图的越来越普及，以后这种长图的出现可能会变得更加的常见，这篇文章就来讲讲我在处理长图显示中遇到的坑。</p>\n<h3 id=\"Max-Texture-Size-问题\"><a href=\"#Max-Texture-Size-问题\" class=\"headerlink\" title=\"Max Texture Size 问题\"></a>Max Texture Size 问题</h3><p>在实际的开发中我使用的是 Glide 作为图片框架，但是我发现依然会有一些图片无法显示出来。通过 log 定位，我发现这些图片都比较长，并且抓到了这样一个异常：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">[WARN] : OpenGLRenderer: Bitmap too large to be uploaded into a texture (752x8546, max=8192x8192)</div></pre></td></tr></table></figure>\n<p>从字面意思来理解是当前图片的尺寸超过了 <code>OpenGL</code> 的渲染上限。最大值是 8192 而图片长度明显超过了最大长度。</p>\n<ul>\n<li><code>OpenGL</code> 是什么？</li>\n</ul>\n<blockquote>\n<p><strong>Open Graphics Library</strong> (<strong>OpenGL</strong>)<a href=\"https://en.wikipedia.org/wiki/OpenGL#cite_note-3\" target=\"_blank\" rel=\"external\">[3]</a><a href=\"https://en.wikipedia.org/wiki/OpenGL#cite_note-4\" target=\"_blank\" rel=\"external\">[4]</a> is a <a href=\"https://en.wikipedia.org/wiki/Language-independent_specification\" target=\"_blank\" rel=\"external\">cross-language</a>, <a href=\"https://en.wikipedia.org/wiki/Cross-platform\" target=\"_blank\" rel=\"external\">cross-platform</a> <a href=\"https://en.wikipedia.org/wiki/Application_programming_interface\" target=\"_blank\" rel=\"external\">application programming interface</a> (API) for rendering <a href=\"https://en.wikipedia.org/wiki/2D_computer_graphics\" target=\"_blank\" rel=\"external\">2D</a> and<a href=\"https://en.wikipedia.org/wiki/3D_computer_graphics\" target=\"_blank\" rel=\"external\">3D</a> <a href=\"https://en.wikipedia.org/wiki/Vector_graphics\" target=\"_blank\" rel=\"external\">vector graphics</a>. The API is typically used to interact with a <a href=\"https://en.wikipedia.org/wiki/Graphics_processing_unit\" target=\"_blank\" rel=\"external\">graphics processing unit</a> (GPU), to achieve <a href=\"https://en.wikipedia.org/wiki/Hardware_acceleration\" target=\"_blank\" rel=\"external\">hardware-accelerated</a><a href=\"https://en.wikipedia.org/wiki/Rendering_(computer_graphics\" target=\"_blank\" rel=\"external\">rendering</a>).</p>\n</blockquote>\n<p>维基百科上面是这样解释的。</p>\n<p>我自己对 <code>OpenGL</code> 并没有什么了解，这里也只是本着解决问题的想法，所以想要深入了解 <code>OpenGL</code> 的同学可以自行学习。简单来说就是图片的尺寸超过了 <code>OpenGL</code> 渲染的限制。</p>\n<h3 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h3><p>知道了问题的所在，就可以开始寻找解决方案了，寻找解决方案的过程就不细说了，直接抛出三个可行的方案来解决。</p>\n<ul>\n<li>调整图片尺寸</li>\n<li>局部显示图片</li>\n<li>关闭硬件加速</li>\n</ul>\n<p>目前我所寻找到的解决方案是这三种，其中第一种是最容易想到的，也是本篇文章重点讲解的。</p>\n<p>Android 在使用 <code>OpenGL</code> 去渲染图片的时候实际上开了硬件加速（不知道这么说对不对），所以最简单粗暴的方法就是在 <code>AndroidManifest.xml</code> 文件中去关闭硬件加速，当然这么做是不怎么清真的，可能会引起其他的问题。</p>\n<h3 id=\"调整图片尺寸\"><a href=\"#调整图片尺寸\" class=\"headerlink\" title=\"调整图片尺寸\"></a>调整图片尺寸</h3><p>resize 图片的尺寸大概每个开发者都会，因此这个方案里面最为重要的一个步骤是获取 max texture size ，通过测试发现不同的手机这个尺寸可能是不一样的。那么如何精确的获取当前手机的渲染限制大小呢？</p>\n<p>上 StackOverflow 上面搜了一下，大部分答案都给出了如下代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span>[] maxTextureSize = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">1</span>];</div><div class=\"line\">GLES10.glGetIntegerv(GL10.GL_MAX_TEXTURE_SIZE, maxTextureSize, <span class=\"number\">0</span>);</div></pre></td></tr></table></figure>\n<p>先别急着去试，如果你稍微仔细一点会发现这些答案后面基本都会有疑惑，这样获取到的值始终是 0。</p>\n<p>所以又换了个问题，为什么会是 0？搜到了这个答案：</p>\n<p><a href=\"http://stackoverflow.com/questions/26985858/gles10-glgetintegerv-returns-0-in-lollipop-only\" target=\"_blank\" rel=\"external\">http://stackoverflow.com/questions/26985858/gles10-glgetintegerv-returns-0-in-lollipop-only</a></p>\n<blockquote>\n<p>call to OpenGL ES API with no current context (logged once per thread)</p>\n<p>You need a current OpenGL context in your thread before you can make <strong>any</strong> OpenGL calls, which includes your <code>glGetIntegerv()</code> call. This was always true. But it seems like in pre-Lollipop, there was an OpenGL context that was created in the frameworks, and that was sometimes (always?) current when app code was called.</p>\n</blockquote>\n<p>在调用 OpenGL ES API 的时候没有一个 context。所以问题又变成了如何创建一个 OpenGL 的 context？因为这个回答已经相当详细，我只简单的翻译一下。</p>\n<ul>\n<li>创建 <code>GLSurfaceView</code>，这是最简单最方便的一种方法，但是该方法只有当你需要使用 OpenGL 来渲染展示画面的时候才具有实际意义。</li>\n<li>使用 <code>EGL14</code>来完成调用 <code>OpenGl</code> 的相关 API 前的准备工作，并且不需要真正的渲染画面。</li>\n</ul>\n<p>第一种方法在官方文档中给出了非常详细的教程－<a href=\"https://developer.android.com/reference/android/opengl/GLSurfaceView.html\" target=\"_blank\" rel=\"external\">GLSurfaceView</a></p>\n<p>第二种方法中的 <code>EGL14</code> 只支持到 API 17，如果要兼容到更低的系统需要使用 <code>EGL10</code>。</p>\n<h4 id=\"创建-OpenGL-Context\"><a href=\"#创建-OpenGL-Context\" class=\"headerlink\" title=\"创建 OpenGL Context\"></a>创建 OpenGL Context</h4><ul>\n<li>初始化 <code>EGLDisplay</code></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">EGLDisplay dpy = EGL14.eglGetDisplay(EGL14.EGL_DEFAULT_DISPLAY);</div><div class=\"line\"><span class=\"keyword\">int</span>[] vers = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">2</span>];</div><div class=\"line\">EGL14.eglInitialize(dpy, vers, <span class=\"number\">0</span>, vers, <span class=\"number\">1</span>);</div></pre></td></tr></table></figure>\n<ul>\n<li>做一些配置，因为我们只是获取下 texture size ，不需要真正的渲染，所以这些配置不是特别重要</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span>[] configAttr = &#123;</div><div class=\"line\">    EGL14.EGL_COLOR_BUFFER_TYPE, EGL14.EGL_RGB_BUFFER,</div><div class=\"line\">    EGL14.EGL_LEVEL, <span class=\"number\">0</span>,</div><div class=\"line\">    EGL14.EGL_RENDERABLE_TYPE, EGL14.EGL_OPENGL_ES2_BIT,</div><div class=\"line\">    EGL14.EGL_SURFACE_TYPE, EGL14.EGL_PBUFFER_BIT,</div><div class=\"line\">    EGL14.EGL_NONE</div><div class=\"line\">&#125;;</div><div class=\"line\">EGLConfig[] configs = <span class=\"keyword\">new</span> EGLConfig[<span class=\"number\">1</span>];</div><div class=\"line\"><span class=\"keyword\">int</span>[] numConfig = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">1</span>];</div><div class=\"line\">EGL14.eglChooseConfig(dpy, configAttr, <span class=\"number\">0</span>,</div><div class=\"line\">                      configs, <span class=\"number\">0</span>, <span class=\"number\">1</span>, numConfig, <span class=\"number\">0</span>);</div><div class=\"line\"><span class=\"keyword\">if</span> (numConfig[<span class=\"number\">0</span>] == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">    <span class=\"comment\">// TROUBLE! No config found.</span></div><div class=\"line\">&#125;</div><div class=\"line\">EGLConfig config = configs[<span class=\"number\">0</span>];</div></pre></td></tr></table></figure>\n<ul>\n<li>为了成为当前的 context，需要渲染一个 <code>SurfaceView</code>，但是我们又不想真的去渲染一个 <code>view</code> ，因此创建一个在屏幕外的小 <code>surface</code></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span>[] surfAttr = &#123;</div><div class=\"line\">    EGL14.EGL_WIDTH, <span class=\"number\">64</span>,</div><div class=\"line\">    EGL14.EGL_HEIGHT, <span class=\"number\">64</span>,</div><div class=\"line\">    EGL14.EGL_NONE</div><div class=\"line\">&#125;;</div><div class=\"line\">EGLSurface surf = EGL14.eglCreatePbufferSurface(dpy, config, surfAttr, <span class=\"number\">0</span>);</div></pre></td></tr></table></figure>\n<ul>\n<li>创建 <code>OpenGL context</code></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span>[] ctxAttrib = &#123;</div><div class=\"line\">    EGL14.EGL_CONTEXT_CLIENT_VERSION, <span class=\"number\">2</span>,</div><div class=\"line\">    EGL14.EGL_NONE</div><div class=\"line\">&#125;;</div><div class=\"line\">EGLContext ctx = EGL14.eglCreateContext(dpy, config, EGL14.EGL_NO_CONTEXT, ctxAttrib, <span class=\"number\">0</span>);</div></pre></td></tr></table></figure>\n<ul>\n<li>Make Current</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">EGL14.eglMakeCurrent(dpy, surf, surf, ctx);</div></pre></td></tr></table></figure>\n<p>到这儿我们的准备工作就做完了。</p>\n<p>接下来就是获取 max texture size</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span>[] maxSize = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">1</span>];</div><div class=\"line\">GLES20.glGetIntegerv(GLES20.GL_MAX_TEXTURE_SIZE, maxSize, <span class=\"number\">0</span>);</div></pre></td></tr></table></figure>\n<p>有了这个值，怎么去调整图片就看你自己了～</p>\n<h4 id=\"销毁-OpenGL-Context\"><a href=\"#销毁-OpenGL-Context\" class=\"headerlink\" title=\"销毁 OpenGL Context\"></a>销毁 OpenGL Context</h4><p>获取到了这个值以后就可以将这个上下文给销毁了</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">EGL14.eglMakeCurrent(dpy, EGL14.EGL_NO_SURFACE, EGL14.EGL_NO_SURFACE,</div><div class=\"line\">                     EGL14.EGL_NO_CONTEXT);</div><div class=\"line\">EGL14.eglDestroySurface(dpy, surf);</div><div class=\"line\">EGL14.eglDestroyContext(dpy, ctx);</div><div class=\"line\">EGL14.eglTerminate(dpy);</div></pre></td></tr></table></figure>\n<h3 id=\"局部显示图片\"><a href=\"#局部显示图片\" class=\"headerlink\" title=\"局部显示图片\"></a>局部显示图片</h3><p>第一种方案虽然解决了大部分长图的显示问题，但是依然会面临 OOM 的风险。尤其是当对图片的显示要求比较高时（高清大图），上一种方案似乎也不够完美。</p>\n<p><code>BitmapRegionDecoder</code> 似乎是一个不错的选择。</p>\n<blockquote>\n<p>BitmapRegionDecoder can be used to decode a rectangle region from an image. BitmapRegionDecoder is particularly useful when an original image is large and you only need parts of the image.</p>\n</blockquote>\n<p>这个类也是我最近才接触的，还没有用到实际的项目中去，但是感觉会是一个不错解决方案。目前在网上有一篇写的比较好的文章－<a href=\"http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/1021/3607.html\" target=\"_blank\" rel=\"external\">Android 高清加载巨图方案 拒绝压缩图片</a>，介绍的非常详细，也有 demo 可以学习。这个方案我就不再细说了，等具体用到项目中了再来看有没有什么值得补充的。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>这篇文章并没有太多原创的内容，毕竟涉及到问题解决的时候，一般都可以从网上找到答案。而这个问题是我实际开发中所碰到的，索性把较好的解决方案抛出来，也方便有同样需求的同学，如果你有更好的解决方案也非常希望你能分享出来。</p>\n","categories":["Android"],"tags":[]},{"title":"对 SharedPreferences 再多一点了解","url":"https://joesteven.github.io/shared_preferences_source/","content":"<blockquote>\n<p>作者：<a href=\"http://extremej.itscoder.com/about/\" target=\"_blank\" rel=\"external\">阿风</a></p>\n<p>审阅者：<a href=\"http://imxie.cc/\" target=\"_blank\" rel=\"external\">HugoXie</a>、 <a href=\"http://allenwu.itscoder.com/\" target=\"_blank\" rel=\"external\">allen</a></p>\n</blockquote>\n<h3 id=\"序言\"><a href=\"#序言\" class=\"headerlink\" title=\"序言\"></a>序言</h3><p>相信很多人面试的时候被问到过 Android 中的数据持久化，其中有一个方法就是使用 <code>SharedPreferences</code> 来保存一些简单的数据到本地。如果你对 <code>SharedPreferences</code> 还不了解，建议先阅读官方文档，再写个小 demo 实践一下。</p>\n<p><code>SharedPreferences</code> 用的比较多的同学可能知道，在 API9 以后加入了一个新的方法 <code>apply()</code> ，官方文档中可以看到在不关心返回值的情况下尽量使用 <code>apply()</code> 。另外 <code>SharedPreferences</code> 对于多进程的数据分享会出现不同步的情况，推荐阅读<a href=\"http://melodyxxx.com/2016/08/04/%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B8%AD%E5%AE%89%E5%85%A8%E7%9A%84%E4%BD%BF%E7%94%A8SharedPreferences/\" target=\"_blank\" rel=\"external\">多进程中安全的使用SharedPreferences</a> 。以上的问题是为什么呢？作为一个时刻保持好奇心的码农，今天就来学习一下 <code>SharedPreferences</code> 的源码。</p>\n<h3 id=\"源码解析\"><a href=\"#源码解析\" class=\"headerlink\" title=\"源码解析\"></a>源码解析</h3><p>本篇文章的解析思路主要是 <code>SharedPreferences</code> 的工作流程，重点分析 <code>commit()</code> 和<code>apply()</code> 的区别。 </p>\n<p><code>SharedPreferences</code> (以下简称 <code>SP</code>)是一个接口，贴一张图来看看他的结构：</p>\n<p><img src=\"/img/shared_preferences_1.png\" alt=\"SP 结构\"></p>\n<p>可以看到这个接口的结构本身不复杂，所有对数据进行改动的操作都在 <code>Editor</code> 接口内，另外还有一个 <code>SP</code> 操作的监听接口，好了，接下来就看看他的实现类 － <code>SharedPreferencesImpl</code> (以下简称 <code>SPI</code>)。</p>\n<h4 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> File mFile;</div><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> File mBackupFile;</div><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> mMode;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">private</span> Map&lt;String, Object&gt; mMap;     <span class=\"comment\">// guarded by 'this'</span></div><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mDiskWritesInFlight = <span class=\"number\">0</span>;  <span class=\"comment\">// guarded by 'this'</span></div><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> mLoaded = <span class=\"keyword\">false</span>;      <span class=\"comment\">// guarded by 'this'</span></div><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">long</span> mStatTimestamp;          <span class=\"comment\">// guarded by 'this'</span></div><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">long</span> mStatSize;               <span class=\"comment\">// guarded by 'this'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Object mWritingToDiskLock = <span class=\"keyword\">new</span> Object();</div><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Object mContent = <span class=\"keyword\">new</span> Object();</div><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> WeakHashMap&lt;OnSharedPreferenceChangeListener, Object&gt; mListeners =</div><div class=\"line\">        <span class=\"keyword\">new</span> WeakHashMap&lt;OnSharedPreferenceChangeListener, Object&gt;();</div><div class=\"line\"></div><div class=\"line\">SharedPreferencesImpl(File file, <span class=\"keyword\">int</span> mode) &#123;</div><div class=\"line\">    mFile = file; <span class=\"comment\">// 保存数据的文件</span></div><div class=\"line\">    mBackupFile = makeBackupFile(file); <span class=\"comment\">// 备份文件</span></div><div class=\"line\">    mMode = mode;</div><div class=\"line\">    mLoaded = <span class=\"keyword\">false</span>; <span class=\"comment\">// 导入文件标记</span></div><div class=\"line\">    mMap = <span class=\"keyword\">null</span>;</div><div class=\"line\">    startLoadFromDisk();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> File <span class=\"title\">makeBackupFile</span><span class=\"params\">(File prefsFile)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> File(prefsFile.getPath() + <span class=\"string\">\".bak\"</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>构造方法中初始化了一些成员变量，首先是保存数据用的文件，熟悉 <code>SP</code> 的同学应该都知道这是个 xml 文件，事实上是在 Context 中指定的，后面会讲到。接着就是初始化了一个备份文件，当数据写入失败时用于恢复数据，后面也会讲到。另外就是文件的访问权限，还初始化了一个 <code>Map</code> ，先来看看 <code>startLoadFromDisk()</code> 方法，代码比较长，省略了一些异常捕获的代码。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">startLoadFromDisk</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</div><div class=\"line\">        mLoaded = <span class=\"keyword\">false</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">new</span> Thread(<span class=\"string\">\"SharedPreferencesImpl-load\"</span>) &#123;</div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">synchronized</span> (SharedPreferencesImpl.<span class=\"keyword\">this</span>) &#123;</div><div class=\"line\">                loadFromDiskLocked();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;.start();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">loadFromDiskLocked</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">  \t\t<span class=\"comment\">// 判断是否已经加载过了</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (mLoaded) &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">  \t\t<span class=\"comment\">// 判断是否有备份文件，如果有，就把当前文件干掉，把备份文件转正</span></div><div class=\"line\">  \t\t<span class=\"comment\">// 后面会具体讲备份文件的操作逻辑，这里不懂没关系，不用纠结</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (mBackupFile.exists()) &#123;</div><div class=\"line\">            mFile.delete();</div><div class=\"line\">            mBackupFile.renameTo(mFile);</div><div class=\"line\">        &#125;</div><div class=\"line\">\t\t... 省略 ...</div><div class=\"line\">        Map map = <span class=\"keyword\">null</span>;</div><div class=\"line\">        StructStat stat = <span class=\"keyword\">null</span>;</div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">            stat = Os.stat(mFile.getPath()); <span class=\"comment\">// 获取文件的一些信息</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (mFile.canRead()) &#123;</div><div class=\"line\">                BufferedInputStream str = <span class=\"keyword\">null</span>;</div><div class=\"line\">                <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                    str = <span class=\"keyword\">new</span> BufferedInputStream(</div><div class=\"line\">                            <span class=\"keyword\">new</span> FileInputStream(mFile), <span class=\"number\">16</span>*<span class=\"number\">1024</span>);</div><div class=\"line\">                    map = XmlUtils.readMapXml(str); <span class=\"comment\">// 解析 xml 文件，存放到 map 中</span></div><div class=\"line\">                &#125; <span class=\"keyword\">catch</span> (XmlPullParserException e) &#123;</div><div class=\"line\">                   ... 省略 ...</div><div class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">                    IoUtils.closeQuietly(str);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (ErrnoException e) &#123;</div><div class=\"line\">        &#125;</div><div class=\"line\">        mLoaded = <span class=\"keyword\">true</span>; <span class=\"comment\">// 标记导入完成</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (map != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            mMap = map; <span class=\"comment\">// 存为成员变量</span></div><div class=\"line\">            mStatTimestamp = stat.st_mtime; <span class=\"comment\">// 获取文件时间戳</span></div><div class=\"line\">            mStatSize = stat.st_size; <span class=\"comment\">// 大小</span></div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            mMap = <span class=\"keyword\">new</span> HashMap&lt;String, Object&gt;();</div><div class=\"line\">        &#125;</div><div class=\"line\">        notifyAll(); <span class=\"comment\">// 唤醒其他等待线程</span></div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>这段代码看起来特别长，其实就做了一件事情，将 xml 文件解析后以键值对的形式存放到一个 <code>Map</code> 中，初始化也就算结束了。</p>\n<h4 id=\"读数据\"><a href=\"#读数据\" class=\"headerlink\" title=\"读数据\"></a>读数据</h4><p>想必你也猜到了，读取数据就是从 <code>mMap</code> 中去获取，比较简单：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getString</span><span class=\"params\">(String key, @Nullable String defValue)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</div><div class=\"line\">      \t<span class=\"comment\">// 如果文件还没有导入，会进入 wait() 状态</span></div><div class=\"line\">      \t<span class=\"comment\">// 上面代码中导入成功后会被唤醒</span></div><div class=\"line\">        awaitLoadedLocked(); </div><div class=\"line\">        String v = (String)mMap.get(key);</div><div class=\"line\">        <span class=\"keyword\">return</span> v != <span class=\"keyword\">null</span> ? v : defValue;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"写数据\"><a href=\"#写数据\" class=\"headerlink\" title=\"写数据\"></a>写数据</h4><p>写数据是 <code>Editor</code> 对象去操作的，首先获取一个 <code>Editor</code>，这里 Google 工程师还留下了一个 TODO :</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Editor <span class=\"title\">edit</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span> remove the need to call awaitLoadedLocked() when</span></div><div class=\"line\">    <span class=\"comment\">// requesting an editor.  will require some work on the</span></div><div class=\"line\">    <span class=\"comment\">// Editor, but then we should be able to do:</span></div><div class=\"line\">    <span class=\"comment\">//</span></div><div class=\"line\">    <span class=\"comment\">//      context.getSharedPreferences(..).edit().putString(..).apply()</span></div><div class=\"line\">    <span class=\"comment\">//</span></div><div class=\"line\">    <span class=\"comment\">// ... all without blocking.</span></div><div class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</div><div class=\"line\">        awaitLoadedLocked();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> EditorImpl();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>来看看链式调用的第一步，<code>putString()</code>:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Editor <span class=\"title\">putString</span><span class=\"params\">(String key, @Nullable String value)</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;String, Object&gt; mModified = Maps.newHashMap();</div><div class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</div><div class=\"line\">        mModified.put(key, value);</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>Editor</code> 中有一个 <code>Map</code> ，看名字是保存被修改的数据。</p>\n<p>接下来就是本文分析的重头戏了，提交修改有两个方法 <code>commit()</code> 和 <code>apply()</code>，先来看看官方文档中对于 <code>apply</code> 的描述</p>\n<blockquote>\n<p>Unlike <code>commit()</code>, which writes its preferences out to persistent storage synchronously, <code>apply()</code> commits its changes to the in-memory <code>SharedPreferences</code> immediately but starts an asynchronous commit to disk and you won’t be notified of any failures. If another editor on this SharedPreferences does a regular <code>commit()</code> while a <code>apply()</code> is still outstanding, the <code>commit()</code> will block until all async commits are completed as well as the commit itself.</p>\n</blockquote>\n<p>大意是 <code>commit</code> 写数据是同步操作（先这么理解，细节上并不是简单的同步），有返回值，而 <code>apply()</code> 是异步操作没有返回值。那我们先来看 <code>commit()</code></p>\n<h4 id=\"commit\"><a href=\"#commit\" class=\"headerlink\" title=\"commit()\"></a>commit()</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">commit</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">  \t<span class=\"comment\">// 先提交到内存中，并返回一个 mcr 对象</span></div><div class=\"line\">    MemoryCommitResult mcr = commitToMemory();</div><div class=\"line\">  \t<span class=\"comment\">// 写入文件中</span></div><div class=\"line\">    SharedPreferencesImpl.<span class=\"keyword\">this</span>.enqueueDiskWrite(</div><div class=\"line\">        mcr, <span class=\"keyword\">null</span> <span class=\"comment\">/* sync write on this thread okay */</span>);</div><div class=\"line\">    <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">      \t<span class=\"comment\">// 阻塞线程</span></div><div class=\"line\">        mcr.writtenToDiskLatch.await();</div><div class=\"line\">    &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">  \t<span class=\"comment\">// 回调</span></div><div class=\"line\">    notifyListeners(mcr);</div><div class=\"line\">    <span class=\"keyword\">return</span> mcr.writeToDiskResult;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这段代码很短，但是比较难懂，首先来看一下第一步 <code>commitToMemory()</code> 中代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> MemoryCommitResult <span class=\"title\">commitToMemory</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">  \t<span class=\"comment\">// 创建一个 mcr 对象，用于记录本次提交</span></div><div class=\"line\">    MemoryCommitResult mcr = <span class=\"keyword\">new</span> MemoryCommitResult();</div><div class=\"line\">    <span class=\"keyword\">synchronized</span> (SharedPreferencesImpl.<span class=\"keyword\">this</span>) &#123;</div><div class=\"line\">      \t<span class=\"comment\">// 如果当前有正在写入到文件中的任务</span></div><div class=\"line\">      \t<span class=\"comment\">// 复制一份数据</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (mDiskWritesInFlight &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">            mMap = <span class=\"keyword\">new</span> HashMap&lt;String, Object&gt;(mMap);</div><div class=\"line\">        &#125;</div><div class=\"line\">      \t<span class=\"comment\">// 并且把该 Map 作为即将要写入文件的数据源</span></div><div class=\"line\">        mcr.mapToWriteToDisk = mMap;</div><div class=\"line\">        mDiskWritesInFlight++; <span class=\"comment\">// 写任务 ＋1</span></div><div class=\"line\"></div><div class=\"line\">        ... listener 处理 略 ...</div><div class=\"line\">        <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (mClear) &#123;</div><div class=\"line\">                <span class=\"keyword\">if</span> (!mMap.isEmpty()) &#123;</div><div class=\"line\">                    mcr.changesMade = <span class=\"keyword\">true</span>;</div><div class=\"line\">                    mMap.clear();</div><div class=\"line\">                &#125;</div><div class=\"line\">                mClear = <span class=\"keyword\">false</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">\t\t\t<span class=\"comment\">// 遍历 mModified </span></div><div class=\"line\">            <span class=\"keyword\">for</span> (Map.Entry&lt;String, Object&gt; e : mModified.entrySet()) &#123;</div><div class=\"line\">                String k = e.getKey();</div><div class=\"line\">                Object v = e.getValue();</div><div class=\"line\">                <span class=\"comment\">// \"this\" is the magic value for a removal mutation. In addition,</span></div><div class=\"line\">                <span class=\"comment\">// setting a value to \"null\" for a given key is specified to be</span></div><div class=\"line\">                <span class=\"comment\">// equivalent to calling remove on that key.</span></div><div class=\"line\">                <span class=\"keyword\">if</span> (v == <span class=\"keyword\">this</span> || v == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                    <span class=\"keyword\">if</span> (!mMap.containsKey(k)) &#123;</div><div class=\"line\">                        <span class=\"keyword\">continue</span>;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    mMap.remove(k);</div><div class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                  \t<span class=\"comment\">// 将数据放到 mMap 中去</span></div><div class=\"line\">                    <span class=\"keyword\">if</span> (mMap.containsKey(k)) &#123;</div><div class=\"line\">                        Object existingValue = mMap.get(k);</div><div class=\"line\">                        <span class=\"keyword\">if</span> (existingValue != <span class=\"keyword\">null</span> &amp;&amp; existingValue.equals(v)) &#123;</div><div class=\"line\">                            <span class=\"keyword\">continue</span>;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    mMap.put(k, v);</div><div class=\"line\">                &#125;</div><div class=\"line\">\t\t\t\t<span class=\"comment\">// 标记修改</span></div><div class=\"line\">                mcr.changesMade = <span class=\"keyword\">true</span>;</div><div class=\"line\">                <span class=\"keyword\">if</span> (hasListeners) &#123;</div><div class=\"line\">                    mcr.keysModified.add(k);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">\t\t\t<span class=\"comment\">// 清空临时保存的数据</span></div><div class=\"line\">            mModified.clear();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> mcr;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>简单来说，提交到内存的这一步，就是将一开始 <code>Editor</code> 放入到临时修改的 <code>Map</code> 中的数据放入到 <code>SP</code> 的 <code>mMap</code> 中去，然后返回一个 <code>mcr</code> 对象用于标示这次提交结果。</p>\n<p>接下来就是第二步写入文件中 <code>enqueueDiskWrite(mcr, null )</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">enqueueDiskWrite</span><span class=\"params\">(<span class=\"keyword\">final</span> MemoryCommitResult mcr,</span></span></div><div class=\"line\">                              <span class=\"keyword\">final</span> Runnable postWriteRunnable) &#123;</div><div class=\"line\">  \t<span class=\"comment\">// 新建了一个写入文件的 Runnable 任务</span></div><div class=\"line\">    <span class=\"keyword\">final</span> Runnable writeToDiskRunnable = <span class=\"keyword\">new</span> Runnable() &#123;</div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">                <span class=\"keyword\">synchronized</span> (mWritingToDiskLock) &#123;</div><div class=\"line\">                  \t<span class=\"comment\">// 写入文件</span></div><div class=\"line\">                    writeToFile(mcr);</div><div class=\"line\">                &#125;</div><div class=\"line\">                <span class=\"keyword\">synchronized</span> (SharedPreferencesImpl.<span class=\"keyword\">this</span>) &#123;</div><div class=\"line\">                  <span class=\"comment\">// 成功后任务减一  </span></div><div class=\"line\">                  mDiskWritesInFlight--;</div><div class=\"line\">                &#125;</div><div class=\"line\">                <span class=\"keyword\">if</span> (postWriteRunnable != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                    postWriteRunnable.run();</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;;</div><div class=\"line\">\t<span class=\"comment\">// 判断当前提交是否为同步提交 条件是传入的第二个参数为 null</span></div><div class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> isFromSyncCommit = (postWriteRunnable == <span class=\"keyword\">null</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// Typical #commit() path with fewer allocations, doing a write on</span></div><div class=\"line\">    <span class=\"comment\">// the current thread.</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (isFromSyncCommit) &#123;</div><div class=\"line\">      \t<span class=\"comment\">// 同步提交</span></div><div class=\"line\">        <span class=\"keyword\">boolean</span> wasEmpty = <span class=\"keyword\">false</span>;</div><div class=\"line\">        <span class=\"keyword\">synchronized</span> (SharedPreferencesImpl.<span class=\"keyword\">this</span>) &#123;</div><div class=\"line\">          \t<span class=\"comment\">// 进行中的任务只有当前这一个</span></div><div class=\"line\">            wasEmpty = mDiskWritesInFlight == <span class=\"number\">1</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">if</span> (wasEmpty) &#123;</div><div class=\"line\">          \t<span class=\"comment\">// 同步提交开始</span></div><div class=\"line\">            writeToDiskRunnable.run();</div><div class=\"line\">            <span class=\"keyword\">return</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">\t<span class=\"comment\">// 如果不是同步提交，或者上面有多个任务，则加入到线程池队列中</span></div><div class=\"line\">    QueuedWork.singleThreadExecutor().execute(writeToDiskRunnable);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>再回去看 <code>commit()</code> 代码调用该方法时第二个参数确实是传的 <code>null</code>，也就是会走同步提交的逻辑，好像解释了 <code>commit()</code> 同步写数据的原因，但是，等等！如果当前写文件的任务有多个呢？发现还是会加入到线程池里面啊，这不就异步了么？！</p>\n<p>ps.如果你对线程池的原理感兴趣的话可以看看我这篇文章：<a href=\"http://extremej.itscoder.com/threadpoolexecutor_source/\" target=\"_blank\" rel=\"external\">ThreadPoolExecutor源码学习笔记</a>。</p>\n<p><strong>没错，当有多个进行中的写任务时，<code>commit()</code> 确实会异步提交，但是！<code>commit()</code>会等待异步执行完毕。</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// public final CountDownLatch writtenToDiskLatch = new CountDownLatch(1);</span></div><div class=\"line\">mcr.writtenToDiskLatch.await();</div></pre></td></tr></table></figure>\n<p>还记得这行代码么？<code>CountDownLatch</code> 的 <code>await()</code> 方法有什么作用？其实我一开始也不知道，看注释吧：</p>\n<blockquote>\n<p>Causes the current thread to wait until the latch has counted down to* zero, unless the thread is {@linkplain Thread#interrupt interrupted}.</p>\n</blockquote>\n<p>会阻塞当前线程，直到 <code>count</code> 到 0，可以看到 <code>mcr</code> 中的 <code>CountDownLatch</code> 的 <code>count</code> 为 1。</p>\n<p>那么是在什么时候被唤醒的呢？<code>writeToFile(mcr)</code> ，这个方法也是写入文件的核心逻辑，信息量有点大，慢慢的看，试着理解，后面会给出一张图：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// Note: must hold mWritingToDiskLock</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">writeToFile</span><span class=\"params\">(MemoryCommitResult mcr)</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// Rename the current file so it may be used as a backup during the next read</span></div><div class=\"line\">  \t<span class=\"comment\">// 将当前的文件作为备份</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (mFile.exists()) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (!mcr.changesMade) &#123;</div><div class=\"line\">            <span class=\"comment\">// 没有任何改变 不需要写</span></div><div class=\"line\">            mcr.setDiskWriteResult(<span class=\"keyword\">true</span>);</div><div class=\"line\">            <span class=\"keyword\">return</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">      \t<span class=\"comment\">// 如果备份文件不存在，当前文件作为备份，如果存在，直接删掉当前文件</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (!mBackupFile.exists()) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (!mFile.renameTo(mBackupFile)) &#123;</div><div class=\"line\">                Log.e(TAG, <span class=\"string\">\"Couldn't rename file \"</span> + mFile</div><div class=\"line\">                      + <span class=\"string\">\" to backup file \"</span> + mBackupFile);</div><div class=\"line\">                mcr.setDiskWriteResult(<span class=\"keyword\">false</span>);</div><div class=\"line\">                <span class=\"keyword\">return</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            mFile.delete();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// Attempt to write the file, delete the backup and return true as atomically as</span></div><div class=\"line\">    <span class=\"comment\">// possible.  If any exception occurs, delete the new file; next time we will restore</span></div><div class=\"line\">    <span class=\"comment\">// from the backup.</span></div><div class=\"line\">  \t<span class=\"comment\">// 尝试写文件，成功后干掉备份，如果失败了，干掉新文件，下一次恢复备份文件</span></div><div class=\"line\">    <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">        FileOutputStream str = createFileOutputStream(mFile);</div><div class=\"line\">        <span class=\"keyword\">if</span> (str == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            mcr.setDiskWriteResult(<span class=\"keyword\">false</span>);</div><div class=\"line\">            <span class=\"keyword\">return</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        XmlUtils.writeMapXml(mcr.mapToWriteToDisk, str);</div><div class=\"line\">        FileUtils.sync(str);</div><div class=\"line\">        str.close();</div><div class=\"line\">        ContextImpl.setFilePermissionsFromMode(mFile.getPath(), mMode, <span class=\"number\">0</span>);</div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">final</span> StructStat stat = Os.stat(mFile.getPath());</div><div class=\"line\">            <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</div><div class=\"line\">                mStatTimestamp = stat.st_mtime;</div><div class=\"line\">                mStatSize = stat.st_size;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (ErrnoException e) &#123;</div><div class=\"line\">            <span class=\"comment\">// Do nothing</span></div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"comment\">// Writing was successful, delete the backup file if there is one.</span></div><div class=\"line\">       \t<span class=\"comment\">// 写数据成功，干掉备份，</span></div><div class=\"line\">        mBackupFile.delete();</div><div class=\"line\">        mcr.setDiskWriteResult(<span class=\"keyword\">true</span>);</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125; <span class=\"keyword\">catch</span> (XmlPullParserException e) &#123;</div><div class=\"line\">        Log.w(TAG, <span class=\"string\">\"writeToFile: Got exception:\"</span>, e);</div><div class=\"line\">    &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</div><div class=\"line\">        Log.w(TAG, <span class=\"string\">\"writeToFile: Got exception:\"</span>, e);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">// Clean up an unsuccessfully written file</span></div><div class=\"line\">   \t<span class=\"comment\">// 到这儿就说明失败了，干掉新文件</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (mFile.exists()) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (!mFile.delete()) &#123;</div><div class=\"line\">            Log.e(TAG, <span class=\"string\">\"Couldn't clean up partially-written file \"</span> + mFile);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    mcr.setDiskWriteResult(<span class=\"keyword\">false</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setDiskWriteResult</span><span class=\"params\">(<span class=\"keyword\">boolean</span> result)</span> </span>&#123;</div><div class=\"line\">    writeToDiskResult = result;</div><div class=\"line\">    writtenToDiskLatch.countDown(); <span class=\"comment\">// 解除阻塞</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>整个写文件的过程就到此结束了，上面的代码中比较难理解的就是备份这个过程，<strong>首先要理解的是，在正常的情况下磁盘上只应该有一个文件，正常数据文件或者备份文件。</strong></p>\n<p>来看几个图帮助理解。</p>\n<ul>\n<li>首先是写数据，磁盘上没有备份文件：</li>\n</ul>\n<p><img src=\"/img/shared_perferences_2.png\" alt=\"写数据_1\"></p>\n<p>首先会把旧的文件作为备份（重命名为 .bak)，然后创建一个新的文件来写数据，如果成功就删除备份，如果失败就删除新文件，保留备份文件</p>\n<ul>\n<li><p>写数据，磁盘上有旧文件，也有备份文件</p>\n<p>刚刚说了正常情况下不会两个文件同时存在，这种情况通常是新文件写入失败，删除也失败了导致</p>\n</li>\n</ul>\n<p><img src=\"/img/shared_preferences_3.png\" alt=\"写文件_2\"></p>\n<p>这种情况下会直接把旧文件干掉，其他流程同上。</p>\n<ul>\n<li><p>读数据</p>\n<p>读数据有几种情况</p>\n<ul>\n<li>磁盘上只有一个 xml 文件</li>\n<li>磁盘上只有一个备份文件</li>\n<li>磁盘上两个都有</li>\n</ul>\n<p>前两种情况就不说了，反正只有一个可以读，第三种情况会优先读取备份文件，原因是写数据时失败，并且干掉脏数据文件也失败了。这段代码在 <code>loadFromDiskLocked()</code> 中。</p>\n</li>\n</ul>\n<p><img src=\"/img/shared_preferences_5.png\" alt=\"读文件\"></p>\n<p>有没有发现还有一种情况？</p>\n<p><strong>写文件成功，删除备份失败，第二次加载文件的时候会出现什么情况？</strong></p>\n<h4 id=\"apply\"><a href=\"#apply\" class=\"headerlink\" title=\"apply()\"></a>apply()</h4><p>分析 <code>commit()</code> 的时候基本已经把写数据的核心逻辑理出来了 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">apply</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">final</span> MemoryCommitResult mcr = commitToMemory();</div><div class=\"line\">    <span class=\"keyword\">final</span> Runnable awaitCommit = <span class=\"keyword\">new</span> Runnable() &#123;</div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">                <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                    mcr.writtenToDiskLatch.await();</div><div class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException ignored) &#123;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;;</div><div class=\"line\"></div><div class=\"line\">    QueuedWork.add(awaitCommit);</div><div class=\"line\"></div><div class=\"line\">    Runnable postWriteRunnable = <span class=\"keyword\">new</span> Runnable() &#123;</div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">                awaitCommit.run();</div><div class=\"line\">                QueuedWork.remove(awaitCommit);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;;</div><div class=\"line\"></div><div class=\"line\">    SharedPreferencesImpl.<span class=\"keyword\">this</span>.enqueueDiskWrite(mcr, postWriteRunnable);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// Okay to notify the listeners before it's hit disk</span></div><div class=\"line\">    <span class=\"comment\">// because the listeners should always get the same</span></div><div class=\"line\">    <span class=\"comment\">// SharedPreferences instance back, which has the</span></div><div class=\"line\">    <span class=\"comment\">// changes reflected in memory.</span></div><div class=\"line\">    notifyListeners(mcr);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>apply()</code> 在调用 <code>enqueueDiskWrite()</code> 时传入了第二个参数，会加入到线程池中异步处理，且没有返回值</p>\n<h4 id=\"监听\"><a href=\"#监听\" class=\"headerlink\" title=\"监听\"></a>监听</h4><p>可能很多人都不知道，<code>SP</code> 是有一个监听接口的，在文章最开头的结构图里面也能看到</p>\n<p><code>OnSharedPreferenceChangeListener</code>，知道有监听没什么用，重要的是知道什么时候会回调，这个 listener 只有一个方法 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onSharedPreferenceChanged</span><span class=\"params\">(SharedPreferences sharedPreferences, String key)</span></span>;</div></pre></td></tr></table></figure>\n<blockquote>\n<p>Called when a shared preference is changed, added, or removed. This may be called even if a preference is set to its existing value.  </p><p>This callback will be run on your main thread.</p>\n</blockquote>\n<p>这个回调会在主线程中，来看代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">notifyListeners</span><span class=\"params\">(<span class=\"keyword\">final</span> MemoryCommitResult mcr)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (mcr.listeners == <span class=\"keyword\">null</span> || mcr.keysModified == <span class=\"keyword\">null</span> ||</div><div class=\"line\">        mcr.keysModified.size() == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">  \t<span class=\"comment\">// 如果当前是在主线程中，遍历发生改变的 key (删除，修改，增加等)</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (Looper.myLooper() == Looper.getMainLooper()) &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = mcr.keysModified.size() - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</div><div class=\"line\">          \t<span class=\"comment\">// 这个 key 会在提交到内存的时候被记录下来</span></div><div class=\"line\">            <span class=\"keyword\">final</span> String key = mcr.keysModified.get(i);</div><div class=\"line\">            <span class=\"keyword\">for</span> (OnSharedPreferenceChangeListener listener : mcr.listeners) &#123;</div><div class=\"line\">                <span class=\"keyword\">if</span> (listener != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                    listener.onSharedPreferenceChanged(SharedPreferencesImpl.<span class=\"keyword\">this</span>, key);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"comment\">// Run this function on the main thread.</span></div><div class=\"line\">      \t<span class=\"comment\">// 如果不是在主线程中，切换到主线程</span></div><div class=\"line\">        ActivityThread.sMainThreadHandler.post(<span class=\"keyword\">new</span> Runnable() &#123;</div><div class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">                    notifyListeners(mcr);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>返回去看 <code>commit()</code> 和 <code>apply()</code> 可以看到最后调用了这个方法。注册和取消监听的方法是</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">registerOnSharedPreferenceChangeListener</span><span class=\"params\">(OnSharedPreferenceChangeListener listener)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">synchronized</span>(<span class=\"keyword\">this</span>) &#123;</div><div class=\"line\">        mListeners.put(listener, mContent);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">unregisterOnSharedPreferenceChangeListener</span><span class=\"params\">(OnSharedPreferenceChangeListener listener)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">synchronized</span>(<span class=\"keyword\">this</span>) &#123;</div><div class=\"line\">            mListeners.remove(listener);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p><strong>注意每一个被修改的 key 都会以回调的方式依次被传递给监听者</strong></p>\n<h3 id=\"getSharedPreferences\"><a href=\"#getSharedPreferences\" class=\"headerlink\" title=\"getSharedPreferences()\"></a>getSharedPreferences()</h3><p>看完了 <code>SP</code> 中的代码，还有件事情没搞清楚，<code>SP</code> 是被谁创建的？又是怎么管理的？在 <code>Context</code> 中有一个方法 <code>getSharedPreferences(String name, int mode)</code> ,这是个抽象方法，在 <code>ContextImpl</code> 中实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\">* Map from package name, to preference name, to cached preferences.</div><div class=\"line\">*/</div><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> ArrayMap&lt;String, ArrayMap&lt;String, SharedPreferencesImpl&gt;&gt; sSharedPrefs;</div><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> SharedPreferences <span class=\"title\">getSharedPreferences</span><span class=\"params\">(String name, <span class=\"keyword\">int</span> mode)</span> </span>&#123;</div><div class=\"line\">    SharedPreferencesImpl sp;</div><div class=\"line\">    <span class=\"keyword\">synchronized</span> (ContextImpl.class) &#123;</div><div class=\"line\">      \t<span class=\"comment\">// 全局管理不同进程中的 sp</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (sSharedPrefs == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            sSharedPrefs = </div><div class=\"line\">              <span class=\"keyword\">new</span> ArrayMap&lt;String, ArrayMap&lt;String, SharedPreferencesImpl&gt;&gt;();</div><div class=\"line\">        &#125;</div><div class=\"line\">\t\t</div><div class=\"line\">        <span class=\"keyword\">final</span> String packageName = getPackageName();</div><div class=\"line\">      \t<span class=\"comment\">// 通过包名来获取当前进程下的所有 sp</span></div><div class=\"line\">        ArrayMap&lt;String, SharedPreferencesImpl&gt; packagePrefs = sSharedPrefs.get(packageName);</div><div class=\"line\">        <span class=\"keyword\">if</span> (packagePrefs == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            packagePrefs = <span class=\"keyword\">new</span> ArrayMap&lt;String, SharedPreferencesImpl&gt;();</div><div class=\"line\">            sSharedPrefs.put(packageName, packagePrefs);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// At least one application in the world actually passes in a null</span></div><div class=\"line\">        <span class=\"comment\">// name.  This happened to work because when we generated the file name</span></div><div class=\"line\">        <span class=\"comment\">// we would stringify it to \"null.xml\".  Nice.</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (mPackageInfo.getApplicationInfo().targetSdkVersion &lt;</div><div class=\"line\">                Build.VERSION_CODES.KITKAT) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (name == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                name = <span class=\"string\">\"null\"</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">\t\t<span class=\"comment\">// 根据名字获取 sp</span></div><div class=\"line\">        sp = packagePrefs.get(name);</div><div class=\"line\">        <span class=\"keyword\">if</span> (sp == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            File prefsFile = getSharedPrefsFile(name);</div><div class=\"line\">            sp = <span class=\"keyword\">new</span> SharedPreferencesImpl(prefsFile, mode);</div><div class=\"line\">            packagePrefs.put(name, sp);</div><div class=\"line\">            <span class=\"keyword\">return</span> sp;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> ((mode &amp; Context.MODE_MULTI_PROCESS) != <span class=\"number\">0</span> ||</div><div class=\"line\">        getApplicationInfo().targetSdkVersion &lt; android.os.Build.VERSION_CODES.HONEYCOMB) &#123;</div><div class=\"line\">        <span class=\"comment\">// If somebody else (some other process) changed the prefs</span></div><div class=\"line\">        <span class=\"comment\">// file behind our back, we reload it.  This has been the</span></div><div class=\"line\">        <span class=\"comment\">// historical (if undocumented) behavior.</span></div><div class=\"line\">        sp.startReloadIfChangedUnexpectedly();</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> sp;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> File <span class=\"title\">getSharedPrefsFile</span><span class=\"params\">(String name)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> makeFilename(getPreferencesDir(), name + <span class=\"string\">\".xml\"</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>分析完了 <code>SP</code> ，多少还是总结一下，其实官方文档已经写得很清楚了</p>\n<ul>\n<li><code>commit()</code> 是同步提交到内存后再同步提交到磁盘上，如果 <code>commit()</code> 之前还有没结束的异步任务（包括 <code>apply()</code> 的提交），就会一直阻塞到前面的提交都完成，才进行提交。</li>\n<li><code>apply()</code> 是立即提交到内存后异步提交到磁盘上。</li>\n<li><code>commit()</code> 有返回值，而 <code>apply</code> 没有返回值。</li>\n<li>存在内存与磁盘数据不同步的情况，多进程共享需要注意数据安全。</li>\n<li><code>SP</code> 是可以注册监听的。</li>\n</ul>\n<p><strong>大部分同学可能都知道 <code>SP</code> 是基于 xml 进行读写的，自然会担心并发读写的效率问题，事实上通过源码分析可以发现，用 HashMap 作为内存缓存，而 HashMap 的读和写操作效率是非常高的，所以也不应该有 sp 读写耗时的担忧</strong> — <a href=\"http://allenwu.itscoder.com/\" target=\"_blank\" rel=\"external\">allen</a></p>\n<p>最后感谢小刚和三弟的认真审阅和建设性意见。</p>\n","categories":["Android源码学习"],"tags":[]},{"title":"Activity 共享元素转场动画实践","url":"https://joesteven.github.io/zoom-up-animation/","content":"<ul>\n<li>作者：<a href=\"http://extremej.itscoder.com/\" target=\"_blank\" rel=\"external\">阿风</a></li>\n<li>审阅者：<a href=\"http://brucezz.itscoder.com/\" target=\"_blank\" rel=\"external\">Brucezz</a></li>\n</ul>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>上次碰到个需求，要从 Feed 页以 item 放大的动画打开第二个页面，先来看一个效果：</p>\n<p><img src=\"http://7xtakx.com1.z0.glb.clouddn.com/zoom_up.gif\" alt=\"效果图\"></p>\n<p>就是这样一个转场动画～有了思路后要实现起来还是不难</p>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><h4 id=\"1-API\"><a href=\"#1-API\" class=\"headerlink\" title=\"1.API\"></a>1.API</h4><p>一般我在需要实现某个功能的时候，会首先寻找 Android 是否已经提供了相关的 Api ，这样可以避免盲目的造轮子，尤其对于项目来说，时间成本还是很重要的，而且 Android 提供的 Api 使用起来一般也会更简单易于维护。</p>\n<p>事实上在 Android 5.0 确实提供了这样的 Api — <code>ActivityOptions</code> 以及兼容包 <code>ActivityOptionsCompat</code>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">ActivityOptionsCompat.makeCustomAnimation(Context context, <span class=\"keyword\">int</span> enterResId, <span class=\"keyword\">int</span> exitResId)</div><div class=\"line\">ActivityOptionsCompat.makeScaleUpAnimation(View source,<span class=\"keyword\">int</span> startX, <span class=\"keyword\">int</span> startY, <span class=\"keyword\">int</span> startWidth, <span class=\"keyword\">int</span> startHeight)</div><div class=\"line\">ActivityOptionsCompat.makeThumbnailScaleUpAnimation(View source,Bitmap thumbnail, <span class=\"keyword\">int</span> startX, <span class=\"keyword\">int</span> startY)</div><div class=\"line\">ActivityOptionsCompat.makeSceneTransitionAnimation(Activity activity, View sharedElement, String sharedElementName)</div><div class=\"line\">ActivityOptionsCompat.makeSceneTransitionAnimation(Activity activity,Pair&lt;View, String&gt;… sharedElements)</div></pre></td></tr></table></figure>\n<p>这个类使用非常的简单，总共提供了五种方法来实现不同的动画效果，其中就包括我们需要的这种效果。所以一开始我是选择了用 Api 来实现，但是很快发现了有一些问题：</p>\n<ul>\n<li><p><code>makeScaleUpAnimation</code>可以实现我们需要的效果，但是在5.0及以下的手机上效果并不好，会闪屏。（看了下快手貌似是用这个方法实现的，测试发现有同样的问题）</p>\n</li>\n<li><p>后面两个效果较好的共享元素的方法在 5.0 以下的手机上无效果</p>\n</li>\n<li><p>虽然提供了兼容包，但是兼容包的作用仅仅是保证在低版本的系统上不会崩溃，但是不会有效果</p>\n<p>由于我希望兼容到更低的版本上去，因此不得不放弃这个方案，如果你不需要兼容的话可以参考这篇文章来实现炫酷的转场动画<a href=\"https://www.kancloud.cn/qibin0506/android-md/117682\" target=\"_blank\" rel=\"external\">你所不知道的Activity转场动画——ActivityOptions</a>。</p>\n</li>\n</ul>\n<h4 id=\"2-实现思路\"><a href=\"#2-实现思路\" class=\"headerlink\" title=\"2.实现思路\"></a>2.实现思路</h4><p>通过使用 ActivityOptions 可以得出一个思路</p>\n<ul>\n<li>共享元素 — 两个 <code>Activity</code> 间有相同内容的 <code>View</code></li>\n<li>TargetView — 第二个页面的 <code>View</code> 来执行动画</li>\n<li>执行动画的过程中，第二个 <code>Activity</code> 背景透明</li>\n</ul>\n<p>明确了这三个关键点之后，实现起来就清晰很多，事实上这个思路不仅可以实现 <code>Activity</code> 间的动画跳转，一样可以适用于同一个 <code>Activity</code> 中的其它放大动画，例如点击头像出现大图，没有必要再开一个新的 <code>Activity</code>。</p>\n<p>所以我们要做的是封装一个工具类，更加通用的执行动画。</p>\n<h3 id=\"封装动画工具类\"><a href=\"#封装动画工具类\" class=\"headerlink\" title=\"封装动画工具类\"></a>封装动画工具类</h3><p>我们首先不去考虑 <code>Activity</code> 具体要怎么执行动画，先来封装一个动画的工具类。 </p>\n<h4 id=\"1-获取共享元素的初始信息\"><a href=\"#1-获取共享元素的初始信息\" class=\"headerlink\" title=\"1.获取共享元素的初始信息\"></a>1.获取共享元素的初始信息</h4><p>我们封装一个工具类 — <code>ZoomAnimationUtils</code>，在这个类中定义一个 <code>ZoomInfo</code> model：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ZoomInfo</span> <span class=\"keyword\">implements</span> <span class=\"title\">Parcelable</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> screenX;</div><div class=\"line\">    <span class=\"keyword\">int</span> screenY;</div><div class=\"line\">    <span class=\"keyword\">int</span> width;</div><div class=\"line\">    <span class=\"keyword\">int</span> height;</div><div class=\"line\">  ... 省略其它内容 ...</div><div class=\"line\">｝</div></pre></td></tr></table></figure>\n<p>这个类用于获取动画开始时 <code>View</code> 在屏幕上的位置，大小。实现序列化是为了在 <code>Activity</code> 之间能通过 <code>Intent</code> 传递。然后在 <code>ZoomAnimationUtils</code>  中封装一个获取 <code>ZoomInfo</code>  方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ZoomAnimationUtils.<span class=\"function\">ZoomInfo <span class=\"title\">getZoomInfo</span><span class=\"params\">(@NonNull View view)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span>[] screenLocation = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">2</span>];</div><div class=\"line\">    view.getLocationOnScreen(screenLocation);</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ZoomInfo(screenLocation[<span class=\"number\">0</span>],</div><div class=\"line\">                        screenLocation[<span class=\"number\">1</span>],</div><div class=\"line\">                        view.getWidth(),</div><div class=\"line\">                        view.getHeight());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"2-封装动画执行接口\"><a href=\"#2-封装动画执行接口\" class=\"headerlink\" title=\"2.封装动画执行接口\"></a>2.封装动画执行接口</h4><p>在这个需求中我们至少需要提供两个方法，一个放大，一个缩小。先来写放大的动画，想一想我们需要哪些参数？</p>\n<ul>\n<li>第一个共享元素的信息 <code>ZoomInfo</code> (也就是效果图中列表里小图的信息)</li>\n<li>第二个共享元素 <code>TargetView</code>  ，在这个 <code>View</code>  上来执行动画</li>\n<li>Listener ，给调用者提供监听动画执行的回调 </li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">startZoomUpAnim</span><span class=\"params\">(<span class=\"keyword\">final</span> ZoomInfo preViewInfo,</span></span></div><div class=\"line\">                                   <span class=\"keyword\">final</span> View targetView,</div><div class=\"line\">                                   <span class=\"keyword\">final</span> Animator.AnimatorListener listener) &#123;</div><div class=\"line\">    </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>首先我们要将 <code>targetView</code> 的初始属性设置为 <code>preViewInfo</code> ，跟小图一样，因此要在 <code>onDraw</code> 之前就把这件事情先做完，系统提供了一个方法 <code>onPreDraw()</code> 很好的让我们来做这件事情，在上面的方法中添加下面的代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">targetView.getViewTreeObserver().addOnPreDrawListener(<span class=\"keyword\">new</span> ViewTreeObserver.OnPreDrawListener() &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onPreDraw</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">      <span class=\"comment\">// 务必记得 remove 掉 </span></div><div class=\"line\">        targetView.getViewTreeObserver().removeOnPreDrawListener(<span class=\"keyword\">this</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>开始计算开始的状态值，体力活～把逻辑先理清楚再计算，否则会掉入一直调试的怪圈中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> startWidth = preViewInfo.getWidth();</div><div class=\"line\"><span class=\"keyword\">int</span> startHeight = preViewInfo.getHeight();</div><div class=\"line\"><span class=\"keyword\">int</span> endWidth = targetView.getWidth();</div><div class=\"line\"><span class=\"keyword\">int</span> endHeight = targetView.getHeight();</div><div class=\"line\"><span class=\"keyword\">int</span>[] screenLocation = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">2</span>];</div><div class=\"line\">targetView.getLocationOnScreen(screenLocation);</div><div class=\"line\"><span class=\"keyword\">int</span> endX = screenLocation[<span class=\"number\">0</span>];</div><div class=\"line\"><span class=\"keyword\">int</span> endY = screenLocation[<span class=\"number\">1</span>];</div><div class=\"line\"><span class=\"keyword\">float</span> startScaleX = (<span class=\"keyword\">float</span>) endWidth / startWidth;</div><div class=\"line\"><span class=\"keyword\">float</span> startScaleY = (<span class=\"keyword\">float</span>) endHeight / startHeight;</div><div class=\"line\"><span class=\"keyword\">int</span> translationX = preViewInfo.getScreenX() - endX;</div><div class=\"line\"><span class=\"keyword\">int</span> translationY = preViewInfo.getScreenY() - endY;</div><div class=\"line\"></div><div class=\"line\">targetView.setPivotX(<span class=\"number\">0</span>);</div><div class=\"line\">targetView.setPivotY(<span class=\"number\">0</span>);</div><div class=\"line\">targetView.setTranslationX(translationX);</div><div class=\"line\">targetView.setTranslationY(translationY);</div><div class=\"line\">targetView.setScaleX(<span class=\"number\">1</span> / startScaleX);</div><div class=\"line\">targetView.setScaleY(<span class=\"number\">1</span> / startScaleY);</div></pre></td></tr></table></figure>\n<p>上面这步做完后，就得到了一个在屏幕上与小图一样的一个 <code>View</code>  啦，现在来执行动画：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">targetView.setVisibility(View.VISIBLE);</div><div class=\"line\">ViewPropertyAnimator animator = targetView.animate();</div><div class=\"line\">animator.setDuration(ANIMATION_DURATION)</div><div class=\"line\">        .scaleX(<span class=\"number\">1f</span>)</div><div class=\"line\">        .scaleY(<span class=\"number\">1f</span>)</div><div class=\"line\">        .translationX(<span class=\"number\">0</span>)</div><div class=\"line\">        .translationY(<span class=\"number\">0</span>);</div><div class=\"line\"><span class=\"keyword\">if</span> (listener != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">    animator.setListener(listener);</div><div class=\"line\">&#125;</div><div class=\"line\">animator.start();</div></pre></td></tr></table></figure>\n<p>放大的动画就写完了～接下来我们写缩小的动画，思路与放大一样，但是有个小区别，我们缩小的动画实际也是大的那个 <code>View</code>  来执行，这个 <code>View</code> 当前的状态就是动画开始的初始状态，因此不需要做初始化：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">startZoomDownAnim</span><span class=\"params\">(ZoomInfo preViewInfo, <span class=\"keyword\">final</span> View targetView, <span class=\"keyword\">final</span> Animator.AnimatorListener listener)</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> endWidth = preViewInfo.getWidth();</div><div class=\"line\">    <span class=\"keyword\">int</span> endHeight = preViewInfo.getHeight();</div><div class=\"line\">    <span class=\"keyword\">int</span> startWidth = targetView.getWidth();</div><div class=\"line\">    <span class=\"keyword\">int</span> startHeight = targetView.getHeight();</div><div class=\"line\">    <span class=\"keyword\">int</span> endX = preViewInfo.getScreenX();</div><div class=\"line\">    <span class=\"keyword\">int</span> endY = preViewInfo.getScreenY();</div><div class=\"line\">    <span class=\"keyword\">float</span> endScaleX = (<span class=\"keyword\">float</span>) endWidth / startWidth;</div><div class=\"line\">    <span class=\"keyword\">float</span> endScaleY = (<span class=\"keyword\">float</span>) endHeight / startHeight;</div><div class=\"line\">    <span class=\"keyword\">int</span>[] screenLocation = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">2</span>];</div><div class=\"line\">    targetView.getLocationOnScreen(screenLocation);</div><div class=\"line\">    <span class=\"keyword\">int</span> startX = screenLocation[<span class=\"number\">0</span>];</div><div class=\"line\">    <span class=\"keyword\">int</span> startY = screenLocation[<span class=\"number\">1</span>];</div><div class=\"line\">    <span class=\"keyword\">int</span> translationX = endX - startX;</div><div class=\"line\">    <span class=\"keyword\">int</span> translationY = endY - startY;</div><div class=\"line\"></div><div class=\"line\">    targetView.setPivotX(<span class=\"number\">0</span>);</div><div class=\"line\">    targetView.setPivotY(<span class=\"number\">0</span>);</div><div class=\"line\">    targetView.setVisibility(View.VISIBLE);</div><div class=\"line\">    ViewPropertyAnimator animator = targetView.animate();</div><div class=\"line\">    animator.setDuration(ANIMATION_DURATION)</div><div class=\"line\">            .scaleX(endScaleX)</div><div class=\"line\">            .scaleY(endScaleY)</div><div class=\"line\">            .translationX(translationX)</div><div class=\"line\">            .translationY(translationY);</div><div class=\"line\">    <span class=\"keyword\">if</span> (listener != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        animator.setListener(listener);</div><div class=\"line\">    &#125;</div><div class=\"line\">  \tanimator.start();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"实现-Activity-转场动画\"><a href=\"#实现-Activity-转场动画\" class=\"headerlink\" title=\"实现 Activity 转场动画\"></a>实现 Activity 转场动画</h3><h4 id=\"1-进入动画\"><a href=\"#1-进入动画\" class=\"headerlink\" title=\"1.进入动画\"></a>1.进入动画</h4><p>上一步我们已经把动画封装好了，现在我们需要实现 <code>Activity</code>  的转场动画，还记得最开始的那个三个关键点中有一点，将 <code>Activity</code> 背景透明，注意这里的背景是指 <code>Window</code> 的背景，因此要在 style.xml 中定义一个透明主题：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">name</span>=<span class=\"string\">\"Translucent\"</span> <span class=\"attr\">parent</span>=<span class=\"string\">\"AppTheme\"</span>&gt;</span><span class=\"xml\"></span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">name</span>=<span class=\"string\">\"windowNoTitle\"</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">item</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">name</span>=<span class=\"string\">\"android:windowBackground\"</span>&gt;</span>@android:color/transparent<span class=\"tag\">&lt;/<span class=\"name\">item</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">name</span>=<span class=\"string\">\"android:colorBackgroundCacheHint\"</span>&gt;</span>@null<span class=\"tag\">&lt;/<span class=\"name\">item</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">name</span>=<span class=\"string\">\"android:windowIsTranslucent\"</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">item</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">name</span>=<span class=\"string\">\"android:windowAnimationStyle\"</span>&gt;</span>@null<span class=\"tag\">&lt;/<span class=\"name\">item</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></div></pre></td></tr></table></figure>\n<p><strong>着重说下<code>windowIsTranslucent</code> 必须为 true，否则即使设置了 background 为透明，也是黑色</strong></p>\n<p>第二件事情要将 <code>Activity</code> 本身的转场动画去掉 <code>overridePendingTransition(0,0)</code>，这个方法要在调用 <code>startActivity</code> 后立即调用，我在 <code>DetailActivity</code>  中封装了一个静态方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">startActivity</span><span class=\"params\">(Activity from, View sharedView, FeedItem item)</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (item == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span>;</div><div class=\"line\">    Intent intent = <span class=\"keyword\">new</span> Intent(from, DetailActivity.class);</div><div class=\"line\">    intent.putExtra(EXTRA_FEED_ITEM, item);</div><div class=\"line\">  <span class=\"comment\">// 获取到前一个 view 的基本信息</span></div><div class=\"line\">    intent.putExtra(EXTRA_ZOOM_INFO, ZoomAnimationUtils.getZoomInfo(sharedView));</div><div class=\"line\">    from.startActivity(intent);</div><div class=\"line\">  <span class=\"comment\">// 去掉自带的转场动画</span></div><div class=\"line\">    from.overridePendingTransition(<span class=\"number\">0</span>,<span class=\"number\">0</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里我们的共享 <code>View</code> 是一个 <code>ImageView</code> ，使用的图片加载框架是 <code>Picasso</code>，当然用什么框架都可以，但是要保证一点：<strong>动画开始执行时，这个共享元素的内容应该加载完成了</strong></p>\n<p>我们在 <code>onCreate</code> 中先加载好图片</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Picasso.with(<span class=\"keyword\">this</span>)</div><div class=\"line\">        .load(mFeedItem.getImageUrl())</div><div class=\"line\">        .into(<span class=\"keyword\">new</span> Target() &#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onBitmapLoaded</span><span class=\"params\">(Bitmap bitmap, Picasso.LoadedFrom from)</span> </span>&#123;</div><div class=\"line\">              <span class=\"comment\">// 加载图片</span></div><div class=\"line\">                setBitmap(bitmap);</div><div class=\"line\">              <span class=\"comment\">// 执行进入的动画</span></div><div class=\"line\">                tryEnterAnimation();</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onBitmapFailed</span><span class=\"params\">(Drawable errorDrawable)</span> </span>&#123;&#125;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onPrepareLoad</span><span class=\"params\">(Drawable placeHolderDrawable)</span> </span>&#123;&#125;</div><div class=\"line\">        &#125;);</div></pre></td></tr></table></figure>\n<p><code>tryEnterAniamtion()</code> 中的代码就简单了</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">tryEnterAnimation</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    ZoomAnimationUtils.startZoomUpAnim(mZoomInfo, mImageView, <span class=\"keyword\">null</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>到这里，转场动画的进入部分就写完了，但是我们发现个问题～，那就是因为 <code>Activity</code> 是透明的，图片没有盖住的部分是能看到上一个 <code>Activity</code> 的，为了让动画效果更好，我们再加一个背景渐变的动画。</p>\n<p>在 <code>ZoomAnimationUtils</code> 中添加一个方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">startBackgroundAlphaAnim</span><span class=\"params\">(<span class=\"keyword\">final</span> View targetView,</span></span></div><div class=\"line\">                                            <span class=\"keyword\">final</span> ColorDrawable color,</div><div class=\"line\">                                            <span class=\"keyword\">int</span>...values) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (targetView == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span> (values == <span class=\"keyword\">null</span> || values.length == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        values = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;<span class=\"number\">0</span>, <span class=\"number\">255</span>&#125;;</div><div class=\"line\">    &#125;</div><div class=\"line\">    ObjectAnimator bgAnim = ObjectAnimator</div><div class=\"line\">            .ofInt(color, <span class=\"string\">\"alpha\"</span>, values);</div><div class=\"line\">    bgAnim.setDuration(ANIMATION_DURATION);</div><div class=\"line\">    bgAnim.addUpdateListener(<span class=\"keyword\">new</span> ValueAnimator.AnimatorUpdateListener() &#123;</div><div class=\"line\">        <span class=\"meta\">@Override</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onAnimationUpdate</span><span class=\"params\">(ValueAnimator animation)</span> </span>&#123;</div><div class=\"line\">            targetView.setBackgroundDrawable(color);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\">    bgAnim.start();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>然后在 <code>DetailActivity</code> 中的 <code>tryEnterAnimation()</code>  中给背景加上动画：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">tryEnterAnimation</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    ZoomAnimationUtils.startZoomUpAnim(mZoomInfo, mImageView, <span class=\"keyword\">null</span>);</div><div class=\"line\">    ZoomAnimationUtils.startBackgroundAlphaAnim(mBackgroundView,</div><div class=\"line\">            <span class=\"keyword\">new</span> ColorDrawable(getResources().getColor(android.R.color.black)), <span class=\"number\">0</span>, <span class=\"number\">255</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"2-退出动画\"><a href=\"#2-退出动画\" class=\"headerlink\" title=\"2.退出动画\"></a>2.退出动画</h4><p>重写两个方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onBackPressed</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    tryExitAnimation();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">finish</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>.finish();</div><div class=\"line\">  <span class=\"comment\">// 去掉自带的转场动画</span></div><div class=\"line\">    overridePendingTransition(<span class=\"number\">0</span>, <span class=\"number\">0</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>退出动画</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">tryExitAnimation</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    ZoomAnimationUtils.startBackgroundAlphaAnim(mBackgroundView,</div><div class=\"line\">                                                <span class=\"keyword\">new</span> ColorDrawable(getResources().getColor(android.R.color.black)),</div><div class=\"line\">                                                <span class=\"number\">255</span>,</div><div class=\"line\">                                                <span class=\"number\">0</span>);</div><div class=\"line\">    ZoomAnimationUtils.startZoomDownAnim(mZoomInfo,</div><div class=\"line\">                                         mImageView,</div><div class=\"line\">                                         <span class=\"keyword\">new</span> AnimatorListenerAdapter() &#123;</div><div class=\"line\">        <span class=\"meta\">@Override</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onAnimationEnd</span><span class=\"params\">(Animator animation)</span> </span>&#123;</div><div class=\"line\">            finish();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"坑\"><a href=\"#坑\" class=\"headerlink\" title=\"坑\"></a>坑</h3><p>我们好像顺利的写完了动画，但是 QA 后来给我提了一个 bug，这个 bug 极其的蛋疼，由这个 bug 又引发了其它的坑，而这些坑基本来自于 <code>Window</code> 的透明。</p>\n<ul>\n<li>坑一：透明主题的 <code>Activity</code> 如果弹出键盘，并且是 <code>adjustResize</code>  模式，在键盘弹出的一瞬间可以看到前一个 <code>Activity</code> <ul>\n<li>原因：键盘弹起时，<code>Activity</code> 重新计算了高度缩短了，而键盘弹起有一个动画，在动画没有执行完毕之前，键盘所占用的空间上没有别的布局只有 <code>Window</code> ，而  <code>Window</code> 是透明的因此就看到了上一个 <code>Activity</code></li>\n<li>尝试的解决方案：在动画执行完毕后，将 <code>Window</code> 的背景设置为不透明，但是失败了，见坑二</li>\n</ul>\n</li>\n<li>坑二：如果当前的 <code>Window</code> 背景带有透明度，在动态改变背景的时候会闪一下屏，如果 <code>Window</code> 的初始背景颜色没有透明度，动态改变背景很完美<ul>\n<li>原因：不详，目测是 Android 的 bug</li>\n<li>解决方案：无。。。</li>\n</ul>\n</li>\n<li>坑三：也是由解决坑二造成的，我试图通过监听键盘弹起事件来手动调节布局，这样 <code>Activity</code> 不需要 resize 也就没有那个 bug，但是发现监听键盘弹起的方法基本都是监听 <code>Activity</code> 重新布局后对比高度来判断的，因此在 <code>adjustNothing</code> 状态下无效，<strong>值得一提的是，跟三弟交流发现他们钻了一个空子，当 <code>Activity</code> 为全屏状态时 <code>adjustResize</code> 是不生效的，但是可以监听到键盘弹出，所以相当于是<code>adjustNothing</code>的效果</strong>，但这种情况没法在我这个项目使用。</li>\n</ul>\n<p>最后的解决方案：最后为了解决这个 bug ，我用了一个很蠢的方法，在这个透明的 <code>Activity</code> 的前面那个 <code>Activity</code> 上面加上一个前景～（不要跟我说清真。。。逼急了什么都能干得出来）</p>\n<h3 id=\"相关资料\"><a href=\"#相关资料\" class=\"headerlink\" title=\"相关资料\"></a>相关资料</h3><ul>\n<li><a href=\"https://github.com/JoeSteven/ZoomAnimDemo\" target=\"_blank\" rel=\"external\">动画Demo</a></li>\n<li><a href=\"https://github.com/qii/weiciyuan\" target=\"_blank\" rel=\"external\">微次元</a> — 实现时参考了这个开源项目</li>\n<li><a href=\"https://www.kancloud.cn/qibin0506/android-md/117682\" target=\"_blank\" rel=\"external\">你所不知道的Activity转场动画——ActivityOptions</a></li>\n<li><a href=\"http://cashow.github.io/android-get-keyboard-height.html\" target=\"_blank\" rel=\"external\">Android - 监听软键盘状态以及获取软键盘的高度</a></li>\n</ul>\n<h1 id=\"Activity-共享元素转场动画实践-Joe\"><a href=\"#Activity-共享元素转场动画实践-Joe\" class=\"headerlink\" title=\"Activity 共享元素转场动画实践 @Joe\"></a><a href=\"http://extremej.itscoder.com/zoom-up-animation/\" target=\"_blank\" rel=\"external\">Activity 共享元素转场动画实践</a> <a href=\"http://extremej.itscoder.com/\" target=\"_blank\" rel=\"external\">@Joe</a></h1>","categories":["Android"],"tags":[]},{"title":"优雅的管理你的文稿","url":"https://joesteven.github.io/manage_your_paper_work_elegantly/","content":"<h3 id=\"序言\"><a href=\"#序言\" class=\"headerlink\" title=\"序言\"></a>序言</h3><p>在我没做码农前，经常需要写各种论文，报表之类的文稿。有一个非常苦恼的困扰就是，写完了一个版本后，要在这版本基础上改动，就复制一份，时间长了以后电脑上各种 1.0、2.0、3.0…一团遭，为了保持整洁就删除了一些认为以后用不到的，结果后面突然要用，这种痛我想很多人都有。还有跟别人一起写文稿的时候，明明是他写的，后来甩锅给我，那种委屈简直了。</p>\n<p><img src=\"http://7xtakx.com1.z0.glb.clouddn.com/manage_origin.png\" alt=\"疯狂 cv\"></p>\n<p>做了码农后，我发现有很多工具，即使你不写代码，熟练使用后，也会大大改善你的工作效率～，今天教大家如何优雅的管理你的文稿。</p>\n<h3 id=\"目标\"><a href=\"#目标\" class=\"headerlink\" title=\"目标\"></a>目标</h3><p>如果你认真的看完了本篇文章，我希望能帮你在管理文稿的过程中达到以下几个目标：</p>\n<ul>\n<li>永远告别复制粘贴产生的一堆 x.x 及备份文件。</li>\n<li>不管你写了多少个版本，让你一秒切换到任意版本。</li>\n<li>精确比较每一个版本间的不同。</li>\n<li>多人合作，再也不怕别人甩锅。</li>\n<li>（如果需要）远程备份，再也不怕电脑突然跪了。</li>\n</ul>\n<h3 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h3><p>无论你是使用 windows 还是 Mac ，都需要用到这个工具 — <strong>Git</strong>。</p>\n<p>因为本篇文章主要目的是管理文稿，所以只会介绍相关的 Git 使用，如果你对 Git 很感兴趣可以自行搜索。</p>\n<h4 id=\"Git-配置\"><a href=\"#Git-配置\" class=\"headerlink\" title=\"Git 配置\"></a>Git 配置</h4><p> Git 是 Linux 之父 Linus Torvalds 一怒之下撸出来的一个代码版本管理工具，Git 是基于命令行进行操作，当然也有很多的开源工具，实现了对 Git 进行图形化操作，也就是大家常见的各种软件，只需要鼠标点就好了。</p>\n<p>但是在这里我会先教大家使用命令行，这样能比较快速的熟悉 Git 的相关命令，并且图形化一般只有一些常用命令，所以掌握一些命令是有必要的。（命令行会显得你逼格比较高～）</p>\n<p>扯远了，先来配置好 Git～</p>\n<p>1.Mac 先到官网<a href=\"https://git-scm.com/\" target=\"_blank\" rel=\"external\">下载</a> Git ，Windows <a href=\"http://git-scm.com/download/win\" target=\"_blank\" rel=\"external\">点我</a>。</p>\n<p>2.下载完成后安装～这一步应该没有什么问题，那么怎么判断你是否安装成功呢？</p>\n<p>如果是  Mac ，在 Launchpad —&gt; 其他 —&gt; 终端，打开终端～你会看到下图这个窗口。（当然你的可能是白色的）</p>\n<p><img src=\"http://7xtakx.com1.z0.glb.clouddn.com/teminate.png\" alt=\"Mac 终端\"></p>\n<p>然后输入下面的命令<code>git version</code>然后回车，查看 Git  的版本，如图：</p>\n<p><img src=\"http://7xtakx.com1.z0.glb.clouddn.com/git_version.png\" alt=\"git version\"></p>\n<p>输出版本号说明安装成功</p>\n<p> Windows 的话在菜单—&gt;Git—&gt;GitBash ，点开，弹出一个命令行窗口（cmd) ，类似于下图：</p>\n<p>就说明安装成功了。</p>\n<p><img src=\"http://7xtakx.com1.z0.glb.clouddn.com/git_bash.png\" alt=\"git bash\"></p>\n<p>3.如何使用 Git？在 Mac 环境下打开终端就可以开始输入 Git 命令了，在 Windows 下除了点菜单，在某个文件夹下点击右键也可以找到 Git Bash，打开就可以。</p>\n<p>到这里 Git 就配置完成了，如果你发现还是没办法正常使用 Git 的话，可以看看这个<a href=\"http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137396287703354d8c6c01c904c7d9ff056ae23da865a000\" target=\"_blank\" rel=\"external\">教程</a>。</p>\n<p>现在开始，我们从新建一篇论文开始，为了方便，就新建 txt 文件作为我们的文稿测试。</p>\n<h3 id=\"新建论文\"><a href=\"#新建论文\" class=\"headerlink\" title=\"新建论文\"></a>新建论文</h3><p>前文我们提到了，Git 可以帮助你不被别人甩锅，所以每次的改动应该知道是谁来做的，那么我们需要先配置你的名称，打开命令行窗口，Mac 是终端，Windows 是 Git Bash ，大家记住，后面不会再提了～</p>\n<p>输入以下命令，输完一行就回车，再输入下一行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">git config --global user.name &quot;Your Name&quot;</div><div class=\"line\">git config --global user.email &quot;email@example.com&quot;</div></pre></td></tr></table></figure>\n<p>这两句命令的意思就是为这个电脑的版本管理配置了修改人的姓名和邮箱，这样每次修改就明确知道是谁修改的。</p>\n<p>废话不多说，我们先建一个文件夹：Demo，然后在这个文件夹下新建一个 txt 文件假装是我们的论文（对，假装，你非要用 word 也可以～）</p>\n<p><img src=\"http://7xtakx.com1.z0.glb.clouddn.com/create_file.png\" alt=\"新建论文文件夹\"></p>\n<p>注意了，现在文件夹有了，论文也有了，怎么用 Git 来管理呢？首先要将这个文件夹变成一个 Git 仓库，说仓库可能有点难理解，但是大家想想仓库，进货出货等等都会登记对吧？咱们就要吧咱们的论文文件夹变成一个严格管理的仓库。</p>\n<p>Mac 的同学打开终端，cd 到这个文件夹下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">cd xxx/xxx/Demo</div></pre></td></tr></table></figure>\n<p>注意，这个 xxx/xxx/Demo 是这个文件夹的路径，可以通过右键查看。cd 到这个文件夹下就相当于在命令行中进入到了这个窗口下</p>\n<p><img src=\"http://7xtakx.com1.z0.glb.clouddn.com/cd_xxx.png\" alt=\"cd 到文件夹下\"></p>\n<p>Windows 的同学可以直接在 Demo 文件夹下面右键打开 Git Bash ，就默认进入到该文件夹下啦</p>\n<h4 id=\"初始化仓库\"><a href=\"#初始化仓库\" class=\"headerlink\" title=\"初始化仓库\"></a>初始化仓库</h4><p>现在已经到这个文件夹下了，我们先来看一下这个文件夹的状态：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">git status</div></pre></td></tr></table></figure>\n<p>查看 Git 仓库的状态，不出意外你会发现报错了</p>\n<p><img src=\"http://7xtakx.com1.z0.glb.clouddn.com/git_status_failed.png\" alt=\"git 仓库不存在\"></p>\n<p>意思是这不是一个 Git 仓库，那么我们来把它变成一个仓库：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">git init</div></pre></td></tr></table></figure>\n<p><img src=\"http://7xtakx.com1.z0.glb.clouddn.com/git_init.png\" alt=\"初始化仓库\"></p>\n<p>这句命令是初始化一个仓库，init 是 Initialized 的缩写，初始化后我们再来查看一下仓库的状态：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">git status</div></pre></td></tr></table></figure>\n<p><img src=\"http://7xtakx.com1.z0.glb.clouddn.com/git_status_1.png\" alt=\"初始化仓库状态\"></p>\n<p>看到了么，我们的仓库已经创建成功了，并且刚刚我们创建的这个论文也出现在了命令行中，并且是红色的～，咱们先不去管是什么意思，来写我们的论文</p>\n<h4 id=\"给论文加点东西\"><a href=\"#给论文加点东西\" class=\"headerlink\" title=\"给论文加点东西\"></a>给论文加点东西</h4><p>咱们打开论文，写点东西：</p>\n<p><img src=\"http://7xtakx.com1.z0.glb.clouddn.com/file_1.png\" alt=\"第一次修改论文\"></p>\n<p>好啦～简单的完成了第一次修改，我们需要保存这一次修改，还是先来查看下仓库的状态：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">git status</div></pre></td></tr></table></figure>\n<p>记住这个命令，你会经常用到的～</p>\n<p><img src=\"http://7xtakx.com1.z0.glb.clouddn.com/git_status_2.png\" alt=\"第一次修改后的状态\"></p>\n<p>发现跟刚刚初始化的时候的状态一样，好了，我们要来记录这一次修改了，首先将要修改的文件加入到本次纪录中：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">git add xxx</div></pre></td></tr></table></figure>\n<p>xxx 是被修改的文件，这里就是我们的 初版.txt，注意是相对路径（相对这个文件夹的）,比如说这个文件夹下面还有一个文件夹 test，test 下面有个文件 xxx，那么 xxx 就应该是 test/xxx。</p>\n<p><img src=\"http://7xtakx.com1.z0.glb.clouddn.com/git_add.png\" alt=\"add 修改文件\"></p>\n<p>add 之后好像什么都没发生哈，再来查看下 status：</p>\n<p><img src=\"http://7xtakx.com1.z0.glb.clouddn.com/git_status_3.png\" alt=\"add 后状态\"></p>\n<p>喏～变绿了有没有，而且有一行字提示你有修改等着被提交，那么我们就来提交吧：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">git commit -m &apos;这里是本次修改的描述信息&apos;</div></pre></td></tr></table></figure>\n<p><img src=\"http://7xtakx.com1.z0.glb.clouddn.com/git_commit_1.png\" alt=\"commit 修改\"></p>\n<p>ok~提示我们完成了提交，并且提交的内容是什么也显示了出来。</p>\n<h4 id=\"查看修改\"><a href=\"#查看修改\" class=\"headerlink\" title=\"查看修改\"></a>查看修改</h4><p>我们提交了第一次修改，那么在哪里查看呢？用下面这个命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">git log</div></pre></td></tr></table></figure>\n<p>这个命令会以流水线的形式来展示我们的每一次修改</p>\n<p><img src=\"http://7xtakx.com1.z0.glb.clouddn.com/git_log_1.png\" alt=\"git log\"></p>\n<p>注意一下，这里f移动查看log 是 h j k l ，而不是方向键，如果要退出查看 log 按一下 q （quit）</p>\n<p>好，我们简单的来总结下上面这几步</p>\n<ul>\n<li>首先是初始化仓库，这个仓库必须是一个文件夹（只需要初始化一次）</li>\n<li>然后修改你的论文，把本次修改 add 进这一次的提交内容中</li>\n<li>最后确定没问题，提交这次修改纪录</li>\n<li>查看这次修改的日志</li>\n</ul>\n<p>用到的命令有</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">git init //初始化</div><div class=\"line\">git status //查看状态</div><div class=\"line\">git add xxx //添加某个文件</div><div class=\"line\">git commit -m &apos;xxx&apos; // 提交这次纪录</div><div class=\"line\">git log // 查看日志</div></pre></td></tr></table></figure>\n<p>好了～，说到这里，是不是感觉干了好多并不明白的事情？貌似并没有什么卵用啊？？？别着急，进入下一步</p>\n<h3 id=\"修改论文\"><a href=\"#修改论文\" class=\"headerlink\" title=\"修改论文\"></a>修改论文</h3><p>上面我们只是刚刚新建了一篇论文，简单的写了个开头而已，现在我们要真正的去写我们的出版了，打开初版，疯狂的输出～</p>\n<p><img src=\"http://7xtakx.com1.z0.glb.clouddn.com/file_2.png\" alt=\"修改正文\"></p>\n<p>ok~正文写完了。。。虽然我这里写的很少，但是假装我们写的很多～我们来查看下仓库的状态</p>\n<p><img src=\"http://7xtakx.com1.z0.glb.clouddn.com/git_status_4.png\" alt=\"修改正文后的状态\"></p>\n<p>看到没～又变红了，我们先不急着像上面一样提交修改，假如我们现在想看看我们到底修改了写什么，跟我们修改前的文件对比一下呢？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">git diff</div></pre></td></tr></table></figure>\n<p>diff 是 different 的缩写</p>\n<p><img src=\"http://7xtakx.com1.z0.glb.clouddn.com/git_diff.png\" alt=\"diff\"></p>\n<p>－号代表了修改前的文件，＋号代表了修改后的文件～</p>\n<p>好了我们确定了本次修改就提交吧～步骤同上，不再重复，看大家能自己学会提交么，提交完后我们看下 log 日志</p>\n<p>注意下命令行中用到的符号都必须是英文符号噢</p>\n<p><img src=\"http://7xtakx.com1.z0.glb.clouddn.com/git_log_2.png\" alt=\"添加正文后的log\"></p>\n<h3 id=\"在不同版本间切换\"><a href=\"#在不同版本间切换\" class=\"headerlink\" title=\"在不同版本间切换\"></a>在不同版本间切换</h3><p>前面的一切都在为后面的操作铺路～上面的功能好像除了纪录下每次的修改并没有其他的卵用啊，假设现在我们有个需求，是要看最开始创建的那个版本，也就是只写了一行字的那个，怎么办？下面教一个流弊的命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">git checkout xxx</div></pre></td></tr></table></figure>\n<p>xxx 具体是什么呢？先不提，因为 checkout 有很多种用法，还记得前面讲  git log 的那张图里面，每一个纪录都有一个独一无二的 id 么？</p>\n<p><img src=\"http://7xtakx.com1.z0.glb.clouddn.com/git_log_2.png\" alt=\"两次修改的日志\"></p>\n<p>找到第一次提交的纪录的 id，复制下来，将 xxx 换成这个 id</p>\n<p><img src=\"http://7xtakx.com1.z0.glb.clouddn.com/git_checkout_commit.png\" alt=\"chekout 第一次提交\"></p>\n<p>再打开我们的 初版.txt 看看</p>\n<p>是不是又回到第一次提交时的样子啦？来看下仓库的状态：</p>\n<p><img src=\"http://7xtakx.com1.z0.glb.clouddn.com/git_status_6.png\" alt=\"checkout 后的状态\"></p>\n<p>有没有看到一行红字，<code>HEAD detached at 3d6fe3c</code>，后面的那个乱码其实是这个纪录的 id 的前几位，不信你去看 log，HEAD 就像是一个指针，这个指针指到哪儿，文件就变成那个时候的样子，怎么样，是不是很流弊？这时候你再查看 log 会发现第二次的提交不见了，不要惊慌，因为在当前的这个提交上面还没有第二个提交纪录呢</p>\n<p>那么怎么切换回第二次，也就是最新的那个版本呢？</p>\n<p>这里就要引入一个分支的概念了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">git branch</div></pre></td></tr></table></figure>\n<p>输入这个命令查看当前仓库中的分支</p>\n<p><img src=\"http://7xtakx.com1.z0.glb.clouddn.com/git_branch_1.png\" alt=\"分支查看\"></p>\n<p>绿色的，前面有 ＊ 号的，就是我们当前所在的分支，另外我们还看到还有一个 master 分支，在没有进行分支指定的情况下是默认在 master 分支上，可以把这个分支看成是主分支，而我们目前所在的这个分支只是一个临时分支，供我们切换到某个版本上面而不影响主分支上的内容，那么现在就让我们切换到主分支上：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">git checkout master</div></pre></td></tr></table></figure>\n<p>然后再查看我们的 log ，发现第二次提交的纪录也回来了，打开初版可以看到恢复到最新的版本了。</p>\n<p>这时候再来查看下分支</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">git branch</div></pre></td></tr></table></figure>\n<p>会发现我们已经到 master 分支上面了，并且之前的那个临时分支已经不见了～</p>\n<h3 id=\"分支开发\"><a href=\"#分支开发\" class=\"headerlink\" title=\"分支开发\"></a>分支开发</h3><p>前面引入了一个分支的概念，现在要好好讲讲分支的作用，这是 Git 比较精华的部分。先举个在程序开发中的例子</p>\n<p><strong>通常在程序开发中会有三个主要的分支，分别是 master ，develop，test，从字面理解就是主分支，开发分支，和测试分支。什么意思呢？</strong></p>\n<p><strong>举个例子，假设我们有个 app 在应用市场的版本是 1.0.0 ，现在我们要开发 1.1.0，怎么做呢？从 master 分支切出一个 develop 分支，在 develop 分支上面去开发 1.1.0 的功能，为什么呢？你想，如果我们直接在 1.0.0 的代码上去开发，如果线上版本有一个重大 bug ，需要紧急修复，而 1.1.0 的功能又只开发了一半，这时候就很尴尬了，可是如果我们在单独的分支上开发 1.1.0，这时候就可以很轻松的在 master 分支上修改bug 重新发一个新的 1.0.0 版本，再接着在 develop 分支上开发 1.1.0，互相不干扰～</strong></p>\n<p>同样，我们在写论文的时候可能也有这个需求，比如你现在已经写了一个能看的版本了（给老师，老板检查之类的），但是你又想再加一点新的东西进去，可是又不希望被老师／老板突然抽查发现你还有的没写完，这样就不完美了。</p>\n<p>利用上面的思路，我们也可以在 master 上是你能看的版本，再切一个单独的分支来加新的东西，这样即便被突然检查也可以很轻松的切换到 master 上面给老师看一个完成版～</p>\n<p>所以我们先要明确两个分支的任务</p>\n<ul>\n<li>master — 这个分支上的每一个版本都应该是完成度较高的（1.0，1.1，1.2，1.3。。。）</li>\n<li>develop — 这个分支上用来加一些东西，或者是修改一些东西，是你真正去写论文的分支</li>\n</ul>\n<p>有好事的同学问了，master 上同时可以保存 1.0，1.1，1.2 等等不同的版本么？当然可以，还记得前面我们任意切换到一个 commit 上吧？不过 当你写到 1.3 版本的时候，可能就已经有非常多的 commit 了，如何精确的跳到一个完成版上面，后面会教大家。</p>\n<p>首先查看分支的命令还记得是什么？</p>\n<h4 id=\"新建分支，切换\"><a href=\"#新建分支，切换\" class=\"headerlink\" title=\"新建分支，切换\"></a>新建分支，切换</h4><p>现在来创建一个新的分支</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">git branch develop</div></pre></td></tr></table></figure>\n<p>后面的 develop 是分支名，这个名字由你来定，需要注意的是，我们当前在 master 分支上去切一个新的分支，这个分支是基于 master 分支的，也就是 master 分支上有的东西，它都有。</p>\n<p><img src=\"http://7xtakx.com1.z0.glb.clouddn.com/git_branch_2.png\" alt=\"新建分支\"></p>\n<p>可以看到已经创建了一个新的分支，现在 checkout 到这个分支上去吧</p>\n<p><img src=\"http://7xtakx.com1.z0.glb.clouddn.com/git_checkout_branch.png\" alt=\"切换分支\"></p>\n<p>查看 log  可以看到，master 上面的提交，这个分支上都有，对吧。</p>\n<p>现在我们就可以愉快的在这个分支上疯狂的输出了，打开文件，写点东西</p>\n<p><img src=\"http://7xtakx.com1.z0.glb.clouddn.com/file_3.png\" alt=\"develop 修改\"></p>\n<p>修改完了，怎么提交？不需要再说了吧</p>\n<p><img src=\"http://7xtakx.com1.z0.glb.clouddn.com/git_log_3.png\" alt=\"develop log\"></p>\n<p>现在问题来了，我怎么把 develop 上面的修改弄到 master 上面去呢？</p>\n<h4 id=\"分支合并\"><a href=\"#分支合并\" class=\"headerlink\" title=\"分支合并\"></a>分支合并</h4><p>很简单，一个分支要想更新到另一个分支所在的版本，合并下这个分支就好了</p>\n<p>所以，首先我们要切换到 master 分支上面</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">git checkout master</div></pre></td></tr></table></figure>\n<p>然后合并 develop 分支上面的改动</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">git merge develop</div></pre></td></tr></table></figure>\n<p><img src=\"http://7xtakx.com1.z0.glb.clouddn.com/git_checkout_branch_2.png\" alt=\"合并分支\"></p>\n<p>git 会提示我有一个文件发生了改变，这时候再看看log，是不是有了第三次提交的纪录呢？</p>\n<h3 id=\"版本标注\"><a href=\"#版本标注\" class=\"headerlink\" title=\"版本标注\"></a>版本标注</h3><p>前面说了，会教大家如何表明一个版本，比如现在我们有了三次修改纪录，但第三次提交时才完成了我们的 1.0，当我们写到 5.0 的时候，可能有上百个提交，我怎么能精确的记住 1.0 在哪次提交纪录上呢？</p>\n<p>很简单我们在完成了 1.0 的这次纪录上添加一个标记，来标明它是 1.0 的版本</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">git tag xxx</div></pre></td></tr></table></figure>\n<p>xxx 即是你要的标记</p>\n<p><img src=\"http://7xtakx.com1.z0.glb.clouddn.com/git_tag_1.png\" alt=\"tag 标记\"></p>\n<p>OK～添加完成，怎么看呢？简单</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">git tag</div></pre></td></tr></table></figure>\n<p>就可以看到你当前有多少个 tag 了。有同学问了，我可以在这一次纪录上多打几个标记么？当然可以，只要你开心～</p>\n<p>如果要删除某个 tag</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">git tag -d xxx</div></pre></td></tr></table></figure>\n<p>来实操一下，咱们已经添加了一个 1.0 的 tag 了。现在来多提交几次，看看能不能回到 1.0 版本。</p>\n<p><img src=\"http://7xtakx.com1.z0.glb.clouddn.com/file_4.png\" alt=\"完成了多个版本\"></p>\n<p><img src=\"http://7xtakx.com1.z0.glb.clouddn.com/git_log_5.png\" alt=\"多个版本的 log\"></p>\n<p>现在我们已经提交了两次，完成了两个版本，这里为了方便我们都是直接在 master 上提交的哈。</p>\n<p>来看看怎么切换回 1.0，有的同学可能已经猜到了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">git checkout 1.0</div></pre></td></tr></table></figure>\n<p>这个 checkout 是不是很流弊啊。</p>\n<p>再打开初版.txt看看，是不是回到了 1.0 版本呢？</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>到这里已经教给了大家 git 常用的这些操作，当然 git 的操作远不止这些，本篇文章的目的只是带你入门，当你入门了以后就可以通过看官方文档或者专业一点的  git 介绍来深入学习，对了～目标里面的最后一条，我会放到下一篇文章中来单独讲解，如果你特别感兴趣可以自行 Google  Github～</p>\n<p>当然，如果你对命令行操作实在感到困难，也可以使用图形化的 Git 工具来帮助操作，前提是你得理解这些命令的作用噢～</p>\n<h3 id=\"资料\"><a href=\"#资料\" class=\"headerlink\" title=\"资料\"></a>资料</h3><p><a href=\"https://git-scm.com/book/zh/v2\" target=\"_blank\" rel=\"external\">Git-Book</a></p>\n<p><a href=\"https://my.oschina.net/amstrong/blog/159114\" target=\"_blank\" rel=\"external\">图形化工具集合</a></p>\n","categories":["Tools"],"tags":[]},{"title":"SparseArray 的使用及实现原理","url":"https://joesteven.github.io/sparsearray_source_analyse/","content":"<blockquote>\n<p>作者：<a href=\"http://extremej.itscoder.com/about/\" target=\"_blank\" rel=\"external\">阿风</a></p>\n<p>审阅者：<a href=\"http://allenwu.itscoder.com/\" target=\"_blank\" rel=\"external\">allenwu</a></p>\n</blockquote>\n<h3 id=\"序言\"><a href=\"#序言\" class=\"headerlink\" title=\"序言\"></a>序言</h3><p>相信大家都用过<code>HashMap</code>用来存放键值对，最近在项目中使用<code>HashMap</code>的时候发现，有时候 IDE 会提示我这里的<code>HashMap</code>可以用<code>SparseArray</code>或者<code>SparseIntArray</code>等等来代替。</p>\n<p>细心的朋友可能也发现了这个提示，并且会发现并不是所有的<code>HashMap</code>都会提示替换。今天就来一探究竟，到底<code>SparseArray</code>跟<code>HaspMap</code>相比有什么优缺点，又是在什么场景下来使用的呢？</p>\n<p>如果你对于<code>HashMap</code>的实现原理还不是很了解，推荐你阅读<a href=\"http://allenwu.itscoder.com/\" target=\"_blank\" rel=\"external\">allen</a>的这篇<a href=\"http://allenwu.itscoder.com/2016/08/19/allenwu_20160819__hashmap_source_analyse/\" target=\"_blank\" rel=\"external\">Java 集合框架源码分析系列之 HashMap</a>。</p>\n<h3 id=\"SparseArray-的使用\"><a href=\"#SparseArray-的使用\" class=\"headerlink\" title=\"SparseArray 的使用\"></a>SparseArray 的使用</h3><h4 id=\"创建\"><a href=\"#创建\" class=\"headerlink\" title=\"创建\"></a>创建</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">SparseArray&lt;Student&gt; sparseArray = <span class=\"keyword\">new</span> SparseArray&lt;&gt;();</div><div class=\"line\">SparseArray&lt;Student&gt; sparseArray = <span class=\"keyword\">new</span> SparseArray&lt;&gt;(capacity);</div></pre></td></tr></table></figure>\n<p>首先来看看如何创建一个<code>SparseArray</code>，前文说了<code>SparseArray</code>是用来替换<code>HashMap</code>的，而<code>SparseArray</code>只需要指定一个泛型，似乎说明<code>key</code>的类型在<code>SparseArray</code>内部已经指定了呢？</p>\n<p><code>SparseArray</code>有两个构造方法，一个默认构造方法，一个传入容量。</p>\n<h4 id=\"put\"><a href=\"#put\" class=\"headerlink\" title=\"put()\"></a>put()</h4><p>创建完<code>sparseArray</code>后，来看看怎么往里面存放数据吧。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">sparseArray.put(<span class=\"keyword\">int</span> key,Student value);</div></pre></td></tr></table></figure>\n<p>噢，原来<code>SparseArray</code>存放的键值对中的键是<code>int</code>型的数据，为什么呢？后面分析源码的时候再讲。</p>\n<p><code>put()</code>就跟<code>HashMap</code>的使用方法一样。</p>\n<h4 id=\"get\"><a href=\"#get\" class=\"headerlink\" title=\"get()\"></a>get()</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">sparseArray.get(<span class=\"keyword\">int</span> key);</div><div class=\"line\">sparseArray.get(<span class=\"keyword\">int</span> key,Student valueIfNotFound);</div></pre></td></tr></table></figure>\n<h4 id=\"remove\"><a href=\"#remove\" class=\"headerlink\" title=\"remove()\"></a>remove()</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">sparseArray.remove(<span class=\"keyword\">int</span> key);</div></pre></td></tr></table></figure>\n<h4 id=\"index\"><a href=\"#index\" class=\"headerlink\" title=\"index\"></a>index</h4><p>前面几个都跟<code>HashMap</code>没有什么太大区别，而这个<code>index</code>就是<code>SparseArray</code>所特有的属性了，这里为了方便理解先提一嘴，<code>SparseArray</code>从名字上看就能猜到跟数组有关系，事实上他底层是两条数组，一组存放<code>key</code>，一组存放<code>value</code>，知道了这一点应该能猜到<code>index</code>的作用了。</p>\n<p><code>index</code> — <code>key</code>在数组中的位置。<code>SparseArray</code>提供了一些跟<code>index</code>相关的方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">sparseArray.indexOfKey(<span class=\"keyword\">int</span> key);</div><div class=\"line\">sparseArray.indexOfValue(T value);</div><div class=\"line\">sparseArray.keyAt(<span class=\"keyword\">int</span> index);</div><div class=\"line\">sparseArray.valueAt(<span class=\"keyword\">int</span> index);</div><div class=\"line\">sparseArray.setValueAt(<span class=\"keyword\">int</span> index);</div><div class=\"line\">sparseArray.removeAt(<span class=\"keyword\">int</span> index);</div><div class=\"line\">sparseArray.removeAt(<span class=\"keyword\">int</span> index,<span class=\"keyword\">int</span> size);</div></pre></td></tr></table></figure>\n<h3 id=\"SparseArray-实现原理\"><a href=\"#SparseArray-实现原理\" class=\"headerlink\" title=\"SparseArray 实现原理\"></a>SparseArray 实现原理</h3><p>前面简单的介绍了 <code>SparseArray</code> 的使用，为了在实际工作中最合理的选用数据结构，深入的了解每种数据结构的实现原理是很有必要的，这样可以更好的理解和比较不同数据结构之间的优缺点，比死记概念要更好，甚至可以根据自己的具体需求去实现最适合需求的数据结构。</p>\n<p>话不多说，打开源码来一探究竟。我看源码的习惯，是先看这个类文件的注释，一般能在整体上给个思路。</p>\n<blockquote>\n<p>SparseArrays map integers to Objects.  Unlike a normal array of Objects,there can be gaps in the indices.  It is intended to be more memory efficient than using a HashMap to map Integers to Objects, both because it avoids auto-boxing keys and its data structure doesn’t rely on an extra entry object for each mapping.</p>\n</blockquote>\n<p>这段注释基本解释了该类的作用：<strong>使用<code>int[]</code>数组存放<code>key</code>，避免了<code>HashMap</code>中基本数据类型需要装箱的步骤，其次不使用额外的结构体（Entry)，单个元素的存储成本下降。</strong></p>\n<p>如果你对装箱的概念还不清楚，可以看看小黑屋的这篇文章：<a href=\"http://droidyue.com/blog/2015/04/07/autoboxing-and-autounboxing-in-java/\" target=\"_blank\" rel=\"external\">Java中的自动装箱与拆箱</a>。</p>\n<h4 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h4><p><code>SparseArray</code>没有继承任何其他的数据结构，实现了<code>Cloneable</code>接口。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span>[] mKeys;</div><div class=\"line\"><span class=\"keyword\">private</span> Object[] mValues;</div><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mSize;<span class=\"comment\">//当前实际存放的数量</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SparseArray</span><span class=\"params\">()</span> </span>&#123;<span class=\"keyword\">this</span>(<span class=\"number\">10</span>);&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SparseArray</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity)</span> </span>&#123;</div><div class=\"line\">  \t\t<span class=\"comment\">//如果容量为0，获取两个长度为0的数组</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (initialCapacity == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">            mKeys = EmptyArray.INT;</div><div class=\"line\">            mValues = EmptyArray.OBJECT;</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">          <span class=\"comment\">//创建两个长度相同的数组，一个放key,一个放values</span></div><div class=\"line\">            mValues = ArrayUtils.newUnpaddedObjectArray(initialCapacity);</div><div class=\"line\">            mKeys = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[mValues.length];</div><div class=\"line\">        &#125;</div><div class=\"line\">        mSize = <span class=\"number\">0</span>;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>初始化<code>SparseArray</code>只是简单的创建了两个数组。</p>\n<h4 id=\"put-1\"><a href=\"#put-1\" class=\"headerlink\" title=\"put()\"></a>put()</h4><p>接下来就是往<code>SparseArray</code>中存放数据。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">put</span><span class=\"params\">(<span class=\"keyword\">int</span> key, E value)</span> </span>&#123;</div><div class=\"line\">  \t<span class=\"comment\">// 首先通过二分查找去 key 数组中查找要插入的 key，返回索引</span></div><div class=\"line\">    <span class=\"keyword\">int</span> i = ContainerHelpers.binarySearch(mKeys, mSize, key);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (i &gt;= <span class=\"number\">0</span>) &#123;</div><div class=\"line\">      <span class=\"comment\">// 如果 i&gt;=0 说明数组中已经有了该key，则直接覆盖原来的值</span></div><div class=\"line\">        mValues[i] = value;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      <span class=\"comment\">// 取反，这里得到的i应该是最适合该key的插入位置，具体怎么得到的，后面会说</span></div><div class=\"line\">        i = ~i;</div><div class=\"line\">\t\t<span class=\"comment\">// 如果索引小于当前已经存放的长度，并且这个位置上的值为DELETED(即被标记为删除的值)</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (i &lt; mSize &amp;&amp; mValues[i] == DELETED) &#123;</div><div class=\"line\">          <span class=\"comment\">// 直接赋值并返回，注意 size 不需要增加</span></div><div class=\"line\">            mKeys[i] = key;</div><div class=\"line\">            mValues[i] = value;</div><div class=\"line\">            <span class=\"keyword\">return</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">\t\t<span class=\"comment\">// 到这一步说明直接赋值失败，检查当前是否被标记待回收且当前存放的长度已经大于或等于了数组长度</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (mGarbage &amp;&amp; mSize &gt;= mKeys.length) &#123;</div><div class=\"line\">          \t<span class=\"comment\">// 回收数组中应该被干掉的值</span></div><div class=\"line\">            gc();</div><div class=\"line\">\t\t\t<span class=\"comment\">// 重新再获取一下索引，因为数组发生了变化</span></div><div class=\"line\">            <span class=\"comment\">// Search again because indices may have changed.</span></div><div class=\"line\">            i = ~ContainerHelpers.binarySearch(mKeys, mSize, key);</div><div class=\"line\">        &#125;</div><div class=\"line\">\t\t<span class=\"comment\">// 最终在 i 位置上插入键与值，并且size ＋1</span></div><div class=\"line\">        mKeys = GrowingArrayUtils.insert(mKeys, mSize, i, key);</div><div class=\"line\">        mValues = GrowingArrayUtils.insert(mValues, mSize, i, value);</div><div class=\"line\">        mSize++;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面这段代码是一次插入数据的操作，单看的话有些难懂，因为插入跟删除之间有一定的关系，所以要看懂这段代码，还必须搞懂删除的逻辑。在看删除之前，还是先大体梳理一下插入的几个特点：</p>\n<ul>\n<li><strong>存放<code>key</code>的数组是有序的（二分查找的前提条件）</strong></li>\n<li><strong>如果冲突，新值直接覆盖原值，并且不会返回原值（<code>HashMap</code>会返回原值）</strong></li>\n<li><strong>如果当前要插入的 key 的索引上的值为DELETE，直接覆盖</strong></li>\n<li><strong>前几步都失败了，检查是否需要<code>gc()</code>并且在该索引上插入数据</strong></li>\n</ul>\n<p>插入的逻辑大体上是这四点，理解起来可能还是有些抽象，我们来几张图：</p>\n<h5 id=\"冲突直接覆盖\"><a href=\"#冲突直接覆盖\" class=\"headerlink\" title=\"冲突直接覆盖\"></a>冲突直接覆盖</h5><p><img src=\"http://7xtakx.com1.z0.glb.clouddn.com/sparse_array_put_one.jpg\" alt=\"冲突直接覆盖原值\"></p>\n<p>上面这个图，插入一个<code>key=3</code>的元素，因为在<code>mKeys</code>中已经存在了这个值，则直接覆盖。</p>\n<h5 id=\"插入索引上为DELETED\"><a href=\"#插入索引上为DELETED\" class=\"headerlink\" title=\"插入索引上为DELETED\"></a>插入索引上为DELETED</h5><p><img src=\"http://7xtakx.com1.z0.glb.clouddn.com/sparse_array_put_two.jpg\" alt=\"索引上为DELETED\"></p>\n<p>注意<code>mKeys</code>中并没有 3 这个值，但是通过二分查找得出来，目前应该插入的索引位置为 2 ，即<code>key=4</code>所在的位置，而当前这个位置上对应的<code>value</code>标记为<code>DELETED</code>了，所以会直接将该位置上的<code>key</code>赋值为 3 ，并且将该位置上的<code>value</code>赋值为<code>put()</code>传入的对象。</p>\n<h5 id=\"索引上有值，但是应该触发gc\"><a href=\"#索引上有值，但是应该触发gc\" class=\"headerlink\" title=\"索引上有值，但是应该触发gc()\"></a>索引上有值，但是应该触发<code>gc()</code></h5><p><img src=\"http://7xtakx.com1.z0.glb.clouddn.com/sparse_array_put_three.jpg\" alt=\"触发gc()\"></p>\n<p>注意这个图跟前面的几个又一个区别，那就是数组已经满容量了，而且 3 应该插入的位置已经有 4 了，而 5 所指向的值为<code>DELETED</code>，<strong>这种情况下，会先去回收<code>DELETED</code>,重新调整数组结构，图中的例子则会回收 5 ,然后再重新计算 3 应该插入的位置</strong></p>\n<h5 id=\"满容且无法gc\"><a href=\"#满容且无法gc\" class=\"headerlink\" title=\"满容且无法gc()\"></a>满容且无法<code>gc()</code></h5><p><img src=\"http://7xtakx.com1.z0.glb.clouddn.com/sparse_array_put_four.jpg\" alt=\"满容且无法触发gc()\"></p>\n<p>这种情况下，就只能对数组进行扩容，然后插入数据。</p>\n<p>结合这几个图，插入的流程应该很清晰了，但是<code>put()</code>还有几个值得我们探索的点，首先就是二分查找的算法，这是一个很普通的二分算法，注意最后一行代码，当找不到这个值的时候<code>return ~lo</code>，实际上到这一步的时候，理论上<code>lo==mid==hi</code>。所以这个位置是最适合插入数据的地方。但是为了让能让调用者既知道没有查到值，又知道索引位置，做了一个取反操作，返回一个负数。这样调用处可以首先通过正负来判断命中，之后又可以通过取反获取索引位置。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// This is Arrays.binarySearch(), but doesn't do any argument validation.</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">binarySearch</span><span class=\"params\">(<span class=\"keyword\">int</span>[] array, <span class=\"keyword\">int</span> size, <span class=\"keyword\">int</span> value)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> lo = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">int</span> hi = size - <span class=\"number\">1</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">while</span> (lo &lt;= hi) &#123;</div><div class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> mid = (lo + hi) &gt;&gt;&gt; <span class=\"number\">1</span>;</div><div class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> midVal = array[mid];</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (midVal &lt; value) &#123;</div><div class=\"line\">            lo = mid + <span class=\"number\">1</span>;</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (midVal &gt; value) &#123;</div><div class=\"line\">            hi = mid - <span class=\"number\">1</span>;</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> mid;  <span class=\"comment\">// value found</span></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> ~lo;  <span class=\"comment\">// value not present</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>第二个点就是，插入数据具体是怎么插入的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">mKeys = GrowingArrayUtils.insert(mKeys, mSize, i, key);</div><div class=\"line\">mValues = GrowingArrayUtils.insert(mValues, mSize, i, value);</div></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>[] insert(<span class=\"keyword\">int</span>[] array, <span class=\"keyword\">int</span> currentSize, <span class=\"keyword\">int</span> index, <span class=\"keyword\">int</span> element) &#123;</div><div class=\"line\">    <span class=\"keyword\">assert</span> currentSize &lt;= array.length;<span class=\"comment\">//断言</span></div><div class=\"line\">\t<span class=\"comment\">// 如果当前的长度加1还是小于数组长度</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (currentSize + <span class=\"number\">1</span> &lt;= array.length) &#123;</div><div class=\"line\">      <span class=\"comment\">// 复制数组,没有进行扩容</span></div><div class=\"line\">        System.arraycopy(array, index, array, index + <span class=\"number\">1</span>, currentSize - index);</div><div class=\"line\">        array[index] = element;</div><div class=\"line\">        <span class=\"keyword\">return</span> array;</div><div class=\"line\">    &#125;</div><div class=\"line\">\t<span class=\"comment\">// 需要扩容，分为两步，首先复制前半部分</span></div><div class=\"line\">    <span class=\"keyword\">int</span>[] newArray = ArrayUtils.newUnpaddedIntArray(growSize(currentSize));</div><div class=\"line\">    System.arraycopy(array, <span class=\"number\">0</span>, newArray, <span class=\"number\">0</span>, index);</div><div class=\"line\">    <span class=\"comment\">// 插入数据</span></div><div class=\"line\">  \tnewArray[index] = element;</div><div class=\"line\">  \t<span class=\"comment\">// 复制后半部分</span></div><div class=\"line\">    System.arraycopy(array, index, newArray, index + <span class=\"number\">1</span>, array.length - index);</div><div class=\"line\">    <span class=\"keyword\">return</span> newArray;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>put()</code>部分的代码就全部完毕了，接下来先来看看<code>remove()</code>是怎么处理的？</p>\n<h4 id=\"remove-1\"><a href=\"#remove-1\" class=\"headerlink\" title=\"remove()\"></a>remove()</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">remove</span><span class=\"params\">(<span class=\"keyword\">int</span> key)</span> </span>&#123;</div><div class=\"line\">    delete(key);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">delete</span><span class=\"params\">(<span class=\"keyword\">int</span> key)</span> </span>&#123;</div><div class=\"line\">   \t<span class=\"comment\">// 找到该 key 的索引</span></div><div class=\"line\">    <span class=\"keyword\">int</span> i = ContainerHelpers.binarySearch(mKeys, mSize, key);</div><div class=\"line\">\t<span class=\"comment\">// 如果存在，将该索引上的 value 赋值为 DELETED</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (i &gt;= <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (mValues[i] != DELETED) &#123;</div><div class=\"line\">            mValues[i] = DELETED;</div><div class=\"line\">          \t<span class=\"comment\">// 标记当前状态为待回收</span></div><div class=\"line\">            mGarbage = <span class=\"keyword\">true</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Object DELETED = <span class=\"keyword\">new</span> Object();</div></pre></td></tr></table></figure>\n<p>事实上，<code>SparseArray</code>在进行<code>remove()</code>操作的时候分为两个步骤：</p>\n<ul>\n<li>删除<code>value</code> — 在<code>remove()</code>中处理</li>\n<li>删除<code>key</code> —  在<code>gc()</code>中处理，注意这里不是系统的 GC，只是<code>SparseArray</code> 的一个方法</li>\n</ul>\n<p><code>remove()</code>中，将这个<code>key</code>指向了<code>DELETED</code>，这时候<code>value</code>失去了引用，如果没有其它的引用，会在下一次系统内存回收的时候被干掉。来看一张图：</p>\n<p><img src=\"http://7xtakx.com1.z0.glb.clouddn.com/sparse_array_remove.png\" alt=\"remove\"></p>\n<p>但是可以看到<code>key</code>仍然保存在数组中，并没有马上删除，目的应该是为了保持索引结构，同时不会频繁压缩数组，保证索引查询不会错位，那么<code>key</code>什么时候被删除呢？当<code>SparseArray</code>的<code>gc()</code>被调用时。</p>\n<blockquote>\n<p>To help with performance, the container includes an optimization when removing keys: instead of compacting its array immediately, it leaves the removed entry marked as deleted. The entry can then be re-used for the same key, or compacted later in a single garbage collection step of all removed entries. This garbage collection will need to be performed at any time the array needs to be grown or the the map size or entry values are retrieved.</p>\n</blockquote>\n<h4 id=\"gc\"><a href=\"#gc\" class=\"headerlink\" title=\"gc()\"></a>gc()</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">gc</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// Log.e(\"SparseArray\", \"gc start with \" + mSize);</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">int</span> n = mSize;</div><div class=\"line\">    <span class=\"keyword\">int</span> o = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">int</span>[] keys = mKeys;</div><div class=\"line\">    Object[] values = mValues;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</div><div class=\"line\">        Object val = values[i];</div><div class=\"line\">\t\t<span class=\"comment\">// 当前这个 value 不等于 DELETED</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (val != DELETED) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (i != o) &#123;</div><div class=\"line\">              \t<span class=\"comment\">// i != o</span></div><div class=\"line\">              \t<span class=\"comment\">// 将索引 i 处的 key 赋值给 o 处的key</span></div><div class=\"line\">                keys[o] = keys[i];</div><div class=\"line\">              \t<span class=\"comment\">// 同时将值也赋值给 o 处</span></div><div class=\"line\">                values[o] = val;</div><div class=\"line\">              \t<span class=\"comment\">// 最后将 i 处的值置为空</span></div><div class=\"line\">                values[i] = <span class=\"keyword\">null</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">\t\t\t<span class=\"comment\">// o 向后移动一位</span></div><div class=\"line\">            o++;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    mGarbage = <span class=\"keyword\">false</span>;</div><div class=\"line\">    mSize = o;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// Log.e(\"SparseArray\", \"gc end with \" + mSize);</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面的这段代码，直接看可能理解起来也比较困难，主要是理解 <code>o</code> 只有在值等于<code>DELETED</code>的时候才不会向后移，也就是说，当<code>i</code>向后移动一位的时候，<code>o</code>还在值为<code>DELETED</code>的地方，而这时候因为<code>i != o</code>，就会触发第二个判断条件，将<code>i</code>位置的元素向前移动到<code>o</code>处。来看一张图：</p>\n<p><img src=\"http://7xtakx.com1.z0.glb.clouddn.com/sparse_array_gc.png\" alt=\"gc 原理图\"></p>\n<p>如上图所示，在 3 之前，<code>i</code>与<code>o</code>都是相等的，而到 3 的时候，因为值为<code>DELETED</code>，所以只有<code>i++</code>，而<code>o</code>的值仍然等于 2，<strong>重点来了，到 4 的时候，发现<code>i!=o</code>,则会将 4 向前移动到 3，这时候<code>o++</code>了，但是因为<code>o</code>始终小于<code>i</code>一位（这个例子里面），因此后面的元素均会向前移动一位。</strong></p>\n<p><code>gc()</code>的原理了解了，那么在什么情况下会触发<code>gc()</code>呢？上面已经知道在添加元素的时候可能会触发<code>gc()</code>，除了添加元素，前文提到过一系列跟<code>index</code>有关的方法，事实上在调用这些方法的时候，都会试图去触发<code>gc()</code>，这样可以返回给调用者一个精确的索引值。</p>\n<h4 id=\"get-1\"><a href=\"#get-1\" class=\"headerlink\" title=\"get()\"></a>get()</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">int</span> key, E valueIfKeyNotFound)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> i = ContainerHelpers.binarySearch(mKeys, mSize, key);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (i &lt; <span class=\"number\">0</span> || mValues[i] == DELETED) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> valueIfKeyNotFound;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> (E) mValues[i];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>get()</code>中的代码就比较简单了，通过二分查找获取到<code>key</code>的索引，通过该索引来获取到<code>value</code></p>\n<h3 id=\"SparseArray-的系列\"><a href=\"#SparseArray-的系列\" class=\"headerlink\" title=\"SparseArray 的系列\"></a>SparseArray 的系列</h3><p>除了前面分析的<code>SparseArray</code>，其实还有其它的一些类似的数据结构，它们总结起来就是用于存放基本数据类型的键值对：</p>\n<ul>\n<li><code>SparseIntArray</code> — int:int</li>\n<li><code>SparseBooleanArray</code>— int:boolean</li>\n<li><code>SparseLongArray</code>— int:long</li>\n</ul>\n<p>就不一一列举了，有兴趣的可以一个一个去看看，实现原理都差不太多。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>了解了<code>SparseArray</code>的实现原理，就该来总结一下它与<code>HashMap</code>之间来比较的优缺点</p>\n<p>优势：</p>\n<ul>\n<li>避免了基本数据类型的装箱操作</li>\n<li>不需要额外的结构体，单个元素的存储成本更低</li>\n<li>数据量小的情况下，随机访问的效率更高</li>\n</ul>\n<p>有优点就一定有缺点</p>\n<ul>\n<li>插入操作需要复制数组，增删效率降低</li>\n<li>数据量巨大时，复制数组成本巨大，<code>gc()</code>成本也巨大</li>\n<li>数据量巨大时，查询效率也会明显下降</li>\n</ul>\n<p>学习完了<code>SparseArray</code>，相信你对这个系列的数据结构有了更深的认识，什么时候选择什么样的数据结构，在一定程度上对于程序的运行效率会有那么一些帮助。</p>\n","categories":["Android源码学习"],"tags":[]},{"title":"2016,在此别过","url":"https://joesteven.github.io/hi_2017/","content":"<p>这篇本应该在元旦节完成的年终总结，在我难以治愈的拖延症和各种让我妥协的时间冲突中被拖到了今天。人生中的每一年都很重要，16年尤其重要吧。</p>\n<h3 id=\"再回首\"><a href=\"#再回首\" class=\"headerlink\" title=\"再回首\"></a>再回首</h3><blockquote>\n<p>时间太瘦，指缝太宽</p>\n</blockquote>\n<p>我还记得15年毕业典礼上，周绪红校长送给我们这样一句话，转眼已经到17年了。我永远都无法拖住时间，那就试图抓得再紧一些吧。我是个时不时会通过保存的物品来回忆过去的时光，那些现实和荒诞的点滴组成了如今的我，但记忆可能总是会选择性的遗忘一些事情吧。</p>\n<p>16年初来到北京，一个我曾经信誓旦旦不会触碰的城市，奈何生活从来不管你吹过什么样的牛逼，它管的可能也只有机缘巧合。然而除了气候和恼人的房价，这座显眼的城市却给了我很多不曾有过的感受。</p>\n<p>我第一次感到真正的包容和社会的多样性，没人在乎和评价你要过什么样的生活，留什么样的发型。</p>\n<p>我第一次看到身边大部分人都有明确的目标并为之奋斗</p>\n<p>我第一次知道考公务员之风并没有刮得那么厉害</p>\n<p>我第一次加入一个想要真正搞一些事情的组织</p>\n<p>我第一次见到传奇金属乐队 Metallica</p>\n<p>我第一次吃到心心念念的羊肉泡馍</p>\n<p>…</p>\n<p>而 2016 年让我第一次知道了，原来我的人生可以有很多的可能性。</p>\n<p>为了方便以后回忆，还是流水账般的记录下这一年值得记住的事情吧</p>\n<h4 id=\"职业\"><a href=\"#职业\" class=\"headerlink\" title=\"职业\"></a>职业</h4><p>加入今日头条可能是我职业生涯最值得吹嘘的事情吧，我的家人，朋友以及我可能都不会想到我会有机会加入这样一个公司，想来人生也是很妙的，只是加入了 <a href=\"http://itscoder.com/\" target=\"_blank\" rel=\"external\">itsCoder</a> 后，默默的写好每一篇技术文章，向各位前辈大佬们学习更多的知识，却给了我一个无比奇妙的机会。我常说这是偶然，而偶然中的每一个阶梯，我可以不装逼的说我都踩得很准很实。</p>\n<h4 id=\"itsCoder\"><a href=\"#itsCoder\" class=\"headerlink\" title=\"itsCoder\"></a>itsCoder</h4><p>之所以要把  <a href=\"http://itscoder.com/\" target=\"_blank\" rel=\"external\">itsCoder</a> 单独作为一项列出来，一个是因为  <a href=\"http://itscoder.com/\" target=\"_blank\" rel=\"external\">itsCoder</a> 对我来说有着很不一样的意义，另一个是因为我相信以后的每一年的总结里面都会有  <a href=\"http://itscoder.com/\" target=\"_blank\" rel=\"external\">itsCoder</a> 的大事纪。</p>\n<p>首先加入今日头条最直接的原因就是组织，在大家相互督促，鼓励，学习的氛围中我在这个原本应该感到陌生的行业中成长的很快很快，也是在大家分享和开源的精神中我努力写好每一篇文章，虽不敢大肆的推广，只希望如果某个陌生同学碰巧点开了某篇文章不会无功而返吧。</p>\n<p>更为重要的是，只身一人来到北京，几乎没有朋友，然而认识了这群人，即便是散落在五湖四海，也让我感觉有他们跟我一起在同一条路上奔走嬉闹。从最开始的技术交流和斗图，到现在的无话不谈，我能感觉到的是彼此间毫无保留的信任。</p>\n<p><a href=\"http://itscoder.com/\" target=\"_blank\" rel=\"external\">itsCoder</a> 很棒！</p>\n<h4 id=\"音乐\"><a href=\"#音乐\" class=\"headerlink\" title=\"音乐\"></a>音乐</h4><p>即便现在的空闲时间更少了，也依然会在碎片中继续玩儿音乐。</p>\n<ul>\n<li>靠着自己攒下的钱买了人生中的第一把 <a href=\"https://www.taylorguitars.com/\" target=\"_blank\" rel=\"external\">Taylor</a> 吉他</li>\n<li>靠着自己攒下的钱买了人生中的第一个效果器（想想学生时代借别人的效果器，捂脸）</li>\n<li>写了几首还算比较满意的歌</li>\n<li>学会了 Rylynn 的前半部分</li>\n<li>学会用 loop 机把鼓，贝斯，吉他叠在一起录了一首歌</li>\n<li>吉他学习从技术更偏向乐理（到今天就是第八个年头的开始了）</li>\n<li>三爷依然陪着我一起玩儿 （第六个年头开始）</li>\n</ul>\n<h4 id=\"生活\"><a href=\"#生活\" class=\"headerlink\" title=\"生活\"></a>生活</h4><p>身体更差了</p>\n<h3 id=\"向前看\"><a href=\"#向前看\" class=\"headerlink\" title=\"向前看\"></a>向前看</h3><blockquote>\n<p>但行好事，莫问前程</p>\n</blockquote>\n<p>16年就是这么过来的，17年依旧如此吧，运气一向都不会太差。</p>\n<p>前几年一直都在跟自己说等我怎么怎么样了就好好锻炼下身体，可能是没吃过亏吧。去年频繁的感冒（今天也是），肠炎，呼吸道感染让我今年不得不把身体放在第一位。</p>\n<p>父亲常常说我太急躁了，急于看到结果，把所有的时间精力在短期内都放到一件事情上，而忽略甚至忘记了其他的一些必要的事情。刚入行的时候每天写代码到很晚，对于吃饭这件事情都觉得浪费时间，每顿就怎么快怎么来，这一年是我肠炎最频发的一年。</p>\n<p>前几天写了个作息表，即便其他事情完不成，希望能把锻炼身体的计划坚持完成。</p>\n<p>之前看三弟的文章看到一句话</p>\n<blockquote>\n<p>慢慢来，会很快</p>\n</blockquote>\n<p>很喜欢，很透彻。</p>\n<p>所以今年的在技术学习和音乐学习上都慢下来，不再去追求表面华丽，把更多的时间放在基础稳固上。</p>\n<p>技术上</p>\n<ul>\n<li>编码习惯，更仔细一点，先三思，后下笔。</li>\n<li>设计模式</li>\n<li>源码，继续像16年上半年一样学习优秀的源码</li>\n</ul>\n<p>音乐上</p>\n<ul>\n<li>基础乐理巩固</li>\n<li>把七声音阶和五声音阶的指法记住</li>\n<li>电吉他效果器</li>\n</ul>\n<p>去年还买了个小鱼板，今年也把它学会吧。</p>\n<h3 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h3><p>这篇总结基本就是个人性质的，如果你碰巧点了进来，就当看了一篇朋友圈水文吧，不过很大可能你不会看到这里。</p>\n<p>今天状态不太好，等感冒好了回头再想想有什么要修改和补充的地方。</p>\n","categories":["杂谈"],"tags":[]},{"title":"LruCache 源码学习笔记","url":"https://joesteven.github.io/lrucache_source/","content":"<p>转载请附原文链接： <a href=\"http://extremej.itscoder.com/lrucache_source/\" target=\"_blank\" rel=\"external\">LruCache 源码学习笔记</a></p>\n<p>上一篇笔记分析了 Volley 中的 <a href=\"http://extremej.itscoder.com/volley_imageloader_source/\" target=\"_blank\" rel=\"external\">ImageLoder</a> ，作者推荐使用 LruCache 来作为一级缓存。本篇笔记就来分析一下 LruCache 是如何实现缓存的。如果你对 LruCache 还不了解，建议先学会使用，本篇笔记直接上源码，不会介绍使用。</p>\n<p>LruCache 是 Android 中的一个缓存工具类，在 Android 3.1 的时候加入 util 包中，对于低版本的上可以在 support 包中找到这个类。该类以 key－value 的形式保存数据，不允许 null key 或者是 null value ，因此只要get(key) 只要返回空，说明缓存中没有这个 key 对应的数据。</p>\n<p>LruCache 实际上是 LinkedHashMap + 最近使用算法，下面就进入源码中去</p>\n<h3 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h3><p>构造方法指定最大容量，初始化一个 LinedHashMap</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> size; <span class=\"comment\">// 但前大小</span></div><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> maxSize;<span class=\"comment\">// 允许的最大值</span></div><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> putCount;<span class=\"comment\">// 放入缓存数</span></div><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> createCount;<span class=\"comment\">// 创建数据数</span></div><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> evictionCount;<span class=\"comment\">// 移除数目</span></div><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> hitCount;<span class=\"comment\">// 命中数</span></div><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> missCount;<span class=\"comment\">// miss数</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LruCache</span><span class=\"params\">(<span class=\"keyword\">int</span> maxSize)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (maxSize &lt;= <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"maxSize &lt;= 0\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">this</span>.maxSize = maxSize;</div><div class=\"line\">    <span class=\"keyword\">this</span>.map = <span class=\"keyword\">new</span> LinkedHashMap&lt;K, V&gt;(<span class=\"number\">0</span>, <span class=\"number\">0.75f</span>, <span class=\"keyword\">true</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在继承了该类的时候，应该重写 sizeOf 方法来确定每一个元素的大小，默认返回是1</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> <span class=\"title\">sizeOf</span><span class=\"params\">(K key, V value)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"trimToSize-核心代码\"><a href=\"#trimToSize-核心代码\" class=\"headerlink\" title=\"trimToSize () 核心代码\"></a>trimToSize () 核心代码</h3><p>LruCache 中有一个方法 trimToSize() ，这个方法就是根据允许的最大容量来调整存储的元素，是否需要清理掉。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">trimToSize</span><span class=\"params\">(<span class=\"keyword\">int</span> maxSize)</span> </span>&#123;</div><div class=\"line\">  \t<span class=\"comment\">// 首先进入一个循环</span></div><div class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</div><div class=\"line\">        K key;</div><div class=\"line\">        V value;</div><div class=\"line\">        <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</div><div class=\"line\">          \t<span class=\"comment\">// 如果当前的容量小于0，或者实际为空但 size不为0 抛异常</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (size &lt; <span class=\"number\">0</span> || (map.isEmpty() &amp;&amp; size != <span class=\"number\">0</span>)) &#123;</div><div class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(getClass().getName()</div><div class=\"line\">                        + <span class=\"string\">\".sizeOf() is reporting inconsistent results!\"</span>);</div><div class=\"line\">            &#125;</div><div class=\"line\">\t\t\t<span class=\"comment\">// 如果当前大小小于最大容量，跳出循环，不需要调整</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (size &lt;= maxSize) &#123;</div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">          \t<span class=\"comment\">// 到这一步则说明当前大小已经大于了允许的最大容量</span></div><div class=\"line\">\t\t\t<span class=\"comment\">// 找到缓存中最老的那个元素</span></div><div class=\"line\">            Map.Entry&lt;K, V&gt; toEvict = map.eldest();</div><div class=\"line\">            <span class=\"keyword\">if</span> (toEvict == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">\t\t\t<span class=\"comment\">// 从集合移除这个元素，重新计算当前大小，移除的数量＋1</span></div><div class=\"line\">          \t<span class=\"comment\">// 进入下一次循环判断</span></div><div class=\"line\">            key = toEvict.getKey();</div><div class=\"line\">            value = toEvict.getValue();</div><div class=\"line\">            map.remove(key);</div><div class=\"line\">            size -= safeSizeOf(key, value);</div><div class=\"line\">            evictionCount++;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        entryRemoved(<span class=\"keyword\">true</span>, key, value, <span class=\"keyword\">null</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面就是调整缓存空间的核心代码，总共没有几行。剩下的就是简单的查找，增加，移除等等操作</p>\n<h3 id=\"put\"><a href=\"#put\" class=\"headerlink\" title=\"put()\"></a>put()</h3><p>在往缓存中放数据的时候，考虑了一个冲突的问题，可能这个值已经缓存过了，默认采用的是覆盖，但是提供了一个方法来自定义是覆盖还是保留。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (key == <span class=\"keyword\">null</span> || value == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException(<span class=\"string\">\"key == null || value == null\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">\t<span class=\"comment\">// 已经缓存过的值</span></div><div class=\"line\">    V previous;</div><div class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</div><div class=\"line\">        putCount++;</div><div class=\"line\">      \t<span class=\"comment\">// 增加当前大小</span></div><div class=\"line\">        size += safeSizeOf(key, value);</div><div class=\"line\">      \t<span class=\"comment\">// 缓存到map中，并获取是否有冲突的值</span></div><div class=\"line\">        previous = map.put(key, value);</div><div class=\"line\">        <span class=\"keyword\">if</span> (previous != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">          \t<span class=\"comment\">// 如果之前已经缓存过了，那只是覆盖，因此需要把之前这个值的大小减去</span></div><div class=\"line\">            size -= safeSizeOf(key, previous);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (previous != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">      \t<span class=\"comment\">// 该方法提供给使用者自定义是覆盖还是取消</span></div><div class=\"line\">        entryRemoved(<span class=\"keyword\">false</span>, key, previous, value);</div><div class=\"line\">    &#125;</div><div class=\"line\">\t<span class=\"comment\">// 检查大小并调整</span></div><div class=\"line\">    trimToSize(maxSize);</div><div class=\"line\">  \t<span class=\"comment\">// 返回冲突的值</span></div><div class=\"line\">    <span class=\"keyword\">return</span> previous;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在 LruCache 中只要有元素被移除就会调用一个方法 entryRemoved()，复写这个方法可以自定义你自己的冲突处理策略。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">entryRemoved</span><span class=\"params\">(<span class=\"keyword\">boolean</span> evicted, K key, V oldValue, V newValue)</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"get\"><a href=\"#get\" class=\"headerlink\" title=\"get()\"></a>get()</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> V <span class=\"title\">get</span><span class=\"params\">(K key)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (key == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException(<span class=\"string\">\"key == null\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    V mapValue;</div><div class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</div><div class=\"line\">      \t<span class=\"comment\">// 从缓存中找元素</span></div><div class=\"line\">        mapValue = map.get(key);</div><div class=\"line\">        <span class=\"keyword\">if</span> (mapValue != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">          \t<span class=\"comment\">// 找到后 命中数＋1 返回这个元素</span></div><div class=\"line\">            hitCount++;</div><div class=\"line\">            <span class=\"keyword\">return</span> mapValue;</div><div class=\"line\">        &#125;</div><div class=\"line\">      \t<span class=\"comment\">// 没找到就把 miss 数＋1</span></div><div class=\"line\">        missCount++;</div><div class=\"line\">    &#125;</div><div class=\"line\">\t<span class=\"comment\">// 以下的代码会试图创建一个数据返回</span></div><div class=\"line\">    <span class=\"comment\">/*</span></div><div class=\"line\">     * Attempt to create a value. This may take a long time, and the map</div><div class=\"line\">     * may be different when create() returns. If a conflicting value was</div><div class=\"line\">     * added to the map while create() was working, we leave that value in</div><div class=\"line\">     * the map and release the created value.</div><div class=\"line\">     */</div><div class=\"line\">\t<span class=\"comment\">// 如果创建的元素为 null 直接返回 null</span></div><div class=\"line\">    V createdValue = create(key);</div><div class=\"line\">    <span class=\"keyword\">if</span> (createdValue == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</div><div class=\"line\">      \t<span class=\"comment\">// 说明创建元素成功</span></div><div class=\"line\">        createCount++;</div><div class=\"line\">      \t<span class=\"comment\">// 添加到缓存中</span></div><div class=\"line\">        mapValue = map.put(key, createdValue);</div><div class=\"line\">\t\t</div><div class=\"line\">        <span class=\"keyword\">if</span> (mapValue != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            <span class=\"comment\">// There was a conflict so undo that last put</span></div><div class=\"line\">          \t<span class=\"comment\">// 发生了冲突，则回滚操作，留给使用者自己处理</span></div><div class=\"line\">            map.put(key, mapValue);</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">          \t<span class=\"comment\">// 计算当前大小</span></div><div class=\"line\">            size += safeSizeOf(key, createdValue);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (mapValue != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">      \t<span class=\"comment\">// 发生了冲突，交给调用者处理</span></div><div class=\"line\">        entryRemoved(<span class=\"keyword\">false</span>, key, createdValue, mapValue);</div><div class=\"line\">        <span class=\"keyword\">return</span> mapValue;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      \t<span class=\"comment\">// 添加缓存成功，重新判断大小并处理</span></div><div class=\"line\">        trimToSize(maxSize);</div><div class=\"line\">        <span class=\"keyword\">return</span> createdValue;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到 LruCache 在获取缓存失败了之后，还提供了创建的方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> V <span class=\"title\">create</span><span class=\"params\">(K key)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"remove\"><a href=\"#remove\" class=\"headerlink\" title=\"remove()\"></a>remove()</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> V <span class=\"title\">remove</span><span class=\"params\">(K key)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (key == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException(<span class=\"string\">\"key == null\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    V previous;</div><div class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</div><div class=\"line\">        previous = map.remove(key);</div><div class=\"line\">        <span class=\"keyword\">if</span> (previous != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">          \t<span class=\"comment\">// 移除成功，重写计算大小</span></div><div class=\"line\">            size -= safeSizeOf(key, previous);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (previous != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        entryRemoved(<span class=\"keyword\">false</span>, key, previous, <span class=\"keyword\">null</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> previous;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h3><p>LruCache  的源码就分析完了，发现其实原理没有想象的复杂，事实上有很多牛逼的框架原理也没有想象的那么难，可能就是用最简单的逻辑堆叠而成。</p>\n","categories":["Android源码学习"],"tags":[]},{"title":"Volley 中的ImageLoader源码学习笔记","url":"https://joesteven.github.io/volley_imageloader_source/","content":"<p>转载请附原文链接： <a href=\"http://extremej.itscoder.com/volley_imageloader_source/\" target=\"_blank\" rel=\"external\">Volley 中的ImageLoader源码学习笔记</a></p>\n<p>本篇笔记建立在上一篇分析 Volley 源码的基础上，如果你对 Volley 的源码还不了解可以看看上一篇笔记， <a href=\"http://extremej.itscoder.com/volley_source/\" target=\"_blank\" rel=\"external\">传送门</a></p>\n<p>在 Android 中还有一大头疼的问题就是图片的加载， Volley 中封装了一个 ImageLoader 的类可以用来加载图片。本篇笔记就来分析一下 Volley 是如何处理图片加载的。</p>\n<p>主要涉及的类：</p>\n<ul>\n<li>ImageLoader  (Volley中的)</li>\n<li>ImageRequest</li>\n</ul>\n<h3 id=\"创建-ImageLoader\"><a href=\"#创建-ImageLoader\" class=\"headerlink\" title=\"创建 ImageLoader\"></a>创建 ImageLoader</h3><p>使用首先要创建一个 ImageLoader 对象，传入一个 请求队列，和一个 ImageCache。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ImageLoader</span><span class=\"params\">(RequestQueue queue, ImageCache imageCache)</span> </span>&#123;</div><div class=\"line\">    mRequestQueue = queue;</div><div class=\"line\">    mCache = imageCache;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>ImageCache 是一个接口，里面有两个方法，一个从缓存中获取图片，另一个将图片放入缓存中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ImageCache</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Bitmap <span class=\"title\">getBitmap</span><span class=\"params\">(String url)</span></span>;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">putBitmap</span><span class=\"params\">(String url, Bitmap bitmap)</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>作者在这里写了一个注释，建议使用 LruCache 来实现这个接口。</p>\n<p><strong>ImageCache 作为三级缓存中的第一级缓存，也就是内存缓存</strong></p>\n<h3 id=\"获取图片\"><a href=\"#获取图片\" class=\"headerlink\" title=\"获取图片\"></a>获取图片</h3><p>通过 get() 方法可以传入一个图片的 url 并通过 ImageListener 来获取图片。这里再提一嘴，Volley 的作者注释真的写得很清楚啊，基本上把逻辑都说的很明白。这个方法要求在主线程调用，因为显示图片需要在主线程嘛</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ImageContainer <span class=\"title\">get</span><span class=\"params\">(String requestUrl, ImageListener imageListener,</span></span></div><div class=\"line\">        <span class=\"keyword\">int</span> maxWidth, <span class=\"keyword\">int</span> maxHeight, ScaleType scaleType) &#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// only fulfill requests that were initiated from the main thread.</span></div><div class=\"line\">  \t<span class=\"comment\">// 如果不在主线程调用，抛异常</span></div><div class=\"line\">    throwIfNotOnMainThread();</div><div class=\"line\">\t<span class=\"comment\">// 获取到缓存的 key(Volley 自己拼的字符串作为唯一的 key)</span></div><div class=\"line\">    <span class=\"keyword\">final</span> String cacheKey = getCacheKey(requestUrl, maxWidth, maxHeight, scaleType);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// Try to look up the request in the cache of remote images.</span></div><div class=\"line\">  \t<span class=\"comment\">// 在一级缓存中去找图片</span></div><div class=\"line\">    Bitmap cachedBitmap = mCache.getBitmap(cacheKey);</div><div class=\"line\">    <span class=\"keyword\">if</span> (cachedBitmap != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">      \t<span class=\"comment\">// 找到了图片，将图片放到 ImageContainer里面，回调监听</span></div><div class=\"line\">        <span class=\"comment\">// Return the cached bitmap.</span></div><div class=\"line\">        ImageContainer container = <span class=\"keyword\">new</span> ImageContainer(cachedBitmap, requestUrl, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>);</div><div class=\"line\">        imageListener.onResponse(container, <span class=\"keyword\">true</span>);</div><div class=\"line\">        <span class=\"keyword\">return</span> container;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// The bitmap did not exist in the cache, fetch it!</span></div><div class=\"line\">  \t<span class=\"comment\">// 到这里说明一级缓存里面是没有图片的，创建一个新的 ImageContainer</span></div><div class=\"line\">  \t<span class=\"comment\">// 这时候按照三级缓存的步骤应该去磁盘上寻找图片</span></div><div class=\"line\">    ImageContainer imageContainer =</div><div class=\"line\">            <span class=\"keyword\">new</span> ImageContainer(<span class=\"keyword\">null</span>, requestUrl, cacheKey, imageListener);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// Update the caller to let them know that they should use the default bitmap.</span></div><div class=\"line\">  \t<span class=\"comment\">// 这里回调的原因，是为了告诉调用者没有在内存中找到图片</span></div><div class=\"line\">  \t<span class=\"comment\">// 需要从本地或者网络获取图片，回调可以设置一个 placeholder 占位图</span></div><div class=\"line\">    imageListener.onResponse(imageContainer, <span class=\"keyword\">true</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// Check to see if a request is already in-flight.</span></div><div class=\"line\">  \t<span class=\"comment\">// 检查是否已经有一个相同的请求正在等待处理(加载同一张图片)</span></div><div class=\"line\">    BatchedImageRequest request = mInFlightRequests.get(cacheKey);</div><div class=\"line\">    <span class=\"keyword\">if</span> (request != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        <span class=\"comment\">// If it is, add this request to the list of listeners.</span></div><div class=\"line\">      \t<span class=\"comment\">// 如果有，则将该 imageContainer 加入到这个请求的监听列表中去</span></div><div class=\"line\">        request.addContainer(imageContainer);</div><div class=\"line\">        <span class=\"keyword\">return</span> imageContainer;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// The request is not already in flight. Send the new request to the network and</span></div><div class=\"line\">    <span class=\"comment\">// track it.</span></div><div class=\"line\">  \t<span class=\"comment\">// 到这里说明没有重复的请求，那么就要创建一个新的请求了</span></div><div class=\"line\">    Request&lt;Bitmap&gt; newRequest = makeImageRequest(requestUrl, maxWidth, maxHeight, scaleType,cacheKey);</div><div class=\"line\">\t<span class=\"comment\">// 添加到请求队列中，剩下的事情就跟上一篇分析Volley中的处理流程一样的</span></div><div class=\"line\">   \t<span class=\"comment\">// 也就是剩下的两级缓存</span></div><div class=\"line\">    mRequestQueue.add(newRequest);</div><div class=\"line\">  \t<span class=\"comment\">// 添加到正在处理的集合中</span></div><div class=\"line\">    mInFlightRequests.put(cacheKey,</div><div class=\"line\">            <span class=\"keyword\">new</span> BatchedImageRequest(newRequest, imageContainer));</div><div class=\"line\">    <span class=\"keyword\">return</span> imageContainer;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如果没有在一级缓存中获取到图片会创建一个请求</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> Request&lt;Bitmap&gt; <span class=\"title\">makeImageRequest</span><span class=\"params\">(String requestUrl, <span class=\"keyword\">int</span> maxWidth, <span class=\"keyword\">int</span> maxHeight,</span></span></div><div class=\"line\">        ScaleType scaleType, <span class=\"keyword\">final</span> String cacheKey) &#123;</div><div class=\"line\">  \t<span class=\"comment\">// 创建一个 ImageRequest</span></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ImageRequest(requestUrl, <span class=\"keyword\">new</span> Listener&lt;Bitmap&gt;() &#123;</div><div class=\"line\">        <span class=\"meta\">@Override</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onResponse</span><span class=\"params\">(Bitmap response)</span> </span>&#123;</div><div class=\"line\">          \t<span class=\"comment\">// 成功后回调</span></div><div class=\"line\">            onGetImageSuccess(cacheKey, response);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;, maxWidth, maxHeight, scaleType, Config.RGB_565, <span class=\"keyword\">new</span> ErrorListener() &#123;</div><div class=\"line\">        <span class=\"meta\">@Override</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onErrorResponse</span><span class=\"params\">(VolleyError error)</span> </span>&#123;</div><div class=\"line\">            onGetImageError(cacheKey, error);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>当成功获取到图片后，首先把图片放到内存缓存中去</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onGetImageSuccess</span><span class=\"params\">(String cacheKey, Bitmap response)</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// cache the image that was fetched.</span></div><div class=\"line\">    mCache.putBitmap(cacheKey, response);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// remove the request from the list of in-flight requests.</span></div><div class=\"line\">  \t<span class=\"comment\">// 把这个请求从正在处理的集合中移除</span></div><div class=\"line\">    BatchedImageRequest request = mInFlightRequests.remove(cacheKey);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (request != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        <span class=\"comment\">// Update the response bitmap.</span></div><div class=\"line\">      \t<span class=\"comment\">// 获取到图片</span></div><div class=\"line\">        request.mResponseBitmap = response;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// Send the batched response</span></div><div class=\"line\">        batchResponse(cacheKey, request);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>接下来就是将图片发送到各个监听中去。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">batchResponse</span><span class=\"params\">(String cacheKey, BatchedImageRequest request)</span> </span>&#123;</div><div class=\"line\">    mBatchedResponses.put(cacheKey, request);</div><div class=\"line\">    <span class=\"comment\">// If we don't already have a batch delivery runnable in flight, make a new one.</span></div><div class=\"line\">    <span class=\"comment\">// Note that this will be used to deliver responses to all callers in mBatchedResponses.</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (mRunnable == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        mRunnable = <span class=\"keyword\">new</span> Runnable() &#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">                <span class=\"keyword\">for</span> (BatchedImageRequest bir : mBatchedResponses.values()) &#123;</div><div class=\"line\">                    <span class=\"keyword\">for</span> (ImageContainer container : bir.mContainers) &#123;</div><div class=\"line\">                        <span class=\"comment\">// If one of the callers in the batched request canceled the request</span></div><div class=\"line\">                        <span class=\"comment\">// after the response was received but before it was delivered,</span></div><div class=\"line\">                        <span class=\"comment\">// skip them.</span></div><div class=\"line\">                        <span class=\"keyword\">if</span> (container.mListener == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                            <span class=\"keyword\">continue</span>;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        <span class=\"keyword\">if</span> (bir.getError() == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                            container.mBitmap = bir.mResponseBitmap;</div><div class=\"line\">                            container.mListener.onResponse(container, <span class=\"keyword\">false</span>);</div><div class=\"line\">                        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                            container.mListener.onErrorResponse(bir.getError());</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">                mBatchedResponses.clear();</div><div class=\"line\">                mRunnable = <span class=\"keyword\">null</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">        &#125;;</div><div class=\"line\">        <span class=\"comment\">// Post the runnable.</span></div><div class=\"line\">        mHandler.postDelayed(mRunnable, mBatchResponseDelayMs);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"ImageContainer-图片数据容器\"><a href=\"#ImageContainer-图片数据容器\" class=\"headerlink\" title=\"ImageContainer 图片数据容器\"></a>ImageContainer 图片数据容器</h3><p>一次加载图片会出现多种情况，可能从三级缓存中的任意一级中获取，这样就会有多种数据，因此封装了一个 ImageContainer 来为一次单独的加载请求持有所有的数据。</p>\n<ul>\n<li>mBitmap — 图片</li>\n<li>mListener — 监听</li>\n<li>mCacheKey — 缓存key</li>\n<li>mRequestUrl — 请求url</li>\n</ul>\n<p>有三个方法分别是获取图片，获取url，和取消请求。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">cancelRequest</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (mListener == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    BatchedImageRequest request = mInFlightRequests.get(mCacheKey);</div><div class=\"line\">    <span class=\"keyword\">if</span> (request != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">boolean</span> canceled = request.removeContainerAndCancelIfNecessary(<span class=\"keyword\">this</span>);</div><div class=\"line\">        <span class=\"keyword\">if</span> (canceled) &#123;</div><div class=\"line\">            mInFlightRequests.remove(mCacheKey);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"comment\">// check to see if it is already batched for delivery.</span></div><div class=\"line\">        request = mBatchedResponses.get(mCacheKey);</div><div class=\"line\">        <span class=\"keyword\">if</span> (request != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            request.removeContainerAndCancelIfNecessary(<span class=\"keyword\">this</span>);</div><div class=\"line\">            <span class=\"keyword\">if</span> (request.mContainers.size() == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">                mBatchedResponses.remove(mCacheKey);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"getImageListener-默认的监听加载\"><a href=\"#getImageListener-默认的监听加载\" class=\"headerlink\" title=\"getImageListener 默认的监听加载\"></a>getImageListener 默认的监听加载</h3><p>就贴个代码凑字数～没什么好说的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ImageListener <span class=\"title\">getImageListener</span><span class=\"params\">(<span class=\"keyword\">final</span> ImageView view,</span></span></div><div class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> defaultImageResId, <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> errorImageResId) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ImageListener() &#123;</div><div class=\"line\">        <span class=\"meta\">@Override</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onErrorResponse</span><span class=\"params\">(VolleyError error)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (errorImageResId != <span class=\"number\">0</span>) &#123;</div><div class=\"line\">                view.setImageResource(errorImageResId);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"meta\">@Override</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onResponse</span><span class=\"params\">(ImageContainer response, <span class=\"keyword\">boolean</span> isImmediate)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (response.getBitmap() != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                view.setImageBitmap(response.getBitmap());</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (defaultImageResId != <span class=\"number\">0</span>) &#123;</div><div class=\"line\">                view.setImageResource(defaultImageResId);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"图片的处理\"><a href=\"#图片的处理\" class=\"headerlink\" title=\"图片的处理\"></a>图片的处理</h3><p>我们知道在 Android 中加载图片，很容易发生 OOM 的情况，所以对图片的处理是非常有必要的。在 ImageLoader 中似乎没有看到任何处理图片的代码。实际上是在 ImageRequest 里面处理的，在拿到 Response 后就对图片进行了处理。</p>\n<p>有时候我们可能只需要展示100*100 大小的图片，但是原图可能非常大，如果全部加载到内存中必然是浪费了空间并且可能造成内存溢出。所以我们可以根据要展示的实际大小来缩放图片，这样可以节省很大一部分内存空间。</p>\n<p>首先科普一个小技巧，我们知道可以通过 BitmapFactory 来创建一个 Bitmap 对象，但是 BitmapFactory 会预先将这个 Bitmap 加载到内存中，实际上我们还需要对 Bitmap 进行处理，这样占用了无效的内存。BitmapFactory 在创建的时候可以传入一个 Options 对象来改变一些参数。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">BitmapFactory.Options decodeOptions = <span class=\"keyword\">new</span> BitmapFactory.Options();</div><div class=\"line\">decodeOptions.inJustDecodeBounds = <span class=\"keyword\">true</span>;</div></pre></td></tr></table></figure>\n<p>这个对象有一个属性是 inJustDecodeBounds ，从字面理解是只解码边界。这个属性设置为 true 后，BitmapFactory 返回的 Bitmap 为 null,并没有解码，但是图片的宽高等属性是可以获取到的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> actualWidth = decodeOptions.outWidth;</div><div class=\"line\"><span class=\"keyword\">int</span> actualHeight = decodeOptions.outHeight;</div></pre></td></tr></table></figure>\n<p>这个技巧可以允许我们在不占用内存的情况下获取到图片的实际宽高，从而进行缩放。Options 中还有一个参数</p>\n<p><strong>inSampleSize</strong> — 采样率，默认为1。表示从 n 个像素中获取一个像素</p>\n<p>这个参数需要注意几点</p>\n<ul>\n<li>值越大，缩放越小。</li>\n</ul>\n<ul>\n<li>如果这个值小于1，在处理的时候会设置为1。（因为不可能从一个像素中取半个吧，囧）</li>\n<li>值尽可能接近 2 的倍数，因为如果不是 2 的倍数，在底层方法中会向下取值为 2 的倍数</li>\n</ul>\n<p>知道这个技术后就可以通过图片的实际宽高和需要展示的宽高算出缩放比（采样率）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Response&lt;Bitmap&gt; <span class=\"title\">doParse</span><span class=\"params\">(NetworkResponse response)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">byte</span>[] data = response.data;</div><div class=\"line\">    BitmapFactory.Options decodeOptions = <span class=\"keyword\">new</span> BitmapFactory.Options();</div><div class=\"line\">    Bitmap bitmap = <span class=\"keyword\">null</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span> (mMaxWidth == <span class=\"number\">0</span> &amp;&amp; mMaxHeight == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        decodeOptions.inPreferredConfig = mDecodeConfig;</div><div class=\"line\">        bitmap = BitmapFactory.decodeByteArray(data, <span class=\"number\">0</span>, data.length, decodeOptions);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"comment\">// If we have to resize this image, first get the natural bounds.</span></div><div class=\"line\">        decodeOptions.inJustDecodeBounds = <span class=\"keyword\">true</span>;</div><div class=\"line\">        BitmapFactory.decodeByteArray(data, <span class=\"number\">0</span>, data.length, decodeOptions);</div><div class=\"line\">        <span class=\"keyword\">int</span> actualWidth = decodeOptions.outWidth;</div><div class=\"line\">        <span class=\"keyword\">int</span> actualHeight = decodeOptions.outHeight;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// Then compute the dimensions we would ideally like to decode to.</span></div><div class=\"line\">      \t<span class=\"comment\">// 计算调整后的图片尺寸(根据 ScaleType 等)</span></div><div class=\"line\">        <span class=\"keyword\">int</span> desiredWidth = getResizedDimension(mMaxWidth, mMaxHeight,</div><div class=\"line\">                actualWidth, actualHeight, mScaleType);</div><div class=\"line\">        <span class=\"keyword\">int</span> desiredHeight = getResizedDimension(mMaxHeight, mMaxWidth,</div><div class=\"line\">                actualHeight, actualWidth, mScaleType);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// Decode to the nearest power of two scaling factor.</span></div><div class=\"line\">        decodeOptions.inJustDecodeBounds = <span class=\"keyword\">false</span>;</div><div class=\"line\">        <span class=\"comment\">// TODO(ficus): Do we need this or is it okay since API 8 doesn't support it?</span></div><div class=\"line\">        <span class=\"comment\">// decodeOptions.inPreferQualityOverSpeed = PREFER_QUALITY_OVER_SPEED;</span></div><div class=\"line\">      \t<span class=\"comment\">// 根据调整后的尺寸算出采样率</span></div><div class=\"line\">        decodeOptions.inSampleSize =</div><div class=\"line\">            findBestSampleSize(actualWidth, actualHeight, desiredWidth, desiredHeight);</div><div class=\"line\">        Bitmap tempBitmap =</div><div class=\"line\">            BitmapFactory.decodeByteArray(data, <span class=\"number\">0</span>, data.length, decodeOptions);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// If necessary, scale down to the maximal acceptable size.</span></div><div class=\"line\">      \t<span class=\"comment\">// 如果调整后的图片还是大于了目标尺寸，再缩放一次</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (tempBitmap != <span class=\"keyword\">null</span> &amp;&amp; (tempBitmap.getWidth() &gt; desiredWidth ||</div><div class=\"line\">                tempBitmap.getHeight() &gt; desiredHeight)) &#123;</div><div class=\"line\">            bitmap = Bitmap.createScaledBitmap(tempBitmap,</div><div class=\"line\">                    desiredWidth, desiredHeight, <span class=\"keyword\">true</span>);</div><div class=\"line\">            tempBitmap.recycle();</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            bitmap = tempBitmap;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (bitmap == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> Response.error(<span class=\"keyword\">new</span> ParseError(response));</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> Response.success(bitmap, HttpHeaderParser.parseCacheHeaders(response));</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>看看 Volley 是怎么计算目标尺寸的，这个方法传入五个参数</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">getResizedDimension</span><span class=\"params\">(<span class=\"keyword\">int</span> maxPrimary, <span class=\"keyword\">int</span> maxSecondary, <span class=\"keyword\">int</span> actualPrimary,<span class=\"keyword\">int</span> actualSecondary, ScaleType scaleType)</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// If no dominant value at all, just return the actual.</span></div><div class=\"line\">  \t<span class=\"comment\">// 没有调整</span></div><div class=\"line\">    <span class=\"keyword\">if</span> ((maxPrimary == <span class=\"number\">0</span>) &amp;&amp; (maxSecondary == <span class=\"number\">0</span>)) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> actualPrimary;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// If ScaleType.FIT_XY fill the whole rectangle, ignore ratio.</span></div><div class=\"line\">  \t<span class=\"comment\">// 如果是 fit_xy ,则直接返回尺寸，忽略掉比率</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (scaleType == ScaleType.FIT_XY) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (maxPrimary == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> actualPrimary;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> maxPrimary;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// If primary is unspecified, scale primary to match secondary's scaling ratio.</span></div><div class=\"line\">   \t<span class=\"comment\">// 如果最大的主值为空，用第二个值来计算比率，再计算尺寸</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (maxPrimary == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">double</span> ratio = (<span class=\"keyword\">double</span>) maxSecondary / (<span class=\"keyword\">double</span>) actualSecondary;</div><div class=\"line\">        <span class=\"keyword\">return</span> (<span class=\"keyword\">int</span>) (actualPrimary * ratio);</div><div class=\"line\">    &#125;</div><div class=\"line\">\t<span class=\"comment\">// 如果第二个值为空，直接返回最大值</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (maxSecondary == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> maxPrimary;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">double</span> ratio = (<span class=\"keyword\">double</span>) actualSecondary / (<span class=\"keyword\">double</span>) actualPrimary;</div><div class=\"line\">    <span class=\"keyword\">int</span> resized = maxPrimary;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// If ScaleType.CENTER_CROP fill the whole rectangle, preserve aspect ratio.</span></div><div class=\"line\">  \t<span class=\"comment\">// 如果缩放类型是 center_crop，则要保持宽高比</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (scaleType == ScaleType.CENTER_CROP) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> ((resized * ratio) &lt; maxSecondary) &#123;</div><div class=\"line\">            resized = (<span class=\"keyword\">int</span>) (maxSecondary / ratio);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> resized;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> ((resized * ratio) &gt; maxSecondary) &#123;</div><div class=\"line\">        resized = (<span class=\"keyword\">int</span>) (maxSecondary / ratio);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> resized;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>最后是计算采样率的方法，用实际的宽高分别计算比率，取最小的那个值，并且尽量接近2的倍数。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">findBestSampleSize</span><span class=\"params\">(</span></span></div><div class=\"line\">        <span class=\"keyword\">int</span> actualWidth, <span class=\"keyword\">int</span> actualHeight, <span class=\"keyword\">int</span> desiredWidth, <span class=\"keyword\">int</span> desiredHeight) &#123;</div><div class=\"line\">    <span class=\"keyword\">double</span> wr = (<span class=\"keyword\">double</span>) actualWidth / desiredWidth;</div><div class=\"line\">    <span class=\"keyword\">double</span> hr = (<span class=\"keyword\">double</span>) actualHeight / desiredHeight;</div><div class=\"line\">    <span class=\"keyword\">double</span> ratio = Math.min(wr, hr);</div><div class=\"line\">    <span class=\"keyword\">float</span> n = <span class=\"number\">1.0f</span>;</div><div class=\"line\">    <span class=\"keyword\">while</span> ((n * <span class=\"number\">2</span>) &lt;= ratio) &#123;</div><div class=\"line\">        n *= <span class=\"number\">2</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"keyword\">int</span>) n;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h3><p>通过学习 Volley 中的 ImageLoader 源码，对于图片的处理的理解更加深入，相信就算是自己来写图片加载，也不会有原来那么头疼。在本篇笔记中提到了 LruCache，这是 Android 官方提倡的缓存方式，因为现在对于软引用和弱饮用也会直接回收，不再可靠。在下一篇源码中将分析 LruCache 源码，看它是如果来解决缓存问题的。</p>\n","categories":["Android源码学习"],"tags":[]},{"title":"Volley源码学习笔记","url":"https://joesteven.github.io/volley_source/","content":"<p>转载请附原文链接： <a href=\"http://extremej.itscoder.com/volley_source/\" target=\"_blank\" rel=\"external\">Volley 源码学习笔记</a></p>\n<p>这几天开启了疯狂的源码学习模式，今天学习的是网络框架 — Volley。依旧按照一贯的思路，从用法入手，再全面分析。</p>\n<p>其实把 Volley 理解成为一个 Request （请求）的调度器可能更容易学习。</p>\n<p>本次分析主要涉及到的类：</p>\n<ul>\n<li>Volley — 获取队列的帮助类</li>\n<li>RequestQueue — 请求队列，维护请求调度</li>\n<li>NetWorkDispatcher — 网络请求线程</li>\n<li>CacheDispatcher — 缓存线程</li>\n<li>Request — 请求</li>\n</ul>\n<h3 id=\"流程图\"><a href=\"#流程图\" class=\"headerlink\" title=\"流程图\"></a>流程图</h3><p> <img src=\"/img/volley流程图.jpg\" alt=\"volley流程图\"></p>\n<p>上面是一张 Volley 处理请求的流程图，简单介绍一下有一个大体的认识，再看源码的时候理解起来会相对容易很多。从上到下依次介绍</p>\n<ul>\n<li>首先会把这个请求加入到一个当前请求的队列中，在这个队列中的请求都表示被 Volley 处理过。在后面结束或者取消请求的时候需要用到</li>\n<li>接着判断是否需要缓存，需要走左边，不需要走右边直接加入 网络请求队列中</li>\n<li>左边是一个等待队列，用于判断当前是否有相同的请求正在进行，如果有则相同的请求都放到这个等待队列中不马上执行。如果没有则向下放到缓存队列中，同时在等待队列中标记该请求</li>\n<li>如果请求被加入到等待队列中了，当正在进行的那个请求被执行完毕后，会将等待队列中重复的请求都放到缓存队列中，也就是直接使用缓存数据而不请求网络了。</li>\n</ul>\n<p>这是大致的流程，实际上的处理还有很多小细节，后面几节慢慢的来学习。</p>\n<h3 id=\"创建-RequestQueue\"><a href=\"#创建-RequestQueue\" class=\"headerlink\" title=\"创建 RequestQueue\"></a>创建 RequestQueue</h3><p>用过 Volley 的同学都知道，使用前应该先获取一个请求队列，然后创建请求，再把请求加入到队列当中去。一般在 Android 中会获取一个全局单例的队列，便于对请求的统一管理。首先来看获取队列的代码。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">RequestQueue mRequestQueue = Volley.newRequestQueue(<span class=\"keyword\">this</span>);</div></pre></td></tr></table></figure>\n<p>来看看 Volley 是怎么创建请求队列的，上面的这个方法调用下面这个方法，传入一个空的 HttpStack。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> RequestQueue <span class=\"title\">newRequestQueue</span><span class=\"params\">(Context context, HttpStack stack)</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 指定磁盘缓存目录</span></div><div class=\"line\">  \tFile cacheDir = <span class=\"keyword\">new</span> File(context.getCacheDir(), DEFAULT_CACHE_DIR);</div><div class=\"line\">\t</div><div class=\"line\">    String userAgent = <span class=\"string\">\"volley/0\"</span>;</div><div class=\"line\">    <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">        String packageName = context.getPackageName();</div><div class=\"line\">        PackageInfo info = context.getPackageManager().getPackageInfo(packageName, <span class=\"number\">0</span>);</div><div class=\"line\">        userAgent = packageName + <span class=\"string\">\"/\"</span> + info.versionCode;</div><div class=\"line\">    &#125; <span class=\"keyword\">catch</span> (NameNotFoundException e) &#123;</div><div class=\"line\">    &#125;</div><div class=\"line\">\t<span class=\"comment\">// 如果没有指定 HttpStack</span></div><div class=\"line\">  \t<span class=\"comment\">// 1.在 api9 以上的情况使用 HurlStack -- 实际上就是 HttpUrlConnection</span></div><div class=\"line\">  \t<span class=\"comment\">// 2.api9 一下则使用 HttpClient 作为网络请求</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (stack == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (Build.VERSION.SDK_INT &gt;= <span class=\"number\">9</span>) &#123;</div><div class=\"line\">            stack = <span class=\"keyword\">new</span> HurlStack();</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"comment\">// Prior to Gingerbread, HttpUrlConnection was unreliable.</span></div><div class=\"line\">            <span class=\"comment\">// See: http://android-developers.blogspot.com/2011/09/androids-http-clients.html</span></div><div class=\"line\">            stack = <span class=\"keyword\">new</span> HttpClientStack(AndroidHttpClient.newInstance(userAgent));</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">\t<span class=\"comment\">// 通过 stack 创建 Network 处理网络请求</span></div><div class=\"line\">    Network network = <span class=\"keyword\">new</span> BasicNetwork(stack);</div><div class=\"line\">\t<span class=\"comment\">// 创建一个请求队列</span></div><div class=\"line\">    RequestQueue queue = <span class=\"keyword\">new</span> RequestQueue(<span class=\"keyword\">new</span> DiskBasedCache(cacheDir), network);</div><div class=\"line\">    <span class=\"comment\">// 开始运行队列</span></div><div class=\"line\">  \tqueue.start();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> queue;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面的代码就是创建了一个 RequestQueue 对象，指定了缓存策略和网络请求处理。这里要插一句，为什么区分了一下 SDK 的版本呢？</p>\n<h4 id=\"HttpUrlConnection-和-HttpClient-的区别\"><a href=\"#HttpUrlConnection-和-HttpClient-的区别\" class=\"headerlink\" title=\"HttpUrlConnection 和 HttpClient 的区别\"></a>HttpUrlConnection 和 HttpClient 的区别</h4><p>HttpClient 是一个网络框架，封装得较为完善，提供了大量的 API 给调用者，性能上也比较稳定。但是这也导致 HttpClient 在保持兼容的情况下扩展性并不是很好，官方也没有很积极的去维护。甚至在 6.0 上将这个框架给废弃。</p>\n<p>相反 HttpUrlConnection 就是一个十分轻量的框架，使用上虽然麻烦一点，扩展性很强。但是在 API9 以前这个框架的 bug 很多，表现不稳定。因此在 API9 以前 Volley 是使用的 HttpClient。</p>\n<p>在 API9 以后，HttpUrlConnection 修复了许多 bug，并且支持响应压缩 gzip，甚至在 4.0 上提供了缓存机制。因此在 API9 以上 Volley 是使用的 HttpUrlConnection</p>\n<h4 id=\"RequestQueue-构造方法\"><a href=\"#RequestQueue-构造方法\" class=\"headerlink\" title=\"RequestQueue 构造方法\"></a>RequestQueue 构造方法</h4><p>RequestQueue  创建的时候初始化了几个变量。可以看到默认的网络线程数是四个，而 mDisPatchers 则是一个长度为线程数的数组，而默认的 ExecutorDelivery 是传入了一个主线程的 Handler 。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DEFAULT_NETWORK_THREAD_POOL_SIZE = <span class=\"number\">4</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">RequestQueue</span><span class=\"params\">(Cache cache, Network network)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>(cache, network, DEFAULT_NETWORK_THREAD_POOL_SIZE);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">RequestQueue</span><span class=\"params\">(Cache cache, Network network, <span class=\"keyword\">int</span> threadPoolSize)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>(cache, network, threadPoolSize,</div><div class=\"line\">                <span class=\"keyword\">new</span> ExecutorDelivery(<span class=\"keyword\">new</span> Handler(Looper.getMainLooper())));</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">RequestQueue</span><span class=\"params\">(Cache cache, Network network, <span class=\"keyword\">int</span> threadPoolSize,</span></span></div><div class=\"line\">            ResponseDelivery delivery) &#123;</div><div class=\"line\">        mCache = cache;<span class=\"comment\">// 缓存</span></div><div class=\"line\">        mNetwork = network; <span class=\"comment\">// 网络</span></div><div class=\"line\">        mDispatchers = <span class=\"keyword\">new</span> NetworkDispatcher[threadPoolSize]; <span class=\"comment\">// 调度器</span></div><div class=\"line\">        mDelivery = delivery; <span class=\"comment\">// 分发 response</span></div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>构造方法中看不出什么特别的端倪，接着看 start() 方法</p>\n<h4 id=\"start\"><a href=\"#start\" class=\"headerlink\" title=\"start()\"></a>start()</h4><p>在 start() 方法里面首先确保将所有的调度器都被停止了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">start</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    stop();  <span class=\"comment\">// Make sure any currently running dispatchers are stopped.</span></div><div class=\"line\">    <span class=\"comment\">// Create the cache dispatcher and start it.</span></div><div class=\"line\">  \t<span class=\"comment\">// 创建一个缓存调度器</span></div><div class=\"line\">    mCacheDispatcher = <span class=\"keyword\">new</span> CacheDispatcher(mCacheQueue, mNetworkQueue, mCache, mDelivery);</div><div class=\"line\">  \t<span class=\"comment\">// 开始运行 </span></div><div class=\"line\">    mCacheDispatcher.start();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// Create network dispatchers (and corresponding threads) up to the pool size.</span></div><div class=\"line\">  <span class=\"comment\">// 遍历 创建 网络调度器，依次开启  </span></div><div class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; mDispatchers.length; i++) &#123;</div><div class=\"line\">        NetworkDispatcher networkDispatcher = <span class=\"keyword\">new</span> NetworkDispatcher(mNetworkQueue, mNetwork,</div><div class=\"line\">                mCache, mDelivery);</div><div class=\"line\">        mDispatchers[i] = networkDispatcher;</div><div class=\"line\">        networkDispatcher.start();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这段代码没多少东西，开启了一个缓存调度器，和四个（默认）网络调度器。还是没有什么头绪，先别急着去看调度器里面的代码，咱们先看看请求是如何加入到队列中去的。</p>\n<h3 id=\"请求入队\"><a href=\"#请求入队\" class=\"headerlink\" title=\"请求入队\"></a>请求入队</h3><p>这段代码比较长，代码用注释来分析。事实上作者的注释也写得十分详尽</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\">Request&lt;T&gt; <span class=\"title\">add</span><span class=\"params\">(Request&lt;T&gt; request)</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// Tag the request as belonging to this queue and add it to the set of current requests.</span></div><div class=\"line\">  \t<span class=\"comment\">// 将这个 request 的队列设置为该队列(在 request中后面需要调用队列中的方法)</span></div><div class=\"line\">    request.setRequestQueue(<span class=\"keyword\">this</span>);</div><div class=\"line\">  \t<span class=\"comment\">// 该集合中存放当前被处理过的请求</span></div><div class=\"line\">    <span class=\"keyword\">synchronized</span> (mCurrentRequests) &#123;</div><div class=\"line\">        mCurrentRequests.add(request);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// Process requests in the order they are added.</span></div><div class=\"line\">  \t<span class=\"comment\">// 给请求设置序列号</span></div><div class=\"line\">    request.setSequence(getSequenceNumber());</div><div class=\"line\">    request.addMarker(<span class=\"string\">\"add-to-queue\"</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// If the request is uncacheable, skip the cache queue and go straight to the network.</span></div><div class=\"line\">  \t<span class=\"comment\">// 如果这个请求不需要缓存，则直接加入到网络队列中</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (!request.shouldCache()) &#123;</div><div class=\"line\">        mNetworkQueue.add(request);</div><div class=\"line\">        <span class=\"keyword\">return</span> request;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// Insert request into stage if there's already a request with the same cache key in flight.</span></div><div class=\"line\">  \t<span class=\"comment\">// 走到这里说明请求需要被缓存</span></div><div class=\"line\">    <span class=\"keyword\">synchronized</span> (mWaitingRequests) &#123;</div><div class=\"line\">      \t<span class=\"comment\">// 获取到缓存的 key</span></div><div class=\"line\">        String cacheKey = request.getCacheKey();</div><div class=\"line\">      \t<span class=\"comment\">// 如果暂存集合中只要能找到这个 key，说明当前有一个相同的请求正在处理中</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (mWaitingRequests.containsKey(cacheKey)) &#123;</div><div class=\"line\">            <span class=\"comment\">// There is already a request in flight. Queue up.</span></div><div class=\"line\">          \t<span class=\"comment\">// 获取到暂存集合中这个 key 对应的请求队列(重复请求可能会有多个)</span></div><div class=\"line\">            Queue&lt;Request&lt;?&gt;&gt; stagedRequests = mWaitingRequests.get(cacheKey);</div><div class=\"line\">            <span class=\"comment\">// 集合中还没有相同请求则创建一个队列</span></div><div class=\"line\">          \t<span class=\"keyword\">if</span> (stagedRequests == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                stagedRequests = <span class=\"keyword\">new</span> LinkedList&lt;Request&lt;?&gt;&gt;();</div><div class=\"line\">            &#125;</div><div class=\"line\">          \t<span class=\"comment\">// 将这个请求放入到队列中</span></div><div class=\"line\">            stagedRequests.add(request);</div><div class=\"line\">          \t<span class=\"comment\">// 将这个队列放回到集合中</span></div><div class=\"line\">            mWaitingRequests.put(cacheKey, stagedRequests);</div><div class=\"line\">            <span class=\"keyword\">if</span> (VolleyLog.DEBUG) &#123;</div><div class=\"line\">                VolleyLog.v(<span class=\"string\">\"Request for cacheKey=%s is in flight, putting on hold.\"</span>, cacheKey);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"comment\">// 到这里就说明当前没有相同的请求在等待处理</span></div><div class=\"line\">          \t<span class=\"comment\">// 将 cacheKey 放入到暂存集合中来标记当前已经有一个请求在等待处理了</span></div><div class=\"line\">          \t<span class=\"comment\">// 只做标记，值为空</span></div><div class=\"line\">            mWaitingRequests.put(cacheKey, <span class=\"keyword\">null</span>);</div><div class=\"line\">            <span class=\"comment\">// 将请求放到缓存队列中去</span></div><div class=\"line\">          \tmCacheQueue.add(request);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> request;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>注意这几件事情</p>\n<ul>\n<li><strong>只要进入到了 add () 方法中的 Request 就表示被处理过的，都要放到 当前请求的集合中，这个集合中就是目前整个队列中存在的请求</strong></li>\n<li><strong>如果不需要缓存，则请求都应该请求网络，因此放到网络请求的队列中</strong></li>\n<li><strong>暂存集合中只要能找到相同的 key 则说明有相同的请求正在等待执行，即便通过 key 获取的值是空</strong></li>\n<li><strong>重复的请求需要待在暂存集合中，并不会马上被加入到队列中</strong></li>\n</ul>\n<p>来看看网络队列和缓存队列是什么鬼，发现两个都是<strong>优先阻塞队列</strong>，这个后面会讲到。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/** The cache triage queue. */</span></div><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> PriorityBlockingQueue&lt;Request&lt;?&gt;&gt; mCacheQueue =</div><div class=\"line\">    <span class=\"keyword\">new</span> PriorityBlockingQueue&lt;Request&lt;?&gt;&gt;();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/** The queue of requests that are actually going out to the network. */</span></div><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> PriorityBlockingQueue&lt;Request&lt;?&gt;&gt; mNetworkQueue =</div><div class=\"line\">    <span class=\"keyword\">new</span> PriorityBlockingQueue&lt;Request&lt;?&gt;&gt;();</div></pre></td></tr></table></figure>\n<p>到这里好像请求就添加完成了，那么请求是怎么被处理的呢？</p>\n<h3 id=\"CacheDispatcher-缓存调度\"><a href=\"#CacheDispatcher-缓存调度\" class=\"headerlink\" title=\"CacheDispatcher 缓存调度\"></a>CacheDispatcher 缓存调度</h3><p>如果有缓存的情况下，请求被加入到了缓存队列中，那就先来看看缓存调度器是怎么工作的。</p>\n<p>CacheDispatcher 继承自 Thread 类，复写了 run()  方法。先看看构造方法,在请求队列 start() 方法中把缓存队列，网络队列，缓存策略，以及发送器都传了进来。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">CacheDispatcher</span><span class=\"params\">(BlockingQueue&lt;Request&lt;?&gt;&gt; cacheQueue,BlockingQueue&lt;Request&lt;?&gt;&gt; networkQueue,Cache cache, ResponseDelivery delivery)</span> </span>&#123;</div><div class=\"line\">    mCacheQueue = cacheQueue;</div><div class=\"line\">    mNetworkQueue = networkQueue;</div><div class=\"line\">    mCache = cache;</div><div class=\"line\">    mDelivery = delivery;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>接下来就是 run() 方法，这段代码比较长，但是逻辑上十分清晰，作者的注释不得不说，写的真是非常详尽。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (DEBUG) VolleyLog.v(<span class=\"string\">\"start new dispatcher\"</span>);</div><div class=\"line\">    Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// Make a blocking call to initialize the cache.</span></div><div class=\"line\">  \t<span class=\"comment\">// 初始化缓存目录</span></div><div class=\"line\">    mCache.initialize();</div><div class=\"line\">\t<span class=\"comment\">// 进入一个死循环</span></div><div class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">            <span class=\"comment\">// Get a request from the cache triage queue, blocking until</span></div><div class=\"line\">            <span class=\"comment\">// at least one is available.</span></div><div class=\"line\">          \t<span class=\"comment\">// 从缓存队列中获取一个请求，该方法是阻塞式的，直到获取到请求</span></div><div class=\"line\">            <span class=\"keyword\">final</span> Request&lt;?&gt; request = mCacheQueue.take();</div><div class=\"line\">            request.addMarker(<span class=\"string\">\"cache-queue-take\"</span>);</div><div class=\"line\">            <span class=\"comment\">// If the request has been canceled, don't bother dispatching it.</span></div><div class=\"line\">          \t<span class=\"comment\">// 如果这个请求被取消了，别犹豫，干掉它～</span></div><div class=\"line\">          \t<span class=\"comment\">// 进入下一次循环</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (request.isCanceled()) &#123;</div><div class=\"line\">                request.finish(<span class=\"string\">\"cache-discard-canceled\"</span>);</div><div class=\"line\">                <span class=\"keyword\">continue</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\">// Attempt to retrieve this item from cache.</span></div><div class=\"line\">          \t<span class=\"comment\">// 通过 mCache 去获取该请求在磁盘上的缓存</span></div><div class=\"line\">            Cache.Entry entry = mCache.get(request.getCacheKey());</div><div class=\"line\">          \t<span class=\"comment\">// 如果获取缓存失败 －－ miss，则将这个 request 加入到网络队列中</span></div><div class=\"line\">          \t<span class=\"comment\">// 进入下一次循环</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (entry == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                request.addMarker(<span class=\"string\">\"cache-miss\"</span>);</div><div class=\"line\">                <span class=\"comment\">// Cache miss; send off to the network dispatcher.</span></div><div class=\"line\">                mNetworkQueue.put(request);</div><div class=\"line\">                <span class=\"keyword\">continue</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">\t</div><div class=\"line\">            <span class=\"comment\">// If it is completely expired, just send it to the network.</span></div><div class=\"line\">          \t<span class=\"comment\">// 到这里说明获取到了缓存，检查缓存是否过期，失效了</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (entry.isExpired()) &#123;</div><div class=\"line\">                request.addMarker(<span class=\"string\">\"cache-hit-expired\"</span>);</div><div class=\"line\">                request.setCacheEntry(entry);</div><div class=\"line\">              \t<span class=\"comment\">// 缓存过期了，还是要请求网络</span></div><div class=\"line\">                mNetworkQueue.put(request);</div><div class=\"line\">                <span class=\"keyword\">continue</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\">// We have a cache hit; parse its data for delivery back to the request.\t</span></div><div class=\"line\">            request.addMarker(<span class=\"string\">\"cache-hit\"</span>);</div><div class=\"line\">          \t<span class=\"comment\">// 到这儿说明拿到了缓存，并且没有过期，解析 response</span></div><div class=\"line\">            Response&lt;?&gt; response = request.parseNetworkResponse(</div><div class=\"line\">                    <span class=\"keyword\">new</span> NetworkResponse(entry.data, entry.responseHeaders));</div><div class=\"line\">            request.addMarker(<span class=\"string\">\"cache-hit-parsed\"</span>);</div><div class=\"line\">\t\t\t</div><div class=\"line\">          \t<span class=\"comment\">// 需要判断一下，如果缓存不需要刷新，发送响应即可</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (!entry.refreshNeeded()) &#123;</div><div class=\"line\">                <span class=\"comment\">// Completely unexpired cache hit. Just deliver the response.</span></div><div class=\"line\">                mDelivery.postResponse(request, response);</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                <span class=\"comment\">// Soft-expired cache hit. We can deliver the cached response,</span></div><div class=\"line\">                <span class=\"comment\">// but we need to also send the request to the network for</span></div><div class=\"line\">                <span class=\"comment\">// refreshing.</span></div><div class=\"line\">              \t<span class=\"comment\">// 这里的逻辑是缓存没有过期，但是缓存需要更新了</span></div><div class=\"line\">              \t<span class=\"comment\">// 1.拿到的缓存依然需要直接分发出去</span></div><div class=\"line\">              \t<span class=\"comment\">// 2.同时将这个请求扔到网络队列中去获取新的数据</span></div><div class=\"line\">                request.addMarker(<span class=\"string\">\"cache-hit-refresh-needed\"</span>);</div><div class=\"line\">                request.setCacheEntry(entry);</div><div class=\"line\"></div><div class=\"line\">                <span class=\"comment\">// Mark the response as intermediate.</span></div><div class=\"line\">                response.intermediate = <span class=\"keyword\">true</span>;</div><div class=\"line\"></div><div class=\"line\">                <span class=\"comment\">// Post the intermediate response back to the user and have</span></div><div class=\"line\">                <span class=\"comment\">// the delivery then forward the request along to the network.</span></div><div class=\"line\">                mDelivery.postResponse(request, response, <span class=\"keyword\">new</span> Runnable() &#123;</div><div class=\"line\">                    <span class=\"meta\">@Override</span></div><div class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">                        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                            mNetworkQueue.put(request);</div><div class=\"line\">                        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">                            <span class=\"comment\">// Not much we can do about this.</span></div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">            <span class=\"comment\">// We may have been interrupted because it was time to quit.</span></div><div class=\"line\">          \t<span class=\"comment\">// 退出</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (mQuit) &#123;</div><div class=\"line\">                <span class=\"keyword\">return</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">continue</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>总结一下缓存调度器的四种状态</p>\n<ul>\n<li>miss — 失败，请求网络</li>\n<li>expire — 过期，请求网络</li>\n<li>hit — 成功，分发数据</li>\n<li>needRefresh — 成功并需要更新，先分发数据，再请求网络</li>\n</ul>\n<h3 id=\"NetworkDispatcher-网络调度\"><a href=\"#NetworkDispatcher-网络调度\" class=\"headerlink\" title=\"NetworkDispatcher 网络调度\"></a>NetworkDispatcher 网络调度</h3><p>NetWorkDispatcher 同样继承自 Thread 类，重写了 run() 方法。因为在这里不需要关心缓存，所以构造方法中不需要传入缓存队列</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">NetworkDispatcher</span><span class=\"params\">(BlockingQueue&lt;Request&lt;?&gt;&gt; queue,Network network, Cache cache,ResponseDelivery delivery)</span> </span>&#123;</div><div class=\"line\">    mQueue = queue;</div><div class=\"line\">    mNetwork = network;</div><div class=\"line\">    mCache = cache;</div><div class=\"line\">    mDelivery = delivery;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>run() 里面的代码也比较长，不过逻辑上也很清晰，依然是一个死循环，不断地从网络队列中获取请求。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</div><div class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</div><div class=\"line\">      \t<span class=\"comment\">// 请求开始时间</span></div><div class=\"line\">        <span class=\"keyword\">long</span> startTimeMs = SystemClock.elapsedRealtime();</div><div class=\"line\">        Request&lt;?&gt; request;</div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">            <span class=\"comment\">// Take a request from the queue.</span></div><div class=\"line\">          \t<span class=\"comment\">// 从队列中获取一个请求，也是阻塞方法</span></div><div class=\"line\">            request = mQueue.take();</div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">            <span class=\"comment\">// We may have been interrupted because it was time to quit.</span></div><div class=\"line\">          \t<span class=\"comment\">// 这个过程中可能线程被打断，说明应该退出</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (mQuit) &#123;</div><div class=\"line\">                <span class=\"keyword\">return</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">          \t<span class=\"comment\">// 进入下一次循环</span></div><div class=\"line\">            <span class=\"keyword\">continue</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">            request.addMarker(<span class=\"string\">\"network-queue-take\"</span>);</div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\">// If the request was cancelled already, do not perform the</span></div><div class=\"line\">            <span class=\"comment\">// network request.</span></div><div class=\"line\">          \t<span class=\"comment\">// 如果这个请求被取消了，同样，不要请求网络，干掉它</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (request.isCanceled()) &#123;</div><div class=\"line\">                request.finish(<span class=\"string\">\"network-discard-cancelled\"</span>);</div><div class=\"line\">                <span class=\"keyword\">continue</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            addTrafficStatsTag(request);</div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\">// Perform the network request.</span></div><div class=\"line\">          \t<span class=\"comment\">// 这里是请求网络，获取到 networkResponse</span></div><div class=\"line\">            NetworkResponse networkResponse = mNetwork.performRequest(request);</div><div class=\"line\">            request.addMarker(<span class=\"string\">\"network-http-complete\"</span>);</div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\">// If the server returned 304 AND we delivered a response already,</span></div><div class=\"line\">            <span class=\"comment\">// we're done -- don't deliver a second identical response.</span></div><div class=\"line\">          \t<span class=\"comment\">// 如果服务器返回了304 并且数据已经发送过一次了，不要再发送第二次，干掉</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (networkResponse.notModified &amp;&amp; request.hasHadResponseDelivered()) &#123;</div><div class=\"line\">                request.finish(<span class=\"string\">\"not-modified\"</span>);</div><div class=\"line\">                <span class=\"keyword\">continue</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\">// Parse the response here on the worker thread.</span></div><div class=\"line\">          \t<span class=\"comment\">// 解析response</span></div><div class=\"line\">            Response&lt;?&gt; response = request.parseNetworkResponse(networkResponse);</div><div class=\"line\">            request.addMarker(<span class=\"string\">\"network-parse-complete\"</span>);</div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\">// Write to cache if applicable.</span></div><div class=\"line\">            <span class=\"comment\">// <span class=\"doctag\">TODO:</span> Only update cache metadata instead of entire record for 304s.</span></div><div class=\"line\">          \t<span class=\"comment\">// 需要缓存，将请求返回的数据存到磁盘上</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (request.shouldCache() &amp;&amp; response.cacheEntry != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                mCache.put(request.getCacheKey(), response.cacheEntry);</div><div class=\"line\">                request.addMarker(<span class=\"string\">\"network-cache-written\"</span>);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\">// Post the response back.</span></div><div class=\"line\">          \t<span class=\"comment\">// 标记</span></div><div class=\"line\">            request.markDelivered();</div><div class=\"line\">          \t<span class=\"comment\">// 分发数据</span></div><div class=\"line\">            mDelivery.postResponse(request, response);</div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (VolleyError volleyError) &#123;</div><div class=\"line\">            volleyError.setNetworkTimeMs(SystemClock.elapsedRealtime() - startTimeMs);</div><div class=\"line\">          \t<span class=\"comment\">// 发送错误</span></div><div class=\"line\">            parseAndDeliverNetworkError(request, volleyError);</div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\">            VolleyLog.e(e, <span class=\"string\">\"Unhandled exception %s\"</span>, e.toString());</div><div class=\"line\">            VolleyError volleyError = <span class=\"keyword\">new</span> VolleyError(e);</div><div class=\"line\">            volleyError.setNetworkTimeMs(SystemClock.elapsedRealtime() - startTimeMs);</div><div class=\"line\">          \t<span class=\"comment\">// 发送错误</span></div><div class=\"line\">            mDelivery.postError(request, volleyError);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"分发响应数据\"><a href=\"#分发响应数据\" class=\"headerlink\" title=\"分发响应数据\"></a>分发响应数据</h3><p>请求处理完了，返回的数据应该怎么返回呢？在上面的代码中通过这个方法 mDelivery.postResponse(request, response)  来发送数据</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">postResponse</span><span class=\"params\">(Request&lt;?&gt; request, Response&lt;?&gt; response)</span> </span>&#123;</div><div class=\"line\">    postResponse(request, response, <span class=\"keyword\">null</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">postResponse</span><span class=\"params\">(Request&lt;?&gt; request, Response&lt;?&gt; response, Runnable runnable)</span> </span>&#123;</div><div class=\"line\">    request.markDelivered();</div><div class=\"line\">    request.addMarker(<span class=\"string\">\"post-response\"</span>);</div><div class=\"line\">    mResponsePoster.execute(<span class=\"keyword\">new</span> ResponseDeliveryRunnable(request, response, runnable));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>还记得之前构造请求队列的时候初始化了这货，handler 是跟主线程 looper 绑定的</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ExecutorDelivery</span><span class=\"params\">(<span class=\"keyword\">final</span> Handler handler)</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// Make an Executor that just wraps the handler.</span></div><div class=\"line\">    mResponsePoster = <span class=\"keyword\">new</span> Executor() &#123;</div><div class=\"line\">        <span class=\"meta\">@Override</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(Runnable command)</span> </span>&#123;</div><div class=\"line\">            handler.post(command);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里的 command 就是上面代码中的 ResponseDeliveryRunnable ，点进去瞧一眼实现了 Runnable 接口，到这里还判断了一次是否被取消了。这段代码没什么好说的</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">     <span class=\"comment\">// If this request has canceled, finish it and don't deliver.</span></div><div class=\"line\">     <span class=\"keyword\">if</span> (mRequest.isCanceled()) &#123;</div><div class=\"line\">         mRequest.finish(<span class=\"string\">\"canceled-at-delivery\"</span>);</div><div class=\"line\">         <span class=\"keyword\">return</span>;</div><div class=\"line\">     &#125;</div><div class=\"line\"></div><div class=\"line\">     <span class=\"comment\">// Deliver a normal response or error, depending.</span></div><div class=\"line\">     <span class=\"keyword\">if</span> (mResponse.isSuccess()) &#123;</div><div class=\"line\">         mRequest.deliverResponse(mResponse.result);</div><div class=\"line\">     &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">         mRequest.deliverError(mResponse.error);</div><div class=\"line\">     &#125;</div><div class=\"line\"></div><div class=\"line\">     <span class=\"comment\">// If this is an intermediate response, add a marker, otherwise we're done</span></div><div class=\"line\">     <span class=\"comment\">// and the request can be finished.</span></div><div class=\"line\">     <span class=\"keyword\">if</span> (mResponse.intermediate) &#123;</div><div class=\"line\">         mRequest.addMarker(<span class=\"string\">\"intermediate-response\"</span>);</div><div class=\"line\">     &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">         mRequest.finish(<span class=\"string\">\"done\"</span>);</div><div class=\"line\">     &#125;</div><div class=\"line\"></div><div class=\"line\">     <span class=\"comment\">// If we have been provided a post-delivery runnable, run it.</span></div><div class=\"line\">     <span class=\"keyword\">if</span> (mRunnable != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">         mRunnable.run();</div><div class=\"line\">     &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>mRequest.deliverResponse(mResponse.result)，这是 Request 中的一个抽象方法，在子类中被实现，挑一个 JsonReqeust 实现的随意感受下，是不是就明白了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">deliverResponse</span><span class=\"params\">(T response)</span> </span>&#123;</div><div class=\"line\">    mListener.onResponse(response);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"请求完成及取消\"><a href=\"#请求完成及取消\" class=\"headerlink\" title=\"请求完成及取消\"></a>请求完成及取消</h3><p>数据是分发完了，别忘了请求还在各种乱七八糟的集合里面，得处理一下。先来看 request.finish() 方法,下面的代码只贴了核心代码，另外一部分跟 log 相关的没有贴出</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">finish</span><span class=\"params\">(<span class=\"keyword\">final</span> String tag)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (mRequestQueue != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        mRequestQueue.finish(<span class=\"keyword\">this</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>调用的是请求队列里的 finish()</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;T&gt; <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">finish</span><span class=\"params\">(Request&lt;T&gt; request)</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// Remove from the set of requests currently being processed.</span></div><div class=\"line\">\t<span class=\"comment\">// 首先从现有的请求集合中移除掉该请求</span></div><div class=\"line\">    <span class=\"keyword\">synchronized</span> (mCurrentRequests) &#123;</div><div class=\"line\">        mCurrentRequests.remove(request);</div><div class=\"line\">    &#125;</div><div class=\"line\">  \t<span class=\"comment\">// 回调监听</span></div><div class=\"line\">    <span class=\"keyword\">synchronized</span> (mFinishedListeners) &#123;</div><div class=\"line\">      <span class=\"keyword\">for</span> (RequestFinishedListener&lt;T&gt; listener : mFinishedListeners) &#123;</div><div class=\"line\">        listener.onRequestFinished(request);</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">\t<span class=\"comment\">// 如果这个请求有缓存</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (request.shouldCache()) &#123;</div><div class=\"line\">        <span class=\"keyword\">synchronized</span> (mWaitingRequests) &#123;</div><div class=\"line\">          \t<span class=\"comment\">// 从暂存集合中，把重复的请求都取出来</span></div><div class=\"line\">            String cacheKey = request.getCacheKey();</div><div class=\"line\">            Queue&lt;Request&lt;?&gt;&gt; waitingRequests = mWaitingRequests.remove(cacheKey);</div><div class=\"line\">            <span class=\"keyword\">if</span> (waitingRequests != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                <span class=\"keyword\">if</span> (VolleyLog.DEBUG) &#123;</div><div class=\"line\">                    VolleyLog.v(<span class=\"string\">\"Releasing %d waiting requests for cacheKey=%s.\"</span>,</div><div class=\"line\">                            waitingRequests.size(), cacheKey);</div><div class=\"line\">                &#125;</div><div class=\"line\">                <span class=\"comment\">// Process all queued up requests. They won't be considered as in flight, but</span></div><div class=\"line\">                <span class=\"comment\">// that's not a problem as the cache has been primed by 'request'.</span></div><div class=\"line\">              <span class=\"comment\">// 全部加入到缓存队列中去  </span></div><div class=\"line\">              mCacheQueue.addAll(waitingRequests);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>finish() 干了三件事情</p>\n<ul>\n<li>把这个请求从现有集合中移除掉，因为已经结束了</li>\n<li>回调所有的监听</li>\n<li>把暂存集合中的重复请求加入到缓存队列中</li>\n</ul>\n<p>如果是取消呢？cancelAll 里面是怎么处理的，下面这个是我们常用的方法，传入一个tag，取消所有该tag的请求</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">cancelAll</span><span class=\"params\">(<span class=\"keyword\">final</span> Object tag)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (tag == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Cannot cancelAll with a null tag\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    cancelAll(<span class=\"keyword\">new</span> RequestFilter() &#123;</div><div class=\"line\">        <span class=\"meta\">@Override</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">apply</span><span class=\"params\">(Request&lt;?&gt; request)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> request.getTag() == tag;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>创建一个 RequestFilter 过滤器，条件是 request 的 tag 与传入 tag 相同，然后依次调用 cancel()，还记得前面多处地方判断当前请求是否被 cancel ，是就直接调用 finish。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">cancelAll</span><span class=\"params\">(RequestFilter filter)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">synchronized</span> (mCurrentRequests) &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (Request&lt;?&gt; request : mCurrentRequests) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (filter.apply(request)) &#123;</div><div class=\"line\">                request.cancel();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"优先级\"><a href=\"#优先级\" class=\"headerlink\" title=\"优先级\"></a>优先级</h3><p>我们知道如果要给一个请求设置优先级，需要重写一个方法 getPriority，默认返回的是 NORMAL ,</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Priority <span class=\"title\">getPriority</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> Priority.NORMAL;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> Priority &#123;</div><div class=\"line\">        LOW,</div><div class=\"line\">        NORMAL,</div><div class=\"line\">        HIGH,</div><div class=\"line\">        IMMEDIATE</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>那入队的时候是怎么判断优先级的呢？Volley 好像也没有处理啊。</p>\n<p>Volley 确实没有处理，还记得一开头介绍两个队列的时候提了一嘴，<strong>优先阻塞队列 — PriorityBlockingQueue</strong>，这个类实现了 BlockingQueue 接口，首先是一个阻塞队列</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">add</span><span class=\"params\">(E e)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> offer(e);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">offer</span><span class=\"params\">(E e)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (e == <span class=\"keyword\">null</span>)</div><div class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</div><div class=\"line\">        <span class=\"keyword\">final</span> ReentrantLock lock = <span class=\"keyword\">this</span>.lock;</div><div class=\"line\">        lock.lock();</div><div class=\"line\">        <span class=\"keyword\">int</span> n, cap;</div><div class=\"line\">        Object[] array;</div><div class=\"line\">        <span class=\"keyword\">while</span> ((n = size) &gt;= (cap = (array = queue).length))</div><div class=\"line\">            tryGrow(array, cap);</div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">            Comparator&lt;? <span class=\"keyword\">super</span> E&gt; cmp = comparator;</div><div class=\"line\">          \t<span class=\"comment\">// 判断是否有对比器</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (cmp == <span class=\"keyword\">null</span>)</div><div class=\"line\">              \t<span class=\"comment\">// 没有设置对比器，直接对比 comparable</span></div><div class=\"line\">                siftUpComparable(n, e, array);</div><div class=\"line\">            <span class=\"keyword\">else</span></div><div class=\"line\">              \t<span class=\"comment\">// 利用对比器对比</span></div><div class=\"line\">                siftUpUsingComparator(n, e, array, cmp);</div><div class=\"line\">            size = n + <span class=\"number\">1</span>;</div><div class=\"line\">            notEmpty.signal();</div><div class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">            lock.unlock();</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>如果没有传入对比器，那么被存储的对象应该实现了  Comparable 接口，在这个方法里面会根据 compareTo 方法来比对两个元素的大小，决定放在队列的哪个位置</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">siftUpComparable</span><span class=\"params\">(<span class=\"keyword\">int</span> k, T x, Object[] array)</span> </span>&#123;</div><div class=\"line\">    Comparable&lt;? <span class=\"keyword\">super</span> T&gt; key = (Comparable&lt;? <span class=\"keyword\">super</span> T&gt;) x;</div><div class=\"line\">    <span class=\"keyword\">while</span> (k &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> parent = (k - <span class=\"number\">1</span>) &gt;&gt;&gt; <span class=\"number\">1</span>;</div><div class=\"line\">        Object e = array[parent];</div><div class=\"line\">        <span class=\"keyword\">if</span> (key.compareTo((T) e) &gt;= <span class=\"number\">0</span>)</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        array[k] = e;</div><div class=\"line\">        k = parent;</div><div class=\"line\">    &#125;</div><div class=\"line\">    array[k] = key;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Request 正是实现了 Comparable 接口，并且按照优先级重写了 compareTo 方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compareTo</span><span class=\"params\">(Request&lt;T&gt; other)</span> </span>&#123;</div><div class=\"line\">    Priority left = <span class=\"keyword\">this</span>.getPriority();</div><div class=\"line\">    Priority right = other.getPriority();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// High-priority requests are \"lesser\" so they are sorted to the front.</span></div><div class=\"line\">    <span class=\"comment\">// Equal priorities are sorted by sequence number to provide FIFO ordering.</span></div><div class=\"line\">    <span class=\"keyword\">return</span> left == right ?</div><div class=\"line\">            <span class=\"keyword\">this</span>.mSequence - other.mSequence :</div><div class=\"line\">            right.ordinal() - left.ordinal();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"NetWork-网络传输\"><a href=\"#NetWork-网络传输\" class=\"headerlink\" title=\"NetWork 网络传输\"></a>NetWork 网络传输</h3><p>Volley 默认是使用 BasicNetWork(HttpStack) 来做网络传输，重写了 performRequest 这个方法，在这个方法里面调用 HttpStack 的 performRequest 方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">httpResponse = mHttpStack.performRequest(request, headers);</div></pre></td></tr></table></figure>\n<p>贴出了 HurlStack 的代码，可以看到实际上就是使用的 HttpUrlConnection, 而且我猜  Hurl 是简称吧～</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> HttpResponse <span class=\"title\">performRequest</span><span class=\"params\">(Request&lt;?&gt; request, Map&lt;String, String&gt; additionalHeaders)</span></span></div><div class=\"line\">        <span class=\"keyword\">throws</span> IOException, AuthFailureError &#123;</div><div class=\"line\">    String url = request.getUrl();</div><div class=\"line\">    HashMap&lt;String, String&gt; map = <span class=\"keyword\">new</span> HashMap&lt;String, String&gt;();</div><div class=\"line\">    map.putAll(request.getHeaders());</div><div class=\"line\">    map.putAll(additionalHeaders);</div><div class=\"line\">    <span class=\"keyword\">if</span> (mUrlRewriter != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        String rewritten = mUrlRewriter.rewriteUrl(url);</div><div class=\"line\">        <span class=\"keyword\">if</span> (rewritten == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IOException(<span class=\"string\">\"URL blocked by rewriter: \"</span> + url);</div><div class=\"line\">        &#125;</div><div class=\"line\">        url = rewritten;</div><div class=\"line\">    &#125;</div><div class=\"line\">    URL parsedUrl = <span class=\"keyword\">new</span> URL(url);</div><div class=\"line\">    HttpURLConnection connection = openConnection(parsedUrl, request);</div><div class=\"line\">    <span class=\"keyword\">for</span> (String headerName : map.keySet()) &#123;</div><div class=\"line\">        connection.addRequestProperty(headerName, map.get(headerName));</div><div class=\"line\">    &#125;</div><div class=\"line\">    setConnectionParametersForRequest(connection, request);</div><div class=\"line\">    <span class=\"comment\">// Initialize HttpResponse with data from the HttpURLConnection.</span></div><div class=\"line\">    ProtocolVersion protocolVersion = <span class=\"keyword\">new</span> ProtocolVersion(<span class=\"string\">\"HTTP\"</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>);</div><div class=\"line\">    <span class=\"keyword\">int</span> responseCode = connection.getResponseCode();</div><div class=\"line\">    <span class=\"keyword\">if</span> (responseCode == -<span class=\"number\">1</span>) &#123;</div><div class=\"line\">        <span class=\"comment\">// -1 is returned by getResponseCode() if the response code could not be retrieved.</span></div><div class=\"line\">        <span class=\"comment\">// Signal to the caller that something was wrong with the connection.</span></div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IOException(<span class=\"string\">\"Could not retrieve response code from HttpUrlConnection.\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    StatusLine responseStatus = <span class=\"keyword\">new</span> BasicStatusLine(protocolVersion,</div><div class=\"line\">            connection.getResponseCode(), connection.getResponseMessage());</div><div class=\"line\">    BasicHttpResponse response = <span class=\"keyword\">new</span> BasicHttpResponse(responseStatus);</div><div class=\"line\">    <span class=\"keyword\">if</span> (hasResponseBody(request.getMethod(), responseStatus.getStatusCode())) &#123;</div><div class=\"line\">        response.setEntity(entityFromConnection(connection));</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">for</span> (Entry&lt;String, List&lt;String&gt;&gt; header : connection.getHeaderFields().entrySet()) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (header.getKey() != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            Header h = <span class=\"keyword\">new</span> BasicHeader(header.getKey(), header.getValue().get(<span class=\"number\">0</span>));</div><div class=\"line\">            response.addHeader(h);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> response;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这一节没什么可讲的，其实就是说明 Volley 其实理解为一个调度器可能更贴近于它的功能，如果你需要完全可以把网络传输进行自定义，把线程调度交给 Volley，这也是它灵活强大的地方。</p>\n<h3 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h3><p>通过这么久的源码学习，我发现看源码是消除误区和误解的最佳办法。并且能学习到大牛的编码风格，设计思路等等。</p>\n<p>下一篇学习笔记中，我将分析 Volley 中的 ImageLoader 以及 LruCache 这个两个类，看看在 Android 处理图片的相关技术。</p>\n","categories":["Android源码学习"],"tags":[]},{"title":"AsyncTask源码学习笔记","url":"https://joesteven.github.io/asynctask_source/","content":"<p>转载请附原文链接： <a href=\"http://extremej.itscoder.com/asynctask_source/\" target=\"_blank\" rel=\"external\">AsyncTask 源码学习笔记</a></p>\n<p>上一篇笔记分析了线程池的源码  <a href=\"http://extremej.itscoder.com/threadpoolexecutor_source/\" target=\"_blank\" rel=\"external\">ThreadPoolExecutor源码学习笔记</a></p>\n<p>作为 Android 开发者不得不说说 Android 中的系统级异步框架 — AysncTask</p>\n<p>几乎大部分 Android 开发者都用过AysncTask。这是一个专注于其他线程与 UI 线程通信的一个框架。官方的介绍：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">AsyncTask enables proper and easy use of the UI thread. This class allows to</div><div class=\"line\">perform background operations and publish results on the UI thread without</div><div class=\"line\">having to manipulate threads and/or handlers.</div></pre></td></tr></table></figure>\n<p>本篇笔记依然会按照我的一贯风格从使用作为主线，捋一捋 AysncTask 的逻辑流程。</p>\n<p>主要涉及到的类有（不包含内部类）：</p>\n<ul>\n<li>AsyncTask</li>\n<li>Futuretask</li>\n</ul>\n<h3 id=\"AsyncTask使用\"><a href=\"#AsyncTask使用\" class=\"headerlink\" title=\"AsyncTask使用\"></a>AsyncTask使用</h3><p>AsyncTask 是一个抽象类，在使用的时候需要继承这个类。</p>\n<ul>\n<li>doInBackground — 必须实现，异步代码在这里面执行</li>\n<li>onPostExecute(Result) — 在 UI 线程回调，传递数据</li>\n<li>onProgressUpdate(Progress) — 任务执行时回调当前进度</li>\n</ul>\n<p>以上是经常被重写的方法，AsyncTask 中其实在整个任务执行周期都有相应方法</p>\n<ul>\n<li>onPreExecute — 执行前准备工作</li>\n<li>onCancelled — 任务取消</li>\n</ul>\n<p>AsyncTask 指定三个泛型，分别是异步任务所需要的参数，进度，和结果。通过 execute() 方法开始执行任务。</p>\n<h3 id=\"AsyncTask-的几种状态\"><a href=\"#AsyncTask-的几种状态\" class=\"headerlink\" title=\"AsyncTask 的几种状态\"></a>AsyncTask 的几种状态</h3><p>AsyncTask 有一个内部类，用于标记当前状态</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> Status &#123;</div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\">     * Indicates that the task has not been executed yet.</div><div class=\"line\">     */</div><div class=\"line\">    PENDING,<span class=\"comment\">//当前任务等待中</span></div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\">     * Indicates that the task is running.</div><div class=\"line\">     */</div><div class=\"line\">    RUNNING,<span class=\"comment\">//当前任务执行中</span></div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\">     * Indicates that &#123;<span class=\"doctag\">@link</span> AsyncTask#onPostExecute&#125; has finished.</div><div class=\"line\">     */</div><div class=\"line\">    FINISHED,<span class=\"comment\">//执行完毕</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"创建\"><a href=\"#创建\" class=\"headerlink\" title=\"创建\"></a>创建</h3><p>十分简单的介绍了一下使用，准备进入源码的世界吧。按照一贯风格，先来看看 AsyncTask 在被创建的时候发生了什么事。首先来看几个比较重要的静态成员变量（常量）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// cpu核数</span></div><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> CPU_COUNT = Runtime.getRuntime().availableProcessors();</div><div class=\"line\"><span class=\"comment\">// 核心线程数 ＝ cpu核数＋1</span></div><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> CORE_POOL_SIZE = CPU_COUNT + <span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"comment\">// 最大线程数 ＝ cpu核数＊2 ＋1</span></div><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MAXIMUM_POOL_SIZE = CPU_COUNT * <span class=\"number\">2</span> + <span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"comment\">// 线程闲置超时时间 1s</span></div><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> KEEP_ALIVE = <span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"comment\">//当前状态为等待</span></div><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> Status mStatus = Status.PENDING;</div><div class=\"line\"><span class=\"comment\">// 任务队列</span></div><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> BlockingQueue&lt;Runnable&gt; sPoolWorkQueue =</div><div class=\"line\">            <span class=\"keyword\">new</span> LinkedBlockingQueue&lt;Runnable&gt;(<span class=\"number\">128</span>);</div><div class=\"line\"><span class=\"comment\">// 创建一个线程池</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Executor THREAD_POOL_EXECUTOR</div><div class=\"line\">            = <span class=\"keyword\">new</span> ThreadPoolExecutor(CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE,</div><div class=\"line\">                    TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory);</div></pre></td></tr></table></figure>\n<p>可以看到创建了一个线程池，指定了核心线程数，最大线程数，任务队列等等。到这儿应该要理解一件事情</p>\n<ul>\n<li><strong>这里的线程池是一个全局静态，也就是所有的AsyncTask使用的其实是同一个线程池</strong></li>\n<li><strong>AsyncTask 应该理解为一个单一的异步任务，本身并不维护线程池，事实上因为 execute() 方法的重载，严格来说应该理解为是一个异步任务队列的调度器</strong></li>\n</ul>\n<p>这里提一个内容外的问题，为什么核心线程数是 cpu 核数＋1，而不是 cpu 核数？或者＋2，＋3等等。很惭愧，半路出家，对于这种问题我也没有特别好的理解，这里简单提一下线程数的设计吧</p>\n<h4 id=\"线程数与-CPU-核数的关系\"><a href=\"#线程数与-CPU-核数的关系\" class=\"headerlink\" title=\"线程数与 CPU 核数的关系\"></a>线程数与 CPU 核数的关系</h4><p>cpu 的核数代表了同一时间能够同时运行的线程数，比如双核的 cpu 在同一个时间内是可以运行两个线程的，对于程序而言，如果 cpu 是多核的，而我们还在使用单线程编程，那么就有其他几个 cpu 是空闲的，这样对于资源是极大的浪费。</p>\n<p>但如果线程数特别的多远超出 cpu 的核数，也会导致线程切换带来较大的开销，一样是不合理的。因此线程数的设计应该考虑在完全利用 cpu 资源的情况下减少线程的切换 。需要注意的是<strong>并不是所有的线程都是占用 CPU 资源的</strong>,这里就要讲到两个概念</p>\n<ul>\n<li>CPU密集型 — 在程序中有大量处理逻辑运算的需求，这样的操作是需要占用 CPU 资源的</li>\n<li>IO密集型 — 有大量的 IO 操作，这样的操作是不需要占用 CPU 资源的</li>\n</ul>\n<p>假设有一个四核的 CPU ，我们创建四个线程，其中有三个线程在执行运算工作，还有一个在做 IO 操作，这个时候 CPU 有一个其实是空闲的，也就是浪费了 CPU 的资源。我忘了是在哪儿看到过一句话，即便是 CPU再密集,也会有那么一点 IO 操作，所以对应设计一个 IO 线程是很有必要的。</p>\n<p>另外线程除了执行时间，还有等待时间，在等待时间里面，CPU 其实也是处于空闲状态的。有一个公式来设计线程数</p>\n<blockquote>\n<p>线程数 ＝ ()(任务执行时间＋等待时间)／任务执行时间)＊cpu核数</p>\n</blockquote>\n<p>因为 AsyncTask 核心线程是需要长时间运行不会被回收，因此减少线程的切换开销，将数量设计为核数＋1，也就不难理解了。而最大线程数可以根据上面的公式算出一个理论的最大值。</p>\n<h4 id=\"AsyncTask-的一个坑\"><a href=\"#AsyncTask-的一个坑\" class=\"headerlink\" title=\"AsyncTask 的一个坑\"></a>AsyncTask 的一个坑</h4><p>我在上一篇文章 <a href=\"http://extremej.itscoder.com/threadpoolexecutor_source/#异常处理\" target=\"_blank\" rel=\"external\">ThreadPoolExecutor源码学习笔记</a> 中在讲 AbortPolicy 的时候说过，在 AysncTask 中引发了血崩，现在来看看是为什么。</p>\n<p>在初始化的源码中可以看到，任务队列的容量设计是128个，在 API19 以前的 AsyncTask 设计的是并行，同时会有5个线程在工作。假设现在有一个多任务需求，很容易就超过了128个，猜猜会发生什么？</p>\n<p>还记得在线程池中如果无法加入队列中的时候会调用 reject 方法，而这里创建的线程池并没有传入自己的 handler ，因此用的是默认的 handler — AbortPolicy ,这个类会直接抛一个运行时异常，于是就这样华丽丽的崩溃了。因此在之后修改了 AsyncTask 的策略，默认为串行，只有一个线程在运行，一次执行一个任务，具体实现在后面的源码中来看。</p>\n<h4 id=\"构造方法\"><a href=\"#构造方法\" class=\"headerlink\" title=\"构造方法\"></a>构造方法</h4><p>前面说了许多题外话，现在才开始真正进入到源码中来～</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">AsyncTask</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    mWorker = <span class=\"keyword\">new</span> WorkerRunnable&lt;Params, Result&gt;() &#123;</div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> Result <span class=\"title\">call</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</div><div class=\"line\">            mTaskInvoked.set(<span class=\"keyword\">true</span>);</div><div class=\"line\"></div><div class=\"line\">            Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</div><div class=\"line\">            <span class=\"comment\">//noinspection unchecked</span></div><div class=\"line\">            Result result = doInBackground(mParams);</div><div class=\"line\">            Binder.flushPendingCommands();</div><div class=\"line\">            <span class=\"keyword\">return</span> postResult(result);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;;</div><div class=\"line\"></div><div class=\"line\">    mFuture = <span class=\"keyword\">new</span> FutureTask&lt;Result&gt;(mWorker) &#123;</div><div class=\"line\">        <span class=\"meta\">@Override</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">done</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                postResultIfNotInvoked(get());</div><div class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">                android.util.Log.w(LOG_TAG, e);</div><div class=\"line\">            &#125; <span class=\"keyword\">catch</span> (ExecutionException e) &#123;</div><div class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"An error occurred while executing doInBackground()\"</span>,</div><div class=\"line\">                        e.getCause());</div><div class=\"line\">            &#125; <span class=\"keyword\">catch</span> (CancellationException e) &#123;</div><div class=\"line\">                postResultIfNotInvoked(<span class=\"keyword\">null</span>);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面是 AsyncTask 的构造方法，看起来长长的代码，我一句注释也没写，因为现在看到的这段代码貌似没有任何的突破口，可以看到初始化了两个变量，mWorker 和 mFuture。注意这里的 Worker 就不是线程池里的那个啦～</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WorkerRunnable</span>&lt;<span class=\"title\">Params</span>, <span class=\"title\">Result</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Callable</span>&lt;<span class=\"title\">Result</span>&gt; </span>&#123;</div><div class=\"line\">    Params[] mParams;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>WorkerRunnanble 是一个抽像类实现了 Callable 接口，这个接口中只有一个方法 call 返回指定的泛型对象，知道这个就可以啦。</p>\n<p>创建的代码基本就告一段落了，后面我们还会回来～接下来看看任务的执行</p>\n<h3 id=\"任务执行\"><a href=\"#任务执行\" class=\"headerlink\" title=\"任务执行\"></a>任务执行</h3><p>执行任务最先想到的就是 execute() 方法，这个方法有一个重载，先来看最常用的这个，也就是传入可变参数，注意这个方法只能在主线程调用，原因很简单，文章一开头就说了这个框架是为了与 UI 线程通信的</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@MainThread</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> AsyncTask&lt;Params, Progress, Result&gt; <span class=\"title\">execute</span><span class=\"params\">(Params... params)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> executeOnExecutor(sDefaultExecutor, params);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>调用了 executeOnExecutor() 传入两个参数，第一从字面看是默认的任务执行器。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">volatile</span> Executor sDefaultExecutor = SERIAL_EXECUTOR;</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Executor SERIAL_EXECUTOR = <span class=\"keyword\">new</span> SerialExecutor();</div></pre></td></tr></table></figure>\n<p>SerialExecutor 是个什么鬼？这里打住，别着急点击去看，先把大体逻辑捋清楚，来看 executeOnExecutor()，这个方法同样也是需要在主线程中调用。代码稍微有点多，一句一句来看。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@MainThread</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> AsyncTask&lt;Params, Progress, Result&gt; <span class=\"title\">executeOnExecutor</span><span class=\"params\">(Executor exec,</span></span></div><div class=\"line\">        Params... params) &#123;</div><div class=\"line\">  <span class=\"comment\">// 前面提到过 AsyncTask 的状态，如果状态不是等待中，则根据状态的不同抛出不同的异常</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (mStatus != Status.PENDING) &#123;</div><div class=\"line\">        <span class=\"keyword\">switch</span> (mStatus) &#123;</div><div class=\"line\">            <span class=\"keyword\">case</span> RUNNING:</div><div class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Cannot execute task:\"</span></div><div class=\"line\">                        + <span class=\"string\">\" the task is already running.\"</span>);</div><div class=\"line\">            <span class=\"keyword\">case</span> FINISHED:</div><div class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Cannot execute task:\"</span></div><div class=\"line\">                        + <span class=\"string\">\" the task has already been executed \"</span></div><div class=\"line\">                        + <span class=\"string\">\"(a task can be executed only once)\"</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  \t<span class=\"comment\">// 状态标记为执行中</span></div><div class=\"line\">    mStatus = Status.RUNNING;</div><div class=\"line\">\t<span class=\"comment\">// 调用准备方法</span></div><div class=\"line\">    onPreExecute();</div><div class=\"line\">\t<span class=\"comment\">// 参数赋值给 mWorker</span></div><div class=\"line\">    mWorker.mParams = params;</div><div class=\"line\">  \t<span class=\"comment\">// 执行起开始执行，传入mFuture</span></div><div class=\"line\">    exec.execute(mFuture);</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>首先判断了当前的状态，只有处于等待中的时候才会向下执行，<strong>也就是说 execute(params) 这个方法只应该被调用一次</strong>, 为什么把参数赋值给 mWorker 的成员变量后执行器使用的是 mFuture 呢？</p>\n<p>还记得前面打住的那个地方，exec 就是 SerialExecutor，这会儿就可以看看它干了啥，做好心理准备，这段代码一开始我看的时候其实是拒绝的，对角懵逼。还是老方法，一句句来，先试试把逻辑理清。</p>\n<p>该类实现了 Executor 接口，重写 execute 方法。参数是一个 Runnable 对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SerialExecutor</span> <span class=\"keyword\">implements</span> <span class=\"title\">Executor</span> </span>&#123;</div><div class=\"line\">   \t<span class=\"comment\">// 任务队列</span></div><div class=\"line\">    <span class=\"keyword\">final</span> ArrayDeque&lt;Runnable&gt; mTasks = <span class=\"keyword\">new</span> ArrayDeque&lt;Runnable&gt;();</div><div class=\"line\">    <span class=\"comment\">// 当前正在执行run方法的Runnable任务</span></div><div class=\"line\">  \tRunnable mActive;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(<span class=\"keyword\">final</span> Runnable r)</span> </span>&#123;</div><div class=\"line\">      \t<span class=\"comment\">//拆开看，1.将一个Runnable对象插入到队列中去</span></div><div class=\"line\">      \t<span class=\"comment\">// 2.这个Runnanble对象重写了 run方法，调用了 r.run() </span></div><div class=\"line\">      \t<span class=\"comment\">// r 也就是从上一步中传入的 mFuture(按照上文的流程，实际按照传入的为准)</span></div><div class=\"line\">      \t<span class=\"comment\">// 3.最终执行 scheduleNext()方法</span></div><div class=\"line\">        mTasks.offer(<span class=\"keyword\">new</span> Runnable() &#123;</div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">                <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                    r.run();</div><div class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">                    scheduleNext();</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div><div class=\"line\">      <span class=\"comment\">// 判断如果当前正在执行的任务为空，调用scheduleNext方法</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (mActive == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            scheduleNext();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">scheduleNext</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">      <span class=\"comment\">// 1.mActivite 从mTasks里面取出第一个任务，如果不为空，交给线程池处理</span></div><div class=\"line\">        <span class=\"keyword\">if</span> ((mActive = mTasks.poll()) != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            THREAD_POOL_EXECUTOR.execute(mActive);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这段代码不是那么好懂，再来捋一下逻辑，在执行 execute 的时候，</p>\n<p><strong>1.首先将任务添加到了队列中，这个队列是执行器的队列，并不是线程池的队列</strong></p>\n<p><strong>2.接下来判断 mActive 是否为空，第一次执行时当然是空，就会执行 scheduleNext 方法</strong></p>\n<p><strong>3.从队列中拿出第一个任务，并赋值给 mActive，如果不为空则交给线程池进行处理</strong></p>\n<p><strong>4.当 mActive 所指向的这个 Runnable 执行完run方法，无论如何都会再次调用 scheduleNext 方法</strong></p>\n<p>通过这一套流程，实现了任务的串行</p>\n<p><strong>注意:这个默认的 Executor 也是全局静态，只要是使用默认的方法，就可以保证任务串行，线程池只有一个线程在运行</strong></p>\n<p>问题来了，doInBackground() 去哪儿了？别着急，我们从 mFuture 入手</p>\n<h3 id=\"FutureTask\"><a href=\"#FutureTask\" class=\"headerlink\" title=\"FutureTask\"></a>FutureTask</h3><p>mFuture 是一个 FutureTask 对象，实现了 RunnableFuture 接口，有一个方法 run()，先来看它的构造方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">FutureTask</span><span class=\"params\">(Callable&lt;V&gt; callable)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (callable == <span class=\"keyword\">null</span>)</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</div><div class=\"line\">    <span class=\"keyword\">this</span>.callable = callable;</div><div class=\"line\">    <span class=\"keyword\">this</span>.state = NEW;       <span class=\"comment\">// ensure visibility of callable</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>构造方法接收一个 callable 对象，并赋值给成员变量 callable，诶，想想 mFuture 初始化的地方，这里又得贴一次 AsyncTask 的构造方法代码，传入 mFuture 中的正是 mWorker 对象，而 doInBackground() 方法正是在 mWorker 的 call() 方法中调用的，看到这里先打住，这段代码我们后面还要再看(囧)～</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">AsyncTask</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    mWorker = <span class=\"keyword\">new</span> WorkerRunnable&lt;Params, Result&gt;() &#123;</div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> Result <span class=\"title\">call</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</div><div class=\"line\">            mTaskInvoked.set(<span class=\"keyword\">true</span>);</div><div class=\"line\"></div><div class=\"line\">            Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</div><div class=\"line\">            <span class=\"comment\">//noinspection unchecked</span></div><div class=\"line\">            Result result = doInBackground(mParams);</div><div class=\"line\">            Binder.flushPendingCommands();</div><div class=\"line\">            <span class=\"keyword\">return</span> postResult(result);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;;</div><div class=\"line\"></div><div class=\"line\">    mFuture = <span class=\"keyword\">new</span> FutureTask&lt;Result&gt;(mWorker) &#123;</div><div class=\"line\">        <span class=\"meta\">@Override</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">done</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                postResultIfNotInvoked(get());</div><div class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">                android.util.Log.w(LOG_TAG, e);</div><div class=\"line\">            &#125; <span class=\"keyword\">catch</span> (ExecutionException e) &#123;</div><div class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"An error occurred while executing doInBackground()\"</span>,</div><div class=\"line\">                        e.getCause());</div><div class=\"line\">            &#125; <span class=\"keyword\">catch</span> (CancellationException e) &#123;</div><div class=\"line\">                postResultIfNotInvoked(<span class=\"keyword\">null</span>);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>回到 FutureTask 中来看看 run() 中的代码，为了简洁，只贴部分核心代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Callable&lt;V&gt; c = callable;<span class=\"comment\">// 获取到这个 callable 对象</span></div><div class=\"line\"><span class=\"keyword\">if</span> (c != <span class=\"keyword\">null</span> &amp;&amp; state == NEW) &#123; <span class=\"comment\">// 如果不为空，并且状态为新任务</span></div><div class=\"line\">    V result;</div><div class=\"line\">    <span class=\"keyword\">boolean</span> ran;</div><div class=\"line\">    <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">        result = c.call(); <span class=\"comment\">// 调用call方法获取到result</span></div><div class=\"line\">        ran = <span class=\"keyword\">true</span>;</div><div class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Throwable ex) &#123;</div><div class=\"line\">        result = <span class=\"keyword\">null</span>;</div><div class=\"line\">        ran = <span class=\"keyword\">false</span>;</div><div class=\"line\">        setException(ex);</div><div class=\"line\">    &#125;</div><div class=\"line\">   \t<span class=\"comment\">// 执行成功</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (ran)</div><div class=\"line\">        set(result);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>再追 set(result)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">set</span><span class=\"params\">(V v)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (U.compareAndSwapInt(<span class=\"keyword\">this</span>, STATE, NEW, COMPLETING)) &#123;</div><div class=\"line\">        <span class=\"comment\">// 将结果赋值给要输出的值</span></div><div class=\"line\">      \toutcome = v;</div><div class=\"line\">        U.putOrderedInt(<span class=\"keyword\">this</span>, STATE, NORMAL); <span class=\"comment\">// final state</span></div><div class=\"line\">      \t<span class=\"comment\">// 结束</span></div><div class=\"line\">      \tfinishCompletion();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// 注意只贴了部分代码</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">finishCompletion</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">  \tdone();</div><div class=\"line\"></div><div class=\"line\">    callable = <span class=\"keyword\">null</span>;        <span class=\"comment\">// to reduce footprint</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">done</span><span class=\"params\">()</span> </span>&#123; &#125;</div></pre></td></tr></table></figure>\n<p>最后调用了 done() 方法，还得看之前的构造方法中的代码，初始化时重写了 done() 方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">done</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">              \t<span class=\"comment\">// 将结果发布出去</span></div><div class=\"line\">                postResultIfNotInvoked(get());</div><div class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">                android.util.Log.w(LOG_TAG, e);</div><div class=\"line\">            &#125; <span class=\"keyword\">catch</span> (ExecutionException e) &#123;</div><div class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"An error occurred while executing doInBackground()\"</span>,</div><div class=\"line\">                        e.getCause());</div><div class=\"line\">            &#125; <span class=\"keyword\">catch</span> (CancellationException e) &#123;</div><div class=\"line\">                postResultIfNotInvoked(<span class=\"keyword\">null</span>);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div></pre></td></tr></table></figure>\n<p>又调用了一个方法 postResultIfNotInvoked(get()) ，如果我直接告诉你 get() 是获取到上面那个 outcome 你信么？。。。还是贴代码吧，严谨一点</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">get</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException, ExecutionException </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> s = state;</div><div class=\"line\">    <span class=\"keyword\">if</span> (s &lt;= COMPLETING)</div><div class=\"line\">        s = awaitDone(<span class=\"keyword\">false</span>, <span class=\"number\">0L</span>);</div><div class=\"line\">    <span class=\"keyword\">return</span> report(s);</div><div class=\"line\">&#125; </div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> V <span class=\"title\">report</span><span class=\"params\">(<span class=\"keyword\">int</span> s)</span> <span class=\"keyword\">throws</span> ExecutionException </span>&#123;</div><div class=\"line\">        Object x = outcome;</div><div class=\"line\">        <span class=\"keyword\">if</span> (s == NORMAL)</div><div class=\"line\">            <span class=\"keyword\">return</span> (V)x;</div><div class=\"line\">        <span class=\"keyword\">if</span> (s &gt;= CANCELLED)</div><div class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> CancellationException();</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ExecutionException((Throwable)x);</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>没骗你吧。。。FutureTask 中的任务就完成了，又要回到 AsyncTask 中去</p>\n<h3 id=\"消息传递\"><a href=\"#消息传递\" class=\"headerlink\" title=\"消息传递\"></a>消息传递</h3><p>上一节 mFuture 把接力棒扔给了postResultIfNotInvoked() ，此时任务执行完毕，但还是在子线程中</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">postResultIfNotInvoked</span><span class=\"params\">(Result result)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> wasTaskInvoked = mTaskInvoked.get();</div><div class=\"line\">    <span class=\"keyword\">if</span> (!wasTaskInvoked) &#123;</div><div class=\"line\">        postResult(result);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Result <span class=\"title\">postResult</span><span class=\"params\">(Result result)</span> </span>&#123;</div><div class=\"line\">    <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</div><div class=\"line\">    Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT,</div><div class=\"line\">            <span class=\"keyword\">new</span> AsyncTaskResult&lt;Result&gt;(<span class=\"keyword\">this</span>, result));</div><div class=\"line\">    message.sendToTarget();</div><div class=\"line\">    <span class=\"keyword\">return</span> result;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面的代码出现了熟悉的对象，Message，既然有 Message 基本可以判断是使用 Handler 进行线程间通信</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Handler <span class=\"title\">getHandler</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">synchronized</span> (AsyncTask.class) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (sHandler == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            sHandler = <span class=\"keyword\">new</span> InternalHandler();</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> sHandler;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InternalHandler</span> <span class=\"keyword\">extends</span> <span class=\"title\">Handler</span> </span>&#123;</div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">InternalHandler</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">          \t<span class=\"comment\">//绑定了住线程的 Looper</span></div><div class=\"line\">            <span class=\"keyword\">super</span>(Looper.getMainLooper());</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"meta\">@SuppressWarnings</span>(&#123;<span class=\"string\">\"unchecked\"</span>, <span class=\"string\">\"RawUseOfParameterizedType\"</span>&#125;)</div><div class=\"line\">        <span class=\"meta\">@Override</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</div><div class=\"line\">            AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj;</div><div class=\"line\">            <span class=\"keyword\">switch</span> (msg.what) &#123;</div><div class=\"line\">                <span class=\"keyword\">case</span> MESSAGE_POST_RESULT:</div><div class=\"line\">                    <span class=\"comment\">// There is only one result</span></div><div class=\"line\">                    result.mTask.finish(result.mData[<span class=\"number\">0</span>]);</div><div class=\"line\">                    <span class=\"keyword\">break</span>;</div><div class=\"line\">                <span class=\"keyword\">case</span> MESSAGE_POST_PROGRESS:</div><div class=\"line\">                    result.mTask.onProgressUpdate(result.mData);</div><div class=\"line\">                    <span class=\"keyword\">break</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">finish</span><span class=\"params\">(Result result)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (isCancelled()) &#123;</div><div class=\"line\">            onCancelled(result);</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            onPostExecute(result);</div><div class=\"line\">        &#125;</div><div class=\"line\">        mStatus = Status.FINISHED;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>看到熟悉的 onPostExecute() ，莫名的激动，这条路可算是走通了。别忘了还有一个 execute(Runnable) 方法的重载</p>\n<h3 id=\"execute-Runnable\"><a href=\"#execute-Runnable\" class=\"headerlink\" title=\"execute(Runnable)\"></a>execute(Runnable)</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@MainThread</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(Runnable runnable)</span> </span>&#123;</div><div class=\"line\">    sDefaultExecutor.execute(runnable);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>就这么点，没啥可说的。。。另外用 AsyncTask 用得早的同学还记得有一个 setDefaultExecutor() 的方法来指定默认执行器，这个方法现在也被 hide 了</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/** <span class=\"doctag\">@hide</span> */</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">setDefaultExecutor</span><span class=\"params\">(Executor exec)</span> </span>&#123;</div><div class=\"line\">    sDefaultExecutor = exec;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>有的同学说了那我就是想用自己的 Executor 怎么办？executeOnExecutor() 传入你自己的 Executor 就行。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li>AsyncTask 只负责任务的调度和通信，其余工作由线程池来做</li>\n<li>API19以后默认情况下 AsyncTask 任务是串行</li>\n<li>AsyncTask 使用 Handler 进行通信</li>\n</ul>\n<p>网上也有很多对 AsyncTask 的总结，今天的分析就结束了。希望在读源码的道路上越走越远～</p>\n<p>如果你有不同的理解欢迎交流探讨，不喜请喷～欢迎来喷</p>\n","categories":["Android源码学习"],"tags":[]},{"title":"ThreadPoolExecutor源码学习笔记","url":"https://joesteven.github.io/threadpoolexecutor_source/","content":"<p>安利一波组织：<a href=\"http://itscoder.com/\" target=\"_blank\" rel=\"external\">itsCoder</a></p>\n<p>转载请附原文链接：<a href=\"http://extremej.itscoder.com/threadpoolexecutor_source/\" target=\"_blank\" rel=\"external\">ThreadPoolExecutor源码学习笔记</a></p>\n<p><strong>大部分分析以注释形式写在源码中</strong></p>\n<p>本篇笔记将从 ThreadPoolExecutor 的一次使用上来分析源码，主要涉及线程池创建，execute 的步骤，任务添加到阻塞队列，线程从阻塞队列中拿取任务执行，线程的回收，线程池的终止。</p>\n<p>涉及到的类有</p>\n<ul>\n<li><p>Executors — 获取线程池</p>\n</li>\n<li><p>ThreadPoolExecutor — 线程池</p>\n</li>\n<li><p>Worker — 工作线程</p>\n</li>\n<li><p>LinkedBlockingQueue — 阻塞队列</p>\n</li>\n<li><p>RejectedExecutionHandler — 任务拒绝处理器（实在不知道什么翻译～）</p>\n<p>​</p>\n</li>\n</ul>\n<h3 id=\"线程池的获取\"><a href=\"#线程池的获取\" class=\"headerlink\" title=\"线程池的获取\"></a>线程池的获取</h3><p>我们知道可以通过 Executors 来获取不同类型的线程池，那么就从 Executors 来开始看它是如何返回不同类型的线程池的，看看我们常用的一些方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//获取一个固定线程池</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title\">newFixedThreadPool</span><span class=\"params\">(<span class=\"keyword\">int</span> nThreads, ThreadFactory threadFactory)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ThreadPoolExecutor(nThreads, nThreads,</div><div class=\"line\">                                  <span class=\"number\">0L</span>, TimeUnit.MILLISECONDS,</div><div class=\"line\">                                  <span class=\"keyword\">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</div><div class=\"line\">                                  threadFactory);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//获取只有一个线程的池子</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title\">newSingleThreadExecutor</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> FinalizableDelegatedExecutorService</div><div class=\"line\">            (<span class=\"keyword\">new</span> ThreadPoolExecutor(<span class=\"number\">1</span>, <span class=\"number\">1</span>,</div><div class=\"line\">                                    <span class=\"number\">0L</span>, TimeUnit.MILLISECONDS,</div><div class=\"line\">                                    <span class=\"keyword\">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</div><div class=\"line\">    &#125;</div><div class=\"line\"><span class=\"comment\">//获取一个缓存线程池，可变</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title\">newCachedThreadPool</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ThreadPoolExecutor(<span class=\"number\">0</span>, Integer.MAX_VALUE,</div><div class=\"line\">                                      <span class=\"number\">60L</span>, TimeUnit.SECONDS,</div><div class=\"line\">                                      <span class=\"keyword\">new</span> SynchronousQueue&lt;Runnable&gt;());</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>从上面的三个方法可以发现其实都是 new 了一个 ThreadPoolExecutor ，但是传入的参数不同，我们进到这个构造方法中去一探究竟，看看不同的参数到底代表了什么</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//构造方法</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ThreadPoolExecutor</span><span class=\"params\">(<span class=\"keyword\">int</span> corePoolSize,</span></span></div><div class=\"line\">                          <span class=\"keyword\">int</span> maximumPoolSize,</div><div class=\"line\">                          <span class=\"keyword\">long</span> keepAliveTime,</div><div class=\"line\">                          TimeUnit unit,</div><div class=\"line\">                          BlockingQueue&lt;Runnable&gt; workQueue,</div><div class=\"line\">                          ThreadFactory threadFactory,</div><div class=\"line\">                          RejectedExecutionHandler handler) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (corePoolSize &lt; <span class=\"number\">0</span> ||</div><div class=\"line\">        maximumPoolSize &lt;= <span class=\"number\">0</span> ||</div><div class=\"line\">        maximumPoolSize &lt; corePoolSize ||</div><div class=\"line\">        keepAliveTime &lt; <span class=\"number\">0</span>)</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException();</div><div class=\"line\">    <span class=\"keyword\">if</span> (workQueue == <span class=\"keyword\">null</span> || threadFactory == <span class=\"keyword\">null</span> || handler == <span class=\"keyword\">null</span>)</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</div><div class=\"line\">    <span class=\"keyword\">this</span>.corePoolSize = corePoolSize;</div><div class=\"line\">    <span class=\"keyword\">this</span>.maximumPoolSize = maximumPoolSize;</div><div class=\"line\">    <span class=\"keyword\">this</span>.workQueue = workQueue;</div><div class=\"line\">    <span class=\"keyword\">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</div><div class=\"line\">    <span class=\"keyword\">this</span>.threadFactory = threadFactory;</div><div class=\"line\">    <span class=\"keyword\">this</span>.handler = handler;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>通过参数名称以及注释可以知道这几个参数的作用分别是</p>\n<ul>\n<li>corePoolSize — 核心线程数，即允许闲置的线程数目</li>\n<li>maximumPoolSize — 最大线程数，即这个线程池的容量</li>\n<li>keepAliveTime — 非核心线程的闲置存活时间</li>\n<li>unit — 上一个参数的单位</li>\n<li>workQueue — 任务队列（阻塞队列）</li>\n<li>threadFacotry —  线程创建工厂</li>\n<li>handler — 当线程池或者任务队列容量已满时用于 reject</li>\n</ul>\n<p>这里要明白一件事情，<strong>核心线程只是通过数目来判断，而不是说先创建的线程就是核心线程。</strong></p>\n<p>这句话可能有点难懂，我大概解释一下，线程池这个核心线程数的用处就是来判断当前这个闲置线程是否应该回收，那么什么是闲置线程呢？一个线程执行完了一个任务后，会去阻塞队列里面取新的任务，在取到任务之前它就是一个闲置的线程，<strong>取任务的方法有两个，一个是一直阻塞直到取出任务，另一个是一定时间内阻塞直到取出任务或者超时，如果超时这个线程就会被回收，我们知道核心线程一般不会被回收。</strong></p>\n<p><strong>线程在取任务的时候，线程池会比较当前的有效线程数和允许的核心线程数，如果小于当前的核心线程数则使用第一个方法取任务，也就是没有超时回收，如果大于核心线程数，则使用第二个，一旦超时就回收，所以，并没有绝对的核心线程，只要这个线程出于闲置状态就有被回收的可能。</strong></p>\n<p><strong>还有一种情况是设置了线程池允许核心线程超时回收，那么无论线程数有多少，统统会使用第二个方法取任务。</strong></p>\n<h3 id=\"任务的执行\"><a href=\"#任务的执行\" class=\"headerlink\" title=\"任务的执行\"></a>任务的执行</h3><h4 id=\"A-状态属性\"><a href=\"#A-状态属性\" class=\"headerlink\" title=\"A.状态属性\"></a>A.状态属性</h4><p>在看源码之前先了解一下 ThreadPoolExecutor 的几个状态属性，这对后面的源码阅读有很重要的作用，ThreadPoolExecutor 有五种状态</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> RUNNING    = -<span class=\"number\">1</span> &lt;&lt; COUNT_BITS; </div><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> SHUTDOWN   =  <span class=\"number\">0</span> &lt;&lt; COUNT_BITS;</div><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> STOP       =  <span class=\"number\">1</span> &lt;&lt; COUNT_BITS;</div><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> TIDYING    =  <span class=\"number\">2</span> &lt;&lt; COUNT_BITS;</div><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> TERMINATED =  <span class=\"number\">3</span> &lt;&lt; COUNT_BITS;</div></pre></td></tr></table></figure>\n<p>从上到下依次是</p>\n<ul>\n<li>RUNNING — 运行状态，可以添加新任务，也可以处理阻塞队列中的任务</li>\n<li>SHUTDOWN — 待关闭状态，不再接受新的任务，会继续处理阻塞队列中的任务</li>\n<li>STOP — 停止状态，此时的线程池不处理任何任务</li>\n<li>TIDYING — 整理状态，也可以理解为预终结状态，这个时候任务都处理完毕，池中无有效线程</li>\n<li>TERMINATED — 终止状态</li>\n</ul>\n<h4 id=\"B-execute-Runnable-command\"><a href=\"#B-execute-Runnable-command\" class=\"headerlink\" title=\"B.execute(Runnable command)\"></a>B.execute(Runnable command)</h4><p>当获取到了一个线程池之后，需要它来执行异步任务，也就是 execute(Runnable) ,传入一个 runnable 对象，在 run 方法中执行我们的代码，那么来看一下 execute() 是怎么工作的，因为源码的注释解释得十分清楚，这里将注释也贴出来。简单翻译一下，当 execute 被调用时总共有三种情况。</p>\n<ul>\n<li><strong>如果当前的有效线程数小于核心线程数，则试图创建一个新的 worker 线程</strong></li>\n<li><strong>如果上面一步失败了，则试图将任务添加到阻塞队列中，并且要再一次判断需要不需要回滚队列，或者说创建线程（后面会详细说明）</strong></li>\n<li><strong>如果上面两步都失败了，则会试图强行创建一个线程来执行这个任务，如果还是失败，扔掉这个任务</strong></li>\n</ul>\n<p>了解了这三个步骤，来看看源码，源码中调用了 addworker 方法，这是创建线程的方法，会在后面讲到</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(Runnable command)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (command == <span class=\"keyword\">null</span>)</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</div><div class=\"line\">    <span class=\"comment\">/*</span></div><div class=\"line\">     * Proceed in 3 steps:</div><div class=\"line\">     *</div><div class=\"line\">     * 1. If fewer than corePoolSize threads are running, try to</div><div class=\"line\">     * start a new thread with the given command as its first</div><div class=\"line\">     * task.  The call to addWorker atomically checks runState and</div><div class=\"line\">     * workerCount, and so prevents false alarms that would add</div><div class=\"line\">     * threads when it shouldn't, by returning false.</div><div class=\"line\">     *</div><div class=\"line\">     * 2. If a task can be successfully queued, then we still need</div><div class=\"line\">     * to double-check whether we should have added a thread</div><div class=\"line\">     * (because existing ones died since last checking) or that</div><div class=\"line\">     * the pool shut down since entry into this method. So we</div><div class=\"line\">     * recheck state and if necessary roll back the enqueuing if</div><div class=\"line\">     * stopped, or start a new thread if there are none.</div><div class=\"line\">     *</div><div class=\"line\">     * 3. If we cannot queue task, then we try to add a new</div><div class=\"line\">     * thread.  If it fails, we know we are shut down or saturated</div><div class=\"line\">     * and so reject the task.</div><div class=\"line\">     */</div><div class=\"line\">    <span class=\"keyword\">int</span> c = ctl.get();</div><div class=\"line\">  <span class=\"comment\">//1.判断有效线程数是否小于核心线程数</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</div><div class=\"line\">      <span class=\"comment\">//创建新线程</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (addWorker(command, <span class=\"keyword\">true</span>))</div><div class=\"line\">            <span class=\"keyword\">return</span>;</div><div class=\"line\">        c = ctl.get();</div><div class=\"line\">    &#125;</div><div class=\"line\">  <span class=\"comment\">//2.分开来看，首先判断当前的池子是否是处于 running 状态</span></div><div class=\"line\">  <span class=\"comment\">//因为只有 running 状态才可以接收新任务</span></div><div class=\"line\">  <span class=\"comment\">//接下来判断能否成功添加到队列中，如果队列满了或者其他情况则会跳到下一步</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</div><div class=\"line\">      <span class=\"comment\">//再次检查池子的状态，如果进入了非 running 状态，回滚队列，扔掉这个任务</span></div><div class=\"line\">        <span class=\"keyword\">int</span> recheck = ctl.get();</div><div class=\"line\">        <span class=\"keyword\">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</div><div class=\"line\">            reject(command);</div><div class=\"line\">      <span class=\"comment\">//如果处于 running 状态则检查当前的有效线程，如果没有则创建一个线程</span></div><div class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (workerCountOf(recheck) == <span class=\"number\">0</span>)</div><div class=\"line\">            addWorker(<span class=\"keyword\">null</span>, <span class=\"keyword\">false</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">  <span class=\"comment\">//3.前两步失败了，就强行创建线程，成功会返回true，如果失败扔掉这个任务</span></div><div class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!addWorker(command, <span class=\"keyword\">false</span>))</div><div class=\"line\">        reject(command);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>解释一下第二步，为什么要recheck</p>\n<p><strong>当这个任务被添加到了阻塞队列前，池子处于 RUNNING 状态，但如果在添加到队列成功后，池子进入了 SHUTDOWN 状态或者其他状态，这时候是不应该再接收新的任务的，所以需要把这个任务从队列中移除，并且 reject</strong></p>\n<p><strong>同样，在没有添加到队列前，可能有一个有效线程，但添加完任务后，这个线程闲置超时或者因为异常被干掉了，这时候需要创建一个新的线程来执行任务</strong></p>\n<p>为了更直观的理解一个任务的执行过程，我画了一张图：</p>\n<p><img src=\"http://7xtakx.com1.z0.glb.clouddn.com/threadpoolexecutor.png\" alt=\"执行流程.png\"></p>\n<h4 id=\"C-addWorker\"><a href=\"#C-addWorker\" class=\"headerlink\" title=\"C .addWorker()\"></a>C .addWorker()</h4><p>前一步把 execute 的流程捋了一遍，里面多次出现了 addWorker() 方法，前文说到这是个创建线程的方法，来看看 addWorker 做了些什么，这个方法代码比较长，我们拆开来一点一点看</p>\n<ul>\n<li>第一部分 — 判断各种基础异常</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">addWorker</span><span class=\"params\">(Runnable firstTask, <span class=\"keyword\">boolean</span> core)</span> </span>&#123;</div><div class=\"line\">    retry:</div><div class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> c = ctl.get();</div><div class=\"line\">        <span class=\"keyword\">int</span> rs = runStateOf(c);</div><div class=\"line\"></div><div class=\"line\">      <span class=\"comment\">// Check if queue empty only if necessary.</span></div><div class=\"line\">      <span class=\"comment\">// 检查线程池状态，队列状态，以及 firstask ，拆开来看</span></div><div class=\"line\">      <span class=\"comment\">// 这段代码看起来异常的蛋疼,转换一下逻辑即</span></div><div class=\"line\">     <span class=\"comment\">//rs&gt;= SHUTDOWN &amp;&amp; (rs != SHUTDOWN || firstTask != null ||workQueue.isEmpty())</span></div><div class=\"line\">      <span class=\"comment\">// 总结起来就是 当前处于非 Running 状态,并且这三种情况</span></div><div class=\"line\">      <span class=\"comment\">// 1. 不是处于 SHUTDOWN 状态，不能再创建线程</span></div><div class=\"line\">      <span class=\"comment\">// 2. 有新的任务 (因为不能再接收新的任务)</span></div><div class=\"line\">      <span class=\"comment\">// 3. 阻塞队列中已经没有任务 (不需要再创建线程)</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</div><div class=\"line\">            ! (rs == SHUTDOWN &amp;&amp;</div><div class=\"line\">               firstTask == <span class=\"keyword\">null</span> &amp;&amp;</div><div class=\"line\">               ! workQueue.isEmpty()))</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">\t\t</div><div class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> wc = workerCountOf(c);<span class=\"comment\">//当前有效线程数目</span></div><div class=\"line\">           <span class=\"comment\">// 根据传入的参数确定以核心线程数还是最大线程数作为判断条件</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (wc &gt;= CAPACITY ||</div><div class=\"line\">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</div><div class=\"line\">              <span class=\"comment\">// 大于容量 或者指定的线程数，不允许创建</span></div><div class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">            <span class=\"keyword\">if</span> (compareAndIncrementWorkerCount(c))</div><div class=\"line\">                <span class=\"keyword\">break</span> retry;</div><div class=\"line\">            c = ctl.get();  <span class=\"comment\">// Re-read ctl</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (runStateOf(c) != rs)</div><div class=\"line\">                <span class=\"keyword\">continue</span> retry;</div><div class=\"line\">            <span class=\"comment\">// else CAS failed due to workerCount change; retry inner loop</span></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  ｝</div></pre></td></tr></table></figure>\n<ul>\n<li>第二部分 — 试图创建线程</li>\n</ul>\n<p>创建一个Worker(什么东西？下文会讲解，这里把它就当成是一个线程的容器)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">boolean</span> workerStarted = <span class=\"keyword\">false</span>;<span class=\"comment\">//标记 worker 开启状态</span></div><div class=\"line\"><span class=\"keyword\">boolean</span> workerAdded = <span class=\"keyword\">false</span>;<span class=\"comment\">//标记 worker 添加状态</span></div><div class=\"line\">Worker w = <span class=\"keyword\">null</span>;</div><div class=\"line\"><span class=\"keyword\">try</span> &#123;</div><div class=\"line\">    w = <span class=\"keyword\">new</span> Worker(firstTask); <span class=\"comment\">//将这个任务作为 worker 的第一个任务传入</span></div><div class=\"line\">    <span class=\"keyword\">final</span> Thread t = w.thread;<span class=\"comment\">//通过 worker 获取到一个线程</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (t != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">final</span> ReentrantLock mainLock = <span class=\"keyword\">this</span>.mainLock;</div><div class=\"line\">        mainLock.lock();</div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">            <span class=\"comment\">// Recheck while holding lock.</span></div><div class=\"line\">            <span class=\"comment\">// Back out on ThreadFactory failure or if</span></div><div class=\"line\">            <span class=\"comment\">// shut down before lock acquired.</span></div><div class=\"line\">            <span class=\"keyword\">int</span> rs = runStateOf(ctl.get());</div><div class=\"line\">\t\t\t</div><div class=\"line\">           <span class=\"comment\">// running状态，或者 shutdown 状态但是没有新的任务</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (rs &lt; SHUTDOWN ||(rs == SHUTDOWN &amp;&amp; firstTask == <span class=\"keyword\">null</span>)) &#123;</div><div class=\"line\">                <span class=\"keyword\">if</span> (t.isAlive()) <span class=\"comment\">// precheck that t is startable</span></div><div class=\"line\">                    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalThreadStateException();</div><div class=\"line\">                <span class=\"comment\">// 将这个 worker 添加到线程池中</span></div><div class=\"line\">              \tworkers.add(w); </div><div class=\"line\">                <span class=\"keyword\">int</span> s = workers.size();</div><div class=\"line\">                <span class=\"keyword\">if</span> (s &gt; largestPoolSize)</div><div class=\"line\">                    largestPoolSize = s;</div><div class=\"line\">              <span class=\"comment\">//标记worker添加成功</span></div><div class=\"line\">                workerAdded = <span class=\"keyword\">true</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">            mainLock.unlock();</div><div class=\"line\">        &#125;</div><div class=\"line\">      \t<span class=\"comment\">// 如果 worker 创建成功，开启线程</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (workerAdded) &#123;</div><div class=\"line\">            t.start();</div><div class=\"line\">            workerStarted = <span class=\"keyword\">true</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (! workerStarted)</div><div class=\"line\">        addWorkerFailed(w);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">return</span> workerStarted;</div></pre></td></tr></table></figure>\n<p>上面代码从逻辑层面来看不算难懂，到这里一个任务到达后，ThreadPoolExecutor 的处理就结束了，那么任务又是怎么被添加到阻塞队列中，线程是如何从队列中取出任务，上文中的 Worker 又是什么东西？</p>\n<p>一个一个来，先来看看 Worker 到底是什么</p>\n<h4 id=\"D-Worker\"><a href=\"#D-Worker\" class=\"headerlink\" title=\"D.Worker\"></a>D.Worker</h4><p>Worker 是 ThreadPoolExecutor 的一个内部类，实现了 Runnable 接口，继承自 AbstractQueuedSynchronizer,这又是个什么鬼？？？我也不造～可以看看这篇文章</p>\n<p><a href=\"http://www.cnblogs.com/zhanjindong/p/java-concurrent-package-aqs-overview.html\" target=\"_blank\" rel=\"external\">《Java并发包源码学习之AQS框架（一）概述》</a></p>\n<p>简单来说，Worker实现了 lock 和 unLock 方法来标示当前线程的状态是否为闲置</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">lock</span><span class=\"params\">()</span>        </span>&#123; acquire(<span class=\"number\">1</span>); &#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryLock</span><span class=\"params\">()</span>  </span>&#123; <span class=\"keyword\">return</span> tryAcquire(<span class=\"number\">1</span>); &#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">unlock</span><span class=\"params\">()</span>      </span>&#123; release(<span class=\"number\">1</span>); &#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isLocked</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> isHeldExclusively(); &#125;</div></pre></td></tr></table></figure>\n<p>上一节创建线程成功后调用 t.start() 而这个线程又是 Worker 的成员变量</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Worker(Runnable firstTask) &#123;</div><div class=\"line\">    setState(-<span class=\"number\">1</span>); <span class=\"comment\">// inhibit interrupts until runWorker</span></div><div class=\"line\">    <span class=\"keyword\">this</span>.firstTask = firstTask;</div><div class=\"line\">    <span class=\"keyword\">this</span>.thread = getThreadFactory().newThread(<span class=\"keyword\">this</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看到这里将 Worker 作为 Runnable 参数创建了一个新的线程，我们知道 Thread 接收一个 Runnable 对象后 start 运行的是 Runnable 的 run 方法，Worker 的 run 方法调用了 runWorker ,这个方法里面就是取出任务执行的逻辑</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    runWorker(<span class=\"keyword\">this</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">runWorker</span><span class=\"params\">(Worker w)</span> </span>&#123;</div><div class=\"line\">        Thread wt = Thread.currentThread();</div><div class=\"line\">        Runnable task = w.firstTask; <span class=\"comment\">// 获取到 worker 的第一个任务</span></div><div class=\"line\">        w.firstTask = <span class=\"keyword\">null</span>;</div><div class=\"line\">        w.unlock(); <span class=\"comment\">// 标记为闲置，还没有开始任务 允许打断</span></div><div class=\"line\">        <span class=\"keyword\">boolean</span> completedAbruptly = <span class=\"keyword\">true</span>; <span class=\"comment\">// 异常退出标记</span></div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">          <span class=\"comment\">// 循环取出任务，如果第一个任务不为空，或者从队列中拿到了任务</span></div><div class=\"line\">          <span class=\"comment\">// 只要这两个条件满足，会一直循环，直到没有任务，正常退出，或者异常退出</span></div><div class=\"line\">            <span class=\"keyword\">while</span> (task != <span class=\"keyword\">null</span> || (task = getTask()) != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                w.lock();<span class=\"comment\">// 该线程标记为非闲置</span></div><div class=\"line\">                <span class=\"comment\">// If pool is stopping, ensure thread is interrupted;</span></div><div class=\"line\">                <span class=\"comment\">// if not, ensure thread is not interrupted.  This</span></div><div class=\"line\">                <span class=\"comment\">// requires a recheck in second case to deal with</span></div><div class=\"line\">                <span class=\"comment\">// shutdownNow race while clearing interrupt</span></div><div class=\"line\">              <span class=\"comment\">// 翻译注释：1.如果线程池STOPPING状态，需要中断线程</span></div><div class=\"line\">              <span class=\"comment\">// 2.Thread.interrupted()是一个native方法，返回当前线程是否有被等待中断的请求</span></div><div class=\"line\">              <span class=\"comment\">// 3.第二个条件成立时，检查线程池状态，如果为STOP，并且没有被中断，则中断线程</span></div><div class=\"line\">                <span class=\"keyword\">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</div><div class=\"line\">                     (Thread.interrupted() &amp;&amp;</div><div class=\"line\">                      runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</div><div class=\"line\">                    !wt.isInterrupted())</div><div class=\"line\">                    wt.interrupt();</div><div class=\"line\">              <span class=\"comment\">// 执行任务</span></div><div class=\"line\">                <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                    beforeExecute(wt, task);<span class=\"comment\">// 执行前</span></div><div class=\"line\">                    Throwable thrown = <span class=\"keyword\">null</span>;</div><div class=\"line\">                    <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                        task.run(); <span class=\"comment\">// 执行任务</span></div><div class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (RuntimeException x) &#123;</div><div class=\"line\">                        thrown = x; <span class=\"keyword\">throw</span> x;</div><div class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (Error x) &#123;</div><div class=\"line\">                        thrown = x; <span class=\"keyword\">throw</span> x;</div><div class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (Throwable x) &#123;</div><div class=\"line\">                        thrown = x; <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(x);</div><div class=\"line\">                    &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">                        afterExecute(task, thrown); <span class=\"comment\">// 执行结束</span></div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">                    task = <span class=\"keyword\">null</span>; <span class=\"comment\">// 将 worker 的任务置空</span></div><div class=\"line\">                    w.completedTasks++; </div><div class=\"line\">                    w.unlock(); <span class=\"comment\">// 释放锁，进入闲置状态</span></div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;<span class=\"comment\">// 循环结束</span></div><div class=\"line\">            completedAbruptly = <span class=\"keyword\">false</span>; <span class=\"comment\">// 标记为正常退出</span></div><div class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">          <span class=\"comment\">// 干掉 worker</span></div><div class=\"line\">            processWorkerExit(w, completedAbruptly);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>这里弄清楚了一件事情，进入循环准备执行任务时，worker 加锁标记为非闲置，任务执行完毕或者出现异常，worker 释放锁，进入闲置状态。</p>\n<p><strong>也就是当一个 worker 执行任务前或者执行完任务，到取出下一个任务期间，都是闲置状态可以被打断</strong></p>\n<p>上面取出任务调用了 getTask() ，诶～为什么有一个死循环，别着急，慢慢看来。上面的代码可以知道如果 getTask 返回任务则执行，如果返回为 null 则 worker 需要被回收</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Runnable <span class=\"title\">getTask</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// 标记取任务是否超时</span></div><div class=\"line\">    <span class=\"keyword\">boolean</span> timedOut = <span class=\"keyword\">false</span>; <span class=\"comment\">// Did the last poll() time out?</span></div><div class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> c = ctl.get();</div><div class=\"line\">        <span class=\"keyword\">int</span> rs = runStateOf(c);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// Check if queue empty only if necessary.</span></div><div class=\"line\">      \t<span class=\"comment\">// 如果线程池状态为 STOP 或者 SHUTDOWN 并且队列已经为空，回收 wroker</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</div><div class=\"line\">            decrementWorkerCount();</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">\t\t<span class=\"comment\">//获取当前有效线程数</span></div><div class=\"line\">        <span class=\"keyword\">int</span> wc = workerCountOf(c);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// Are workers subject to culling?</span></div><div class=\"line\">      \t<span class=\"comment\">// timed 用来标记当前的 worker 是否设置超时时间，</span></div><div class=\"line\">      \t<span class=\"comment\">// 还记得获取线程池的时候 可以设置核心线程超时时间</span></div><div class=\"line\">      \t<span class=\"comment\">//1.允许核心线程超时回收(即所有线程) 2.当前有效线程超过核心线程数(需要回收)</span></div><div class=\"line\">      \t<span class=\"comment\">// 如果timed == false 则该worker不会被回收，如果没有取到任务 会一直阻塞</span></div><div class=\"line\">        <span class=\"keyword\">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</div><div class=\"line\">\t\t</div><div class=\"line\">      \t<span class=\"comment\">// 回收线程条件</span></div><div class=\"line\">      \t<span class=\"comment\">// 1. 有效线程数已经大于了线程池的最大线程数或者设置了超时回收并且已经超时</span></div><div class=\"line\">      \t<span class=\"comment\">// 2. 有效线程数大于1或者队列任务已经为空</span></div><div class=\"line\">      \t<span class=\"comment\">// 只有当上面1和2 同时满足时 则试图回收线程</span></div><div class=\"line\">        <span class=\"keyword\">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</div><div class=\"line\">            &amp;&amp; (wc &gt; <span class=\"number\">1</span> || workQueue.isEmpty())) &#123;</div><div class=\"line\">          <span class=\"comment\">// 如果减少workercount成功 直接回收</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (compareAndDecrementWorkerCount(c))</div><div class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">          <span class=\"comment\">// 否则重走循环，从第一个判断条件处回收</span></div><div class=\"line\">            <span class=\"keyword\">continue</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">\t\t<span class=\"comment\">// 取任务</span></div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">          <span class=\"comment\">// 根据是否设置超时回收来选择不同的取任务的方式</span></div><div class=\"line\">          <span class=\"comment\">// poll 方法取任务会有超时时间，超过时间则返回null</span></div><div class=\"line\">          <span class=\"comment\">// take 方法没有超时时间，阻塞式方法</span></div><div class=\"line\">            Runnable r = timed ?</div><div class=\"line\">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</div><div class=\"line\">                workQueue.take();</div><div class=\"line\">          <span class=\"comment\">// 如果任务不为空返回任务</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (r != <span class=\"keyword\">null</span>)</div><div class=\"line\">                <span class=\"keyword\">return</span> r;</div><div class=\"line\">          <span class=\"comment\">// 否则标记超时 进入下一次循环等待回收</span></div><div class=\"line\">            timedOut = <span class=\"keyword\">true</span>;</div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException retry) &#123;</div><div class=\"line\">          <span class=\"comment\">// 如果出现异常，试图重试</span></div><div class=\"line\">            timedOut = <span class=\"keyword\">false</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>getTask() 方法逻辑也捋得差不多了，这里又出现了两个新的方法，workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) 和 workQueue.take() ，这两个都是阻塞队列的方法，来看看它们又各自是怎么实现的</p>\n<h4 id=\"E-LinkedBlockingQueue-—-阻塞队列\"><a href=\"#E-LinkedBlockingQueue-—-阻塞队列\" class=\"headerlink\" title=\"E.LinkedBlockingQueue — 阻塞队列\"></a>E.LinkedBlockingQueue — 阻塞队列</h4><p>ThreadPoolExecutor 使用的是链表结构的阻塞队列，实现了 BlockingQueue 接口，而 BlockingQueue 则是继承自 Queue 接口，再上层就是 Collection 接口。</p>\n<p>因为本篇笔记主要是分析 ThreadPoolExecutor 的原理，所以不会详细介绍 LinkedBlockingQueue 中的其它代码，主要介绍这里所用的方法，首先来看一下上文所提到的 take()</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">take</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</div><div class=\"line\">    E x; <span class=\"comment\">// 任务</span></div><div class=\"line\">    <span class=\"keyword\">int</span> c = -<span class=\"number\">1</span>; <span class=\"comment\">// 取出任务后的剩余任务数量</span></div><div class=\"line\">    <span class=\"keyword\">final</span> AtomicInteger count = <span class=\"keyword\">this</span>.count; <span class=\"comment\">// 当前任务数量</span></div><div class=\"line\">    <span class=\"keyword\">final</span> ReentrantLock takeLock = <span class=\"keyword\">this</span>.takeLock; <span class=\"comment\">// 加锁防止并发</span></div><div class=\"line\">    takeLock.lockInterruptibly();</div><div class=\"line\">    <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">      <span class=\"comment\">// 如果队列数量为空，则一直循环，阻塞线程</span></div><div class=\"line\">        <span class=\"keyword\">while</span> (count.get() == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">            notEmpty.await();</div><div class=\"line\">        &#125;</div><div class=\"line\">      <span class=\"comment\">// 取出任务</span></div><div class=\"line\">        x = dequeue();</div><div class=\"line\">      <span class=\"comment\">// 任务数量减一</span></div><div class=\"line\">        c = count.getAndDecrement();</div><div class=\"line\">        <span class=\"keyword\">if</span> (c &gt; <span class=\"number\">1</span>)</div><div class=\"line\">            notEmpty.signal();<span class=\"comment\">// 标记队列非空</span></div><div class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">        takeLock.unlock(); <span class=\"comment\">// 释放锁</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  <span class=\"comment\">//</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (c == capacity)</div><div class=\"line\">        signalNotFull();<span class=\"comment\">//标记队列已满</span></div><div class=\"line\">    <span class=\"keyword\">return</span> x;<span class=\"comment\">// 返回任务</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面的代码可以知道 take 方法会一直阻塞直到队列有新的任务为止</p>\n<p>接下来是 poll 方法，可以看到几乎与 take 方法相同，唯一的区别是在阻塞的循环代码块里面加了时间判断，如果超时则直接返回为空，不会一直阻塞下去</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">poll</span><span class=\"params\">(<span class=\"keyword\">long</span> timeout, TimeUnit unit)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</div><div class=\"line\">    E x = <span class=\"keyword\">null</span>; <span class=\"comment\">// 存放的任务</span></div><div class=\"line\">    <span class=\"keyword\">int</span> c = -<span class=\"number\">1</span>; </div><div class=\"line\">    <span class=\"keyword\">long</span> nanos = unit.toNanos(timeout); <span class=\"comment\">// 超时时间</span></div><div class=\"line\">    <span class=\"keyword\">final</span> AtomicInteger count = <span class=\"keyword\">this</span>.count; <span class=\"comment\">// 队列中的数量</span></div><div class=\"line\">    <span class=\"keyword\">final</span> ReentrantLock takeLock = <span class=\"keyword\">this</span>.takeLock; <span class=\"comment\">// 加锁防止并发</span></div><div class=\"line\">    takeLock.lockInterruptibly();</div><div class=\"line\">    <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">      <span class=\"comment\">// 如果队列为空，则不断的循环</span></div><div class=\"line\">        <span class=\"keyword\">while</span> (count.get() == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">          <span class=\"comment\">// 如果当倒计时小于0 即超时时间到 则返回空</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (nanos &lt;= <span class=\"number\">0</span>)</div><div class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">          <span class=\"comment\">// 让线程等待</span></div><div class=\"line\">            nanos = notEmpty.awaitNanos(nanos);</div><div class=\"line\">        &#125;</div><div class=\"line\">        x = dequeue(); <span class=\"comment\">// 取出一个任务</span></div><div class=\"line\">        c = count.getAndDecrement(); <span class=\"comment\">// 取出后的队列数量</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (c &gt; <span class=\"number\">1</span>)</div><div class=\"line\">            notEmpty.signal(); <span class=\"comment\">// 标记非空</span></div><div class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">        takeLock.unlock(); <span class=\"comment\">// 释放锁</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (c == capacity)</div><div class=\"line\">        signalNotFull(); <span class=\"comment\">// 标记队列已满</span></div><div class=\"line\">    <span class=\"keyword\">return</span> x; <span class=\"comment\">// 返回任务</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"线程池的回收及终止\"><a href=\"#线程池的回收及终止\" class=\"headerlink\" title=\"线程池的回收及终止\"></a>线程池的回收及终止</h3><p>前一节分析了任务的执行流程及原理，也留下了一个问题，worker 是如何被回收的呢？线程池该如何管理呢？回到上一节的 runWorker() 方法中，还记得最后调用了一个方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">processWorkerExit(w, completedAbruptly);</div></pre></td></tr></table></figure>\n<p>这个方法传入了两个参数，第一个是当前的 Woker ,第二个是标记异常退出的标识</p>\n<p>首先判断是否为异常退出，如果是异常退出的话需要手动调整线程数量，如果是正常回收的，getTask 方法里面已经手动调整过了，不记得的小伙伴可以看看前文的代码，找找 decrementWorkerCount(),</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">processWorkerExit</span><span class=\"params\">(Worker w, <span class=\"keyword\">boolean</span> completedAbruptly)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (completedAbruptly) <span class=\"comment\">// If abrupt, then workerCount wasn't adjusted</span></div><div class=\"line\">        decrementWorkerCount();</div><div class=\"line\">\t<span class=\"comment\">// 加锁</span></div><div class=\"line\">    <span class=\"keyword\">final</span> ReentrantLock mainLock = <span class=\"keyword\">this</span>.mainLock;</div><div class=\"line\">    mainLock.lock();</div><div class=\"line\">  \t<span class=\"comment\">// 记录线程池完成的任务总数，从 workers 中移除该 worker</span></div><div class=\"line\">    <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">        completedTaskCount += w.completedTasks;</div><div class=\"line\">        workers.remove(w);</div><div class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">        mainLock.unlock();</div><div class=\"line\">    &#125;</div><div class=\"line\">\t</div><div class=\"line\">    tryTerminate();<span class=\"comment\">//尝试关闭池子</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">int</span> c = ctl.get();</div><div class=\"line\">  <span class=\"comment\">// 以下的代码是判断需不需要给线程池创建一个新的线程</span></div><div class=\"line\">  <span class=\"comment\">// 如果线程池的状态是 RUNNING 或者 SHUTDOWN 进一步判断需不需要创建</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (runStateLessThan(c, STOP)) &#123;</div><div class=\"line\">      <span class=\"comment\">// 如果为异常退出直接创建，如果不是异常退出进入判断</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (!completedAbruptly) &#123;</div><div class=\"line\">          <span class=\"comment\">// 获取线程池应该存在的最小线程数 如果设置了超时 则是0，否则是核心线程数</span></div><div class=\"line\">            <span class=\"keyword\">int</span> min = allowCoreThreadTimeOut ? <span class=\"number\">0</span> : corePoolSize;</div><div class=\"line\">          <span class=\"comment\">// 如果 min 是0 但是队列又不为空，则 min 应该是1</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (min == <span class=\"number\">0</span> &amp;&amp; ! workQueue.isEmpty())</div><div class=\"line\">                min = <span class=\"number\">1</span>;</div><div class=\"line\">          <span class=\"comment\">//如果当前池中的有效线程数大于等于最小线程数 则不需要创建</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (workerCountOf(c) &gt;= min)</div><div class=\"line\">                <span class=\"keyword\">return</span>; <span class=\"comment\">// replacement not needed</span></div><div class=\"line\">        &#125;</div><div class=\"line\">      <span class=\"comment\">// 创建线程</span></div><div class=\"line\">        addWorker(<span class=\"keyword\">null</span>, <span class=\"keyword\">false</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面的代码中调用了 tryTerminate() 方法，这个方法是用于终止线程池的，又是一个 for 循环，从代码结构来看是异常情况的重试机制。还是老方法，慢慢来看总共做了几件事情</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">tryTerminate</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> c = ctl.get();</div><div class=\"line\">      <span class=\"comment\">// 如果处于这三种情况不需要关闭线程池</span></div><div class=\"line\">      <span class=\"comment\">// 1. Running 状态</span></div><div class=\"line\">      <span class=\"comment\">// 2. SHUTDOWN 状态并且任务队列不为空，不能终止</span></div><div class=\"line\">      <span class=\"comment\">// 3. TIDYING 或者 TERMINATE 状态，说明已经在关闭了 不需要重复关闭</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (isRunning(c) ||</div><div class=\"line\">            runStateAtLeast(c, TIDYING) ||</div><div class=\"line\">            (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))</div><div class=\"line\">            <span class=\"keyword\">return</span>;</div><div class=\"line\">      <span class=\"comment\">// 进入到关闭线程池的代码，如果线程池中还有线程，则需要打断线程</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (workerCountOf(c) != <span class=\"number\">0</span>) &#123; <span class=\"comment\">// Eligible to terminate 可以关闭池子</span></div><div class=\"line\">          <span class=\"comment\">// 打断闲置线程，只打断一个</span></div><div class=\"line\">            interruptIdleWorkers(ONLY_ONE);</div><div class=\"line\">            <span class=\"keyword\">return</span>;</div><div class=\"line\">          <span class=\"comment\">// 如果有两个以上怎么办？只打断一个？</span></div><div class=\"line\">          <span class=\"comment\">// 这里只打断一个是因为 worker 回收的时候都会进入到该方法中来，可以回去再看看</span></div><div class=\"line\">          <span class=\"comment\">// runWorker方法最后的代码</span></div><div class=\"line\">        &#125;</div><div class=\"line\">\t\t</div><div class=\"line\">      \t<span class=\"comment\">// 线程已经回收完毕，准备关闭线程池</span></div><div class=\"line\">        <span class=\"keyword\">final</span> ReentrantLock mainLock = <span class=\"keyword\">this</span>.mainLock;</div><div class=\"line\">        mainLock.lock();<span class=\"comment\">// 加锁</span></div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">          <span class=\"comment\">//  将状态改变为 TIDYING 并且即将调用 terminated</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (ctl.compareAndSet(c, ctlOf(TIDYING, <span class=\"number\">0</span>))) &#123;</div><div class=\"line\">                <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                    terminated(); <span class=\"comment\">// 终止线程池</span></div><div class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">                    ctl.set(ctlOf(TERMINATED, <span class=\"number\">0</span>)); <span class=\"comment\">// 改变状态</span></div><div class=\"line\">                    termination.signalAll();</div><div class=\"line\">                &#125;</div><div class=\"line\">                <span class=\"keyword\">return</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">            mainLock.unlock();</div><div class=\"line\">          <span class=\"comment\">// 如果终止失败会重试</span></div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"comment\">// else retry on failed CAS</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>尝试终止线程池的代码分析完了，好像就结束了～但作为好奇宝宝，我们是不是应该看看如何打断闲置线程，以及 terminated 中做了什么呢？来吧，继续装逼</p>\n<p>先来看打断线程</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">interruptIdleWorkers</span><span class=\"params\">(<span class=\"keyword\">boolean</span> onlyOne)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">final</span> ReentrantLock mainLock = <span class=\"keyword\">this</span>.mainLock;</div><div class=\"line\">    mainLock.lock();<span class=\"comment\">//加锁～</span></div><div class=\"line\">    <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">      <span class=\"comment\">// 遍历线程池中的 wroker</span></div><div class=\"line\">        <span class=\"keyword\">for</span> (Worker w : workers) &#123;</div><div class=\"line\">            Thread t = w.thread;</div><div class=\"line\">          <span class=\"comment\">// 如果线程没有被中断，并且能够获取到 worker的锁(说明是闲置线程)</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123;</div><div class=\"line\">                <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                    t.interrupt();<span class=\"comment\">// 中断线程</span></div><div class=\"line\">                &#125; <span class=\"keyword\">catch</span> (SecurityException ignore) &#123;</div><div class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">                    w.unlock();</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">          <span class=\"comment\">// 只中断一个 worker 跳出循环，否则会将所有的闲置线程都中断</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (onlyOne)</div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">        mainLock.unlock();<span class=\"comment\">// 释放锁</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>有同学开始装逼了，说我们是好奇宝宝，t.interrupt() 方法也应该看，嗯～没错，但这里是调用了 native 方法，会 c 的可以去看看装逼，我就算了～</p>\n<p>好了，再来看看 terminate, 是不是很坑爹？ terminated 里面神！马！也！没！干！。。。淡定，其实这个方法类似于 Activity 的生命周期方法，允许你在被终止时做一些事情，默认的线程池没有什么要做的事情，当然什么也没写啦～</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * Method invoked when the Executor has terminated.  Default</div><div class=\"line\"> * implementation does nothing. Note: To properly nest multiple</div><div class=\"line\"> * overridings, subclasses should generally invoke</div><div class=\"line\"> * &#123;<span class=\"doctag\">@code</span> super.terminated&#125; within this method.</div><div class=\"line\"> */</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">terminated</span><span class=\"params\">()</span> </span>&#123; &#125;</div></pre></td></tr></table></figure>\n<h3 id=\"异常处理\"><a href=\"#异常处理\" class=\"headerlink\" title=\"异常处理\"></a>异常处理</h3><p>还记得前面讲到，出现各种异常情况，添加队列失败等等，只是笼统的说了一句扔掉，当然代码实现不可能是简单一句扔掉就完了。回到 execute() 方法中找到 reject() 任务，看看究竟是怎么处理的</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">reject</span><span class=\"params\">(Runnable command)</span> </span>&#123;</div><div class=\"line\">    handler.rejectedExecution(command, <span class=\"keyword\">this</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>还记得在创建线程池的时候，初始化了一个 handler — RejectedExecutionHandler</p>\n<p>这是一个接口，只有一个方法,接收两个参数</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">rejectedExecution</span><span class=\"params\">(Runnable r, ThreadPoolExecutor executor)</span></span>;</div></pre></td></tr></table></figure>\n<p>既然是一个接口，那么肯定有他的实现类，我们先不急着看所有实现类，先来看看这里的 handler 可能是什么，记得在使用 Executors 获取线程池调用构造方法的时候并没有传入 handler 参数，那么 ThreadPoolExecutor 应该会有一个默认的 handler</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> RejectedExecutionHandler defaultHandler =</div><div class=\"line\">    <span class=\"keyword\">new</span> AbortPolicy();</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AbortPolicy</span> <span class=\"keyword\">implements</span> <span class=\"title\">RejectedExecutionHandler</span> </span>&#123;</div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">AbortPolicy</span><span class=\"params\">()</span> </span>&#123; &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">rejectedExecution</span><span class=\"params\">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RejectedExecutionException(<span class=\"string\">\"Task \"</span> + r.toString() +</div><div class=\"line\">                                                 <span class=\"string\">\" rejected from \"</span> +</div><div class=\"line\">                                                 e.toString());</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>默认 handler 是 AbortPolicy ,这个类实现了 rejectedExecution() 方法，抛了一个 Runtime 异常，也就是说当任务添加失败，就会抛出异常。这个类在 AsyncTask 引发了一场血案～所以在 API19 以后修改了 AsyncTask 的部分代码逻辑，这里就不细说啦，会在下一篇 AsyncTask 的笔记中分析。</p>\n<p>实际上，在 ThreadPoolExecutor 中除了 AbortPolicy 外还实现了三种不同类型的 handler</p>\n<ul>\n<li>CallerRunsPolicy — 在 线程池没有 shutdown 的前提下，会直接在执行 execute 方法的线程里执行这个任务</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">rejectedExecution</span><span class=\"params\">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (!e.isShutdown()) &#123;</div><div class=\"line\">        r.run();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>DiscardPolicy — 啥也不干，默默地丢掉任务～不信你看</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">rejectedExecution</span><span class=\"params\">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>DiscardOldestPolicy — 丢弃掉队列中未执行的，最老的任务，也就是任务队列排头的任务，然后再试图在执行一次</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">rejectedExecution</span><span class=\"params\">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (!e.isShutdown()) &#123;</div><div class=\"line\">        e.getQueue().poll();</div><div class=\"line\">        e.execute(r);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>其实我不想做任何概念性的总结，原因是我之前没有开始学习源码的时候也看过很多源码分析的文章，大部分文章都会总结一些概念，这些概念本身可能是没有错的，起码是作者自己对源码的理解，但是文字所传达的思想真的是有限的，有时候因为概念的模糊，反而会被带入一个误区，并且长时间的无法转变。</p>\n<p>我自己一开始对线程池的理解其实是有偏差的，宏观上可能没有大的问题，但在细节上有很大的误区，通过自己耐心的阅读源码分析后学习到了很多东西。</p>\n<p>非要总结的话就给一点我阅读源码的小思路吧：</p>\n<ul>\n<li>一定要使用过，起码能完整的使用。如果没有用过很难把流程捋清楚</li>\n<li>从使用的角度作为突破口，一步步的去寻找线索</li>\n<li>一开始看不需要每一句都弄得很清楚，比如一个方法，应该先搞清楚这个方法里面做了几件事，核心的逻辑是什么</li>\n<li>在捋清了整体逻辑后，再去看细节上的实现</li>\n<li>实在无法理解的内容，再看看别人的文章，因为有了源码的基础，再看别人的文章能够有自己的思路</li>\n<li>与你的好基友探讨，你会发现每个人有不同的角度去理解源码，找到最合适你的那一种</li>\n</ul>\n<p>以上是我的一点拙见。</p>\n<p>最后感谢我的好基友  — <strong><a href=\"http://yongyu.itscoder.com/\" target=\"_blank\" rel=\"external\">阿语</a></strong>，在与他的探讨中我走出了误区并有了很多新的理解。</p>\n","categories":["Android源码学习"],"tags":[]},{"title":"Handler源码学习（三）MessageQueue入队插队","url":"https://joesteven.github.io/handler_source_3_MessageQueue/","content":"<p><a href=\"http://extremej.itscoder.com/handler_source_1/\" target=\"_blank\" rel=\"external\">Handler源码学习（一）流程</a><br><a href=\"http://extremej.itscoder.com/handler_source_2_Message/\" target=\"_blank\" rel=\"external\">Handler源码学习（二）Message对象池</a><br>Handler源码学习（三）MessageQueue入队插队</p>\n<h4 id=\"1-消息入队\"><a href=\"#1-消息入队\" class=\"headerlink\" title=\"1.消息入队\"></a>1.消息入队</h4><p>消息队列与Message对象池的结构很像，也是通过对象之间通过next指向形成链表结构</p>\n<p>这时候加入一个msg消息，先来看如果消息队列为空的情况</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//判断消息队列为空时，会直接将这个msg赋值给mMessage，并将p赋值给msg.next，这时next当然时null</span></div><div class=\"line\">msg.markInUse();</div><div class=\"line\">msg.when = when;</div><div class=\"line\">Message p = mMessages;</div><div class=\"line\"><span class=\"keyword\">boolean</span> needWake;</div><div class=\"line\"><span class=\"keyword\">if</span> (p == <span class=\"keyword\">null</span> || when == <span class=\"number\">0</span> || when &lt; p.when) &#123;</div><div class=\"line\">    <span class=\"comment\">// New head, wake up the event queue if blocked.</span></div><div class=\"line\">    msg.next = p;</div><div class=\"line\">    mMessages = msg;</div><div class=\"line\">    needWake = mBlocked;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>假设现在队列中已经有了两个消息，这两个消息的排练是按照执行时间，如果时间相同则是按照入队先后排列。来一步步分析，可以先看后面的图，把思路理清，再看源码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"comment\">// Inserted within the middle of the queue.  Usually we don't have to wake</span></div><div class=\"line\">    <span class=\"comment\">// up the event queue unless there is a barrier at the head of the queue</span></div><div class=\"line\">    <span class=\"comment\">// and the message is the earliest asynchronous message in the queue.</span></div><div class=\"line\">    needWake = mBlocked &amp;&amp; p.target == <span class=\"keyword\">null</span> &amp;&amp; msg.isAsynchronous();</div><div class=\"line\">  \t<span class=\"comment\">//首先声明了一个message对象prev，从字面意思理解是前一个message的意思</span></div><div class=\"line\">    Message prev;</div><div class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</div><div class=\"line\">      <span class=\"comment\">//接着进入一个死循环，将p赋值给prev，看看前面的代码可以知道，p指向的是mMessages,所以这里</span></div><div class=\"line\">      <span class=\"comment\">//是将prev指向了mMessage，再下一次循环的时候，prev则是指向了第二个message，依次类推</span></div><div class=\"line\">        prev = p;</div><div class=\"line\">      <span class=\"comment\">//接着将p指向p.next也就是mMessages.next,也就是消息链表中的第二个message</span></div><div class=\"line\">        p = p.next;</div><div class=\"line\">      <span class=\"comment\">//接下来判断两件事</span></div><div class=\"line\">      <span class=\"comment\">//1.p==null，说明没有下一个消息了，跳出循环</span></div><div class=\"line\">      <span class=\"comment\">//2.p!=null，并且当前需要入队的这个message的执行时间是小于队列中这个任务的执行时间的</span></div><div class=\"line\">      <span class=\"comment\">//也就是说这个入队的message需要比队列中的这个message先执行，也跳出循环</span></div><div class=\"line\">      <span class=\"comment\">//3.如果这两个条件都不满足的话，则继续跟队列中的下一个消息进行对比，直到满足条件，或者到</span></div><div class=\"line\">      <span class=\"comment\">//队列的末尾</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (p == <span class=\"keyword\">null</span> || when &lt; p.when) &#123;</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</div><div class=\"line\">            needWake = <span class=\"keyword\">false</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  <span class=\"comment\">//跳出循环后做了两件事情</span></div><div class=\"line\">  <span class=\"comment\">// 1.将入队的这个消息的next指向循环中获取到的应该排在这个消息之后的message</span></div><div class=\"line\">    msg.next = p; <span class=\"comment\">// invariant: p == prev.next</span></div><div class=\"line\">  <span class=\"comment\">//将msg前面那个message.next指向了msg</span></div><div class=\"line\">    prev.next = msg;</div><div class=\"line\">  <span class=\"comment\">//到这里就将一个message完成了入队</span></div><div class=\"line\">  <span class=\"comment\">//入队的过程是线程安全的</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1473110-cf3917ec68d63362.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"MessageQueue入队.jpg\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1473110-8d1085869f87c65b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"MessageQueue入队（2）.jpg\"></p>\n<h4 id=\"2-取出消息\"><a href=\"#2-取出消息\" class=\"headerlink\" title=\"2.取出消息\"></a>2.取出消息</h4><p>这里贴的不是完整代码，而是取出message的核心逻辑代码，这里其实分了两个部分，第一个部分是消息插队，这个在第三节叙述，第二个部分是正常的消息，其实取出消息的部分比较简单，注释也比较清晰</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</div><div class=\"line\">    <span class=\"comment\">// Try to retrieve the next message.  Return if found.</span></div><div class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> now = SystemClock.uptimeMillis();</div><div class=\"line\">    Message prevMsg = <span class=\"keyword\">null</span>;</div><div class=\"line\">  <span class=\"comment\">//队列的第一个message</span></div><div class=\"line\">    Message msg = mMessages;</div><div class=\"line\">  <span class=\"comment\">//正常取出消息</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (msg != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">      <span class=\"comment\">//1.首先判断当前时间是否小于了msg的执行时间，</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (now &lt; msg.when) &#123;</div><div class=\"line\">            <span class=\"comment\">// Next message is not ready.  Set a timeout to wake up when it is ready.</span></div><div class=\"line\">          <span class=\"comment\">//(翻译)需要执行的消息还没有到执行时间，设置一个唤醒时间，当到了执行时间时唤醒</span></div><div class=\"line\">            nextPollTimeoutMillis = (<span class=\"keyword\">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"comment\">// Got a message.正常取出消息，这里逻辑比较简单，不再赘述</span></div><div class=\"line\">            mBlocked = <span class=\"keyword\">false</span>;</div><div class=\"line\">            <span class=\"keyword\">if</span> (prevMsg != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                prevMsg.next = msg.next;</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                mMessages = msg.next;</div><div class=\"line\">            &#125;</div><div class=\"line\">            msg.next = <span class=\"keyword\">null</span>;</div><div class=\"line\">            <span class=\"keyword\">if</span> (DEBUG) Log.v(TAG, <span class=\"string\">\"Returning message: \"</span> + msg);</div><div class=\"line\">            msg.markInUse();</div><div class=\"line\">            <span class=\"keyword\">return</span> msg;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"comment\">// No more messages.</span></div><div class=\"line\">        nextPollTimeoutMillis = -<span class=\"number\">1</span>;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<h4 id=\"3-消息插队\"><a href=\"#3-消息插队\" class=\"headerlink\" title=\"3.消息插队\"></a>3.消息插队</h4><p>首先需要知道的是整个android系统其实主要是依赖消息机制来处理事件，比如说点击事件等等，都是通过handler发送消息进行处理，但是这些系统消息相较于程序自己发送的消息，应该要优先执行，所以就涉及到了消息插队</p>\n<ul>\n<li>isAsynchronous() — 如何将系统消息和程序发送的消息区分开来</li>\n</ul>\n<p>在阅读Hanlder的源码的时候，可以看到一个@hide的构造方法，传入一个布尔值，从字面意思理解是异步</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Handler</span><span class=\"params\">(<span class=\"keyword\">boolean</span> async)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>(<span class=\"keyword\">null</span>, async);</div><div class=\"line\">&#125;</div><div class=\"line\">mAsynchronous = async;<span class=\"comment\">//赋值给mAsychronous</span></div><div class=\"line\"><span class=\"comment\">//消息入队的时候，msg.setAsynchronous(true);将这个msg标记为异步</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">enqueueMessage</span><span class=\"params\">(MessageQueue queue, Message msg, <span class=\"keyword\">long</span> uptimeMillis)</span> </span>&#123;</div><div class=\"line\">        msg.target = <span class=\"keyword\">this</span>;</div><div class=\"line\">        <span class=\"keyword\">if</span> (mAsynchronous) &#123;</div><div class=\"line\">            msg.setAsynchronous(<span class=\"keyword\">true</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> queue.enqueueMessage(msg, uptimeMillis);</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>为什么要标记为异步呢？是要新开一个线程来执行么？可是最后也是发送到looper所绑定的消息队列中啊，貌似这里并没有异步，接着看上一节提到的消息插队的源码，在这里看到调用了一个方法msg.isAsynchronous()，貌似这个布尔值并不是跟异步有关系，而是将这个消息做了一个标记而已</p>\n<p>前面的消息入队分析可以知道，虽然被标记了系统消息，但是还是按照消息队列的规则去入队，那么如何做到优先取出这个任务呢，一步步看</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Message prevMsg = <span class=\"keyword\">null</span>;</div><div class=\"line\">Message msg = mMessages;</div><div class=\"line\"><span class=\"comment\">//1.判断当前第一个消息不为空</span></div><div class=\"line\"><span class=\"comment\">//2.重点来了,msg.target == null,如果这个消息的target为空，看过handler源码可以知道，</span></div><div class=\"line\"><span class=\"comment\">//只要是通过handler发送消息，就会将这个msg的target指向发送消息的handler，否则也无法处理这个消息</span></div><div class=\"line\"><span class=\"comment\">//那么为什么这里会出现target为空呢？先看if代码块里面的代码</span></div><div class=\"line\"><span class=\"keyword\">if</span> (msg != <span class=\"keyword\">null</span> &amp;&amp; msg.target == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">    <span class=\"comment\">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span></div><div class=\"line\">  \t<span class=\"comment\">//进入一个循环，注意while中的判断条件</span></div><div class=\"line\">    do &#123;</div><div class=\"line\">      </div><div class=\"line\">      <span class=\"comment\">//不断地取下一个消息来匹配判断条件</span></div><div class=\"line\">        prevMsg = msg;</div><div class=\"line\">        msg = msg.next;</div><div class=\"line\">    &#125; <span class=\"keyword\">while</span> (msg != <span class=\"keyword\">null</span> &amp;&amp; !msg.isAsynchronous());</div><div class=\"line\">  <span class=\"comment\">//只有当msg不为空 并且当前的这个消息是异步的，也就是说是系统消息，则跳出循环。</span></div><div class=\"line\">  <span class=\"comment\">//跳出循环后就走到了正常取消息的代码中，取出的正是这个系统消息，发现插队就成功了</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面的分析已经插队成功，但是还有疑点，到底是怎么进入到if代码块中的</p>\n<blockquote>\n<p>// Stalled by a barrier.  Find the next asynchronous message in the queue.</p>\n</blockquote>\n<p>作者在这里给了一条注释，通过一个阻塞块来停止正常的队列，找到队列中的第一个系统消息</p>\n<p>在MessageQueue中试图搜索barrier，发现一个方法，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">postSyncBarrier</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> postSyncBarrier(SystemClock.uptimeMillis());</div><div class=\"line\">    &#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">postSyncBarrier</span><span class=\"params\">(<span class=\"keyword\">long</span> when)</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// Enqueue a new sync barrier token.</span></div><div class=\"line\">    <span class=\"comment\">// We don't need to wake the queue because the purpose of a barrier is to stall it.</span></div><div class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> token = mNextBarrierToken++;</div><div class=\"line\">        <span class=\"keyword\">final</span> Message msg = Message.obtain();</div><div class=\"line\">        msg.markInUse();</div><div class=\"line\">        msg.when = when;</div><div class=\"line\">        msg.arg1 = token;</div><div class=\"line\"></div><div class=\"line\">        Message prev = <span class=\"keyword\">null</span>;</div><div class=\"line\">        Message p = mMessages;</div><div class=\"line\">      <span class=\"comment\">//判断将这个消息插入到队列中的哪个位置</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (when != <span class=\"number\">0</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">while</span> (p != <span class=\"keyword\">null</span> &amp;&amp; p.when &lt;= when) &#123;</div><div class=\"line\">                prev = p;</div><div class=\"line\">                p = p.next;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">if</span> (prev != <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// invariant: p == prev.next</span></div><div class=\"line\">            msg.next = p;</div><div class=\"line\">            prev.next = msg;</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            msg.next = p;</div><div class=\"line\">            mMessages = msg;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> token;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>加入队列的代码已经很熟悉了，可以看到在这段代码中其实入队了一个没有target的消息，而最上面那个public方法中可以看到传入的when是当前的系统时间，也就是说如果调用这个方法会在消息队列的头部插入一个没有target的message，到这里思路就比较清晰了，但是这个消息肯定不能一直在队列中，否则整个队列的正常消息就永远无法处理，所以相对应还有一个remove。注释中说明，这个方法应该跟插入的方法匹配使用。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">removeSyncBarrier</span><span class=\"params\">(<span class=\"keyword\">int</span> token)</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// Remove a sync barrier token from the queue.</span></div><div class=\"line\">    <span class=\"comment\">// If the queue is no longer stalled by a barrier then wake it.</span></div><div class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</div><div class=\"line\">        Message prev = <span class=\"keyword\">null</span>;</div><div class=\"line\">        Message p = mMessages;</div><div class=\"line\">        <span class=\"keyword\">while</span> (p != <span class=\"keyword\">null</span> &amp;&amp; (p.target != <span class=\"keyword\">null</span> || p.arg1 != token)) &#123;</div><div class=\"line\">            prev = p;</div><div class=\"line\">            p = p.next;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">if</span> (p == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"The specified message queue synchronization \"</span></div><div class=\"line\">                    + <span class=\"string\">\" barrier token has not been posted or has already been removed.\"</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> needWake;</div><div class=\"line\">        <span class=\"keyword\">if</span> (prev != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            prev.next = p.next;</div><div class=\"line\">            needWake = <span class=\"keyword\">false</span>;</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            mMessages = p.next;</div><div class=\"line\">            needWake = mMessages == <span class=\"keyword\">null</span> || mMessages.target != <span class=\"keyword\">null</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        p.recycleUnchecked();</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// If the loop is quitting then it is already awake.</span></div><div class=\"line\">        <span class=\"comment\">// We can assume mPtr != 0 when mQuitting is false.</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (needWake &amp;&amp; !mQuitting) &#123;</div><div class=\"line\">            nativeWake(mPtr);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>当发送系统消息时 会在消息队列中插入一个target为空的message，在取出消息时如果发现了这个消息，就跳过所有的正常消息，返回最近的一个系统消息，然后将这个标记消息从队列中remove。</p>\n<p>整个Handler源码学习系列笔记就完结了，当然现在也没有到特别深入的程度，但了解了整套Handler的消息机制后，相信对于源码的阅读能力和编程思路上也有挺大的提高。</p>\n","categories":["Android源码学习"],"tags":[]},{"title":"Handler源码学习（二）Message对象池","url":"https://joesteven.github.io/handler_source_2_Message/","content":"<p><a href=\"http://extremej.itscoder.com/handler_source_1/\" target=\"_blank\" rel=\"external\">Handler源码学习（一）流程</a><br>Handler源码学习（二）Message对象池<br><a href=\"http://extremej.itscoder.com/handler_source_3_MessageQueue/\" target=\"_blank\" rel=\"external\">Handler源码学习（三）MessageQueue入队插队</a><br>消息池是全系统共用，上限为50个</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MAX_POOL_SIZE = <span class=\"number\">50</span>;</div></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// sometimes we store linked lists of these things</span></div><div class=\"line\"><span class=\"comment\">/*package*/</span> Message next;</div><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Message sPool;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//假设现在消息池为空，从new message开始，到这个message被取出使用后，准备回收</span></div><div class=\"line\"><span class=\"comment\">//准备工作：拿到同步锁，避免线程不安全</span></div><div class=\"line\"><span class=\"comment\">//1.next ＝ sPool,因为池中是空的，所以此时sPool其实是null</span></div><div class=\"line\"><span class=\"comment\">//2.spool = this,将当前这个message作为池中下一个应该被复用的对象</span></div><div class=\"line\"><span class=\"comment\">//3.sPoolSize ++;将池子中的数量增加一，这个数量依然是全系统共享</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">recycleUnchecked</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">synchronized</span> (sPoolSync) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (sPoolSize &lt; MAX_POOL_SIZE) &#123;</div><div class=\"line\">                next = sPool;</div><div class=\"line\">                sPool = <span class=\"keyword\">this</span>;</div><div class=\"line\">                sPoolSize++;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"><span class=\"comment\">//上面已经回收了一个message，在这里来获取message，看看会发生什么</span></div><div class=\"line\"><span class=\"comment\">//同样进入同步代码块</span></div><div class=\"line\"><span class=\"comment\">//1.判断sPool是否是为空，如果池子为空，就直接new一个message</span></div><div class=\"line\"><span class=\"comment\">//上面已经回收过一个message了，这里应该不为空</span></div><div class=\"line\"><span class=\"comment\">//m ＝sPool；把池子里的这个message取出来</span></div><div class=\"line\"><span class=\"comment\">//2.sPool = m.next 将池中下一个复用的对象赋值为m.next,但是我们通过上面的代码发现这个是null，先</span></div><div class=\"line\"><span class=\"comment\">//不管</span></div><div class=\"line\"><span class=\"comment\">//3.将m.next置为空,m.flags = 0 给了一个标记使用中</span></div><div class=\"line\"><span class=\"comment\">//4.从池子中减去</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Message <span class=\"title\">obtain</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">synchronized</span> (sPoolSync) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (sPool != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            Message m = sPool;</div><div class=\"line\">            sPool = m.next;</div><div class=\"line\">            m.next = <span class=\"keyword\">null</span>;</div><div class=\"line\">            m.flags = <span class=\"number\">0</span>; <span class=\"comment\">// clear in-use flag</span></div><div class=\"line\">            sPoolSize--;</div><div class=\"line\">            <span class=\"keyword\">return</span> m;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Message();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面的过程只有一个mesage，详细解释一下sPool和next，将sPool看成一个指针，通过next来将对象组成了一个链表，因为每次只需要从池子里拿一个对象，所以不需要关心池子里具体有多少个对象，而是拿出当前这个sPool所指向的这个对象就可以了，sPool从思路上理解就是通过左右移动来完成复用和回收</p>\n<h4 id=\"Obtain-–-复用\"><a href=\"#Obtain-–-复用\" class=\"headerlink\" title=\"Obtain() – 复用\"></a>Obtain() – 复用</h4><p><img src=\"http://upload-images.jianshu.io/upload_images/1473110-2c0dcf654d397a72.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"MessageObtain(1).jpg\"></p>\n<p>当调用Obtain()的时候让sPool＝next，因为第一个message.next就等于第二个message，从图上看相当于sPool这个指针向后移动了一位，随后会将第一个message.next的值置为空</p>\n<p>如下图<br><img src=\"http://upload-images.jianshu.io/upload_images/1473110-600f714bdbc236f8.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"MessageObtain(2).jpg\"></p>\n<p>现在这个链表看上去就断了，如果in-use这个message使用完毕了，怎么回到链表中？</p>\n<h4 id=\"recycleUnchecked-–-回收\"><a href=\"#recycleUnchecked-–-回收\" class=\"headerlink\" title=\"recycleUnchecked() – 回收\"></a>recycleUnchecked() – 回收</h4><p>再看回收的方法中的代码，next ＝ sPool，将当前sPool所指向的message对象赋值给in－use的next，然后sPool = this，将sPool指向第一个message对象<br><img src=\"http://upload-images.jianshu.io/upload_images/1473110-3557f637c794f14b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"MessageRecycle.jpg\"></p>\n<p>这样，就将链表又恢复了～，而且不管是复用还是回收都是保证线程同步的，所以始终会形成一条链式结构</p>\n","categories":["Android源码学习"],"tags":[]},{"title":"Handler源码学习（一）流程","url":"https://joesteven.github.io/handler_source_1/","content":"<p>本系列笔记是我阅读Handler及相关类的源码时所记录的一些之前所不知道的知识点，该系列分为三部分，整体流程，Message对象回收原理，MessageQueue管理队列<br>Handler源码学习（一）流程<br><a href=\"http://extremej.itscoder.com/handler_source_2_Message/\" target=\"_blank\" rel=\"external\">Handler源码学习（二）Message对象池</a><br><a href=\"http://extremej.itscoder.com/handler_source_3_MessageQueue/\" target=\"_blank\" rel=\"external\">Handler源码学习（三）MessageQueue入队插队</a></p>\n<h4 id=\"1-创建handler-—-默认构造方法会获取当前线程的looper，也可以传入指定的looper\"><a href=\"#1-创建handler-—-默认构造方法会获取当前线程的looper，也可以传入指定的looper\" class=\"headerlink\" title=\"1.创建handler — 默认构造方法会获取当前线程的looper，也可以传入指定的looper\"></a>1.创建handler — 默认构造方法会获取当前线程的looper，也可以传入指定的looper</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * Default constructor associates this handler with the &#123;<span class=\"doctag\">@link</span> Looper&#125; for the</div><div class=\"line\"> * current thread.</div><div class=\"line\"> *</div><div class=\"line\"> * If this thread does not have a looper, this handler won't be able to receive messages</div><div class=\"line\"> * so an exception is thrown.</div><div class=\"line\"> */</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Handler</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>(<span class=\"keyword\">null</span>, <span class=\"keyword\">false</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Handler</span><span class=\"params\">(Callback callback, <span class=\"keyword\">boolean</span> async)</span> </span>&#123;</div><div class=\"line\">  \t\t<span class=\"comment\">//警告潜在内存泄漏风险</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (FIND_POTENTIAL_LEAKS) &#123;</div><div class=\"line\">            <span class=\"keyword\">final</span> Class&lt;? extends Handler&gt; klass = getClass();</div><div class=\"line\">          <span class=\"comment\">//如果是匿名类，内部类等等并且不是static 有内存泄露风险</span></div><div class=\"line\">            <span class=\"keyword\">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</div><div class=\"line\">                    (klass.getModifiers() &amp; Modifier.STATIC) == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">                Log.w(TAG, <span class=\"string\">\"The following Handler class should be static or leaks might occur: \"</span> +</div><div class=\"line\">                    klass.getCanonicalName());</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">\t\t<span class=\"comment\">//创建looper</span></div><div class=\"line\">        mLooper = Looper.myLooper();</div><div class=\"line\">        <span class=\"keyword\">if</span> (mLooper == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(</div><div class=\"line\">                <span class=\"string\">\"Can't create handler inside thread that has not called Looper.prepare()\"</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">        mQueue = mLooper.mQueue;</div><div class=\"line\">        mCallback = callback;</div><div class=\"line\">        mAsynchronous = async;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<h4 id=\"2-Looper\"><a href=\"#2-Looper\" class=\"headerlink\" title=\"2.Looper\"></a>2.Looper</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/** Initialize the current thread as a looper.</span></div><div class=\"line\">  * This gives you a chance to create handlers that then reference</div><div class=\"line\">  * this looper, before actually starting the loop. Be sure to call</div><div class=\"line\">  * &#123;<span class=\"doctag\">@link</span> #loop()&#125; after calling this method, and end it by calling</div><div class=\"line\">  * &#123;<span class=\"doctag\">@link</span> #quit()&#125;.</div><div class=\"line\">  */</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">prepare</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    prepare(<span class=\"keyword\">true</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//用ThreadLocal来存放looper 如果当前线程已经有一个looper则抛异常</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">prepare</span><span class=\"params\">(<span class=\"keyword\">boolean</span> quitAllowed)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (sThreadLocal.get() != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"Only one Looper may be created per thread\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    sThreadLocal.set(<span class=\"keyword\">new</span> Looper(quitAllowed));</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Looper</span><span class=\"params\">(<span class=\"keyword\">boolean</span> quitAllowed)</span> </span>&#123;</div><div class=\"line\">        mQueue = <span class=\"keyword\">new</span> MessageQueue(quitAllowed);</div><div class=\"line\">        mThread = Thread.currentThread();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//主线程的looper</span></div><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\">     * Initialize the current thread as a looper, marking it as an</div><div class=\"line\">     * application's main looper. The main looper for your application</div><div class=\"line\">     * is created by the Android environment, so you should never need</div><div class=\"line\">     * to call this function yourself.  See also: &#123;<span class=\"doctag\">@link</span> #prepare()&#125;</div><div class=\"line\">     */</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">prepareMainLooper</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        prepare(<span class=\"keyword\">false</span>);</div><div class=\"line\">        <span class=\"keyword\">synchronized</span> (Looper.class) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (sMainLooper != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"The main Looper has already been prepared.\"</span>);</div><div class=\"line\">            &#125;</div><div class=\"line\">            sMainLooper = myLooper();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"><span class=\"comment\">//构造方法，创建了一个消息队列</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Looper</span><span class=\"params\">(<span class=\"keyword\">boolean</span> quitAllowed)</span> </span>&#123;</div><div class=\"line\">        mQueue = <span class=\"keyword\">new</span> MessageQueue(quitAllowed);</div><div class=\"line\">        mThread = Thread.currentThread();</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<h4 id=\"3-sendMessage\"><a href=\"#3-sendMessage\" class=\"headerlink\" title=\"3.sendMessage\"></a>3.sendMessage</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">sendMessageAtTime</span><span class=\"params\">(Message msg, <span class=\"keyword\">long</span> uptimeMillis)</span> </span>&#123;</div><div class=\"line\">    MessageQueue queue = mQueue;</div><div class=\"line\">    <span class=\"keyword\">if</span> (queue == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        RuntimeException e = <span class=\"keyword\">new</span> RuntimeException(</div><div class=\"line\">                <span class=\"keyword\">this</span> + <span class=\"string\">\" sendMessageAtTime() called with no mQueue\"</span>);</div><div class=\"line\">        Log.w(<span class=\"string\">\"Looper\"</span>, e.getMessage(), e);</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> enqueueMessage(queue, msg, uptimeMillis);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//handler中将message添加到消息队列</span></div><div class=\"line\"><span class=\"comment\">//将这个message的target设置成当前的这个handler</span></div><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">enqueueMessage</span><span class=\"params\">(MessageQueue queue, Message msg, <span class=\"keyword\">long</span> uptimeMillis)</span> </span>&#123;</div><div class=\"line\">        msg.target = <span class=\"keyword\">this</span>;</div><div class=\"line\">        <span class=\"keyword\">if</span> (mAsynchronous) &#123;</div><div class=\"line\">            msg.setAsynchronous(<span class=\"keyword\">true</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> queue.enqueueMessage(msg, uptimeMillis);</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<h4 id=\"4-loop-—-取出消息\"><a href=\"#4-loop-—-取出消息\" class=\"headerlink\" title=\"4.loop() — 取出消息\"></a>4.loop() — 取出消息</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//target是handler，这里是个无限循环</span></div><div class=\"line\">msg.target.dispatchMessage(msg);</div></pre></td></tr></table></figure>\n<h4 id=\"5-dispatchMessage-—-分发消息\"><a href=\"#5-dispatchMessage-—-分发消息\" class=\"headerlink\" title=\"5.dispatchMessage() — 分发消息\"></a>5.dispatchMessage() — 分发消息</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//三种情况，</span></div><div class=\"line\"><span class=\"comment\">//第一种Message对象的callback不为空(runnable)，交给callback处理，第一种大多是使用post方法传入runnable对象时会调用</span></div><div class=\"line\"><span class=\"comment\">//第二种是handler的callback不为空，交给callback处理，callback</span></div><div class=\"line\"><span class=\"comment\">//前两种都没有的情况下交给handleMessag去处理</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">dispatchMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (msg.callback != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        handleCallback(msg);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (mCallback != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (mCallback.handleMessage(msg)) &#123;</div><div class=\"line\">                <span class=\"keyword\">return</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        handleMessage(msg);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">handleCallback</span><span class=\"params\">(Message message)</span> </span>&#123;</div><div class=\"line\">        message.callback.run();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Callback</span> </span>&#123;</div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span></span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"><span class=\"comment\">//Handler的callback可以在构造方法中传入</span></div><div class=\"line\"><span class=\"comment\">//Message的callback可以在obtain方法中作为参数传入，注意，一个消息被使用完毕后会被recycle，callback也会被移除，所以只能使用一次</span></div></pre></td></tr></table></figure>\n<h4 id=\"6-post-—-各种post方法\"><a href=\"#6-post-—-各种post方法\" class=\"headerlink\" title=\"6.post — 各种post方法\"></a>6.post — 各种post方法</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//注意传入的runnable的run方法会在handler所绑定的looper所在线程中执行，最终还是sendMessageDelayed()</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">post</span><span class=\"params\">(Runnable r)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">   <span class=\"keyword\">return</span>  sendMessageDelayed(getPostMessage(r), <span class=\"number\">0</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//不被推荐使用的方法,很容易导致消息队列清空，排序问题，以及其它副作用</span></div><div class=\"line\"><span class=\"comment\">//Posts a message to an object that implements Runnable.</span></div><div class=\"line\"><span class=\"comment\">//Causes the Runnable r to executed on the next iteration through the</span></div><div class=\"line\"><span class=\"comment\">//message queue.</span></div><div class=\"line\"><span class=\"comment\">//This method is only for use in very special circumstances -- it</span></div><div class=\"line\"><span class=\"comment\">//can easily starve the message queue, cause ordering problems, or have</span></div><div class=\"line\"><span class=\"comment\">//other unexpected side-effects.&lt;/b&gt;</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">sendMessageAtFrontOfQueue</span><span class=\"params\">(Message msg)</span> </span>&#123;</div><div class=\"line\">        MessageQueue queue = mQueue;</div><div class=\"line\">        <span class=\"keyword\">if</span> (queue == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            RuntimeException e = <span class=\"keyword\">new</span> RuntimeException(</div><div class=\"line\">                <span class=\"keyword\">this</span> + <span class=\"string\">\" sendMessageAtTime() called with no mQueue\"</span>);</div><div class=\"line\">            Log.w(<span class=\"string\">\"Looper\"</span>, e.getMessage(), e);</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> enqueueMessage(queue, msg, <span class=\"number\">0</span>);</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<h4 id=\"8-扩展\"><a href=\"#8-扩展\" class=\"headerlink\" title=\"8.扩展\"></a>8.扩展</h4><ul>\n<li>runOnUiThread()</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//如果当前线程是ui线程就直接调用run方法，如果不是当前线程则通过handler发送消息</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">runOnUiThread</span><span class=\"params\">(Runnable action)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (Thread.currentThread() != mUiThread) &#123;</div><div class=\"line\">        mHandler.post(action);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        action.run();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>view.post()</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//首先会判断这个view是否已经attach上了window，如果是的话会使用handler来发送消息</span></div><div class=\"line\"><span class=\"comment\">//否则会加入到消息队列中，等到attach了才会一次取出执行</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">post</span><span class=\"params\">(Runnable action)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">final</span> AttachInfo attachInfo = mAttachInfo;</div><div class=\"line\">    <span class=\"keyword\">if</span> (attachInfo != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> attachInfo.mHandler.post(action);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">// Assume that post will succeed later</span></div><div class=\"line\">    ViewRootImpl.getRunQueue().post(action);</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"7-收获\"><a href=\"#7-收获\" class=\"headerlink\" title=\"7.收获\"></a>7.收获</h4><p>1.looper是通过 ThreadLoacal来保存 ，保证looper只被创建一次，且跟当前线程绑定，一个looper。</p>\n<p>2.handler有多个构造方法，并不是必须要重写handleMessage方法，可以通过传入callback对象来处理消息，同时也可以给handler指定looper，因此handler可以给其它线程的looper发送消息。</p>\n<p>3.MessageQueue不由handler创建，而是从looper中获取，一个looper对应有一个MessageQueue，因此一个looper必然可以对应多个handler，它们都是往这同一个消息队列中发送消息而已</p>\n<p>4.Android中的主线程会调用Looper.prepareMainLooper() 方法来创建一个looper，因此不需要我们手动创建looper</p>\n<p>5.handler发送延迟消息时，是通过但前时间＋delayed时间，在某个时间去发送，因此如果在插入message时的时间是0，会容易导致排序问题</p>\n<p>6.每一个Activity在创建的时候其实就已经创建了一个handler，runOnUiThread方法中使用的就是这个handler</p>\n<p>7.view.post除了异步更新ui外还有一个作用，可以判断当前view是否已经attach window，在这个runnable任务被执行时，可以拿到尺寸等等，避免因为disattach造成异常</p>\n","categories":["Android源码学习"],"tags":[]},{"title":"关于我","url":"https://joesteven.github.io/about_me/","content":"<blockquote>\n<p>我常常也在想，我是谁？</p>\n</blockquote>\n<h3 id=\"About-Blog\"><a href=\"#About-Blog\" class=\"headerlink\" title=\"About Blog\"></a>About Blog</h3><p>我的英文名字是 Joe ,从初中开始吧，用了十多年，英文中有一个俗语</p>\n<blockquote>\n<p>average Joe — 最普通的人</p>\n</blockquote>\n<p>可我不想只做一个average Joe ，我想做到最好，对我而言的努力到极致，</p>\n<p>所以有了这个域名 extremej 代表 Extreme Joe</p>\n<p>本站内容主要是我的一些文章，有技术，也可能有生活</p>\n<h3 id=\"About-me\"><a href=\"#About-me\" class=\"headerlink\" title=\"About me\"></a>About me</h3><blockquote>\n<p>工科男，弹吉他，玩乐队，留长发，双子座 </p>\n<p>偶然接触编程，迷恋写代码</p>\n</blockquote>\n<p><strong>代码诚不欺我</strong></p>\n<p>现在的我是一名 Android 开发者，一个业余的摇滚乐手。</p>\n<p>我痴迷技术，也痴迷艺术。</p>\n<p>我希望有一天成为一个</p>\n<p>手艺人。</p>\n<h3 id=\"About-itsCoder\"><a href=\"#About-itsCoder\" class=\"headerlink\" title=\"About itsCoder\"></a>About itsCoder</h3><p>我是 itsCoder 的成员之一，itsCoder 致力于组员的学习督促，产出优质的技术文章，开源项目等等，希望为开源社区贡献一份力量，这里有各色老司机，开不同的车，奔向同一条路 — <strong>技术</strong></p>\n<p><a href=\"http://itscoder.com/\" target=\"_blank\" rel=\"external\">itsCoder</a></p>\n<h3 id=\"My-Works\"><a href=\"#My-Works\" class=\"headerlink\" title=\"My Works\"></a>My Works</h3><ul>\n<li><a href=\"http://www.coolapk.com/apk/com.joe.zatuji\" target=\"_blank\" rel=\"external\">杂图集</a> — 图片浏览应用，MVP+RxJava+Retrofit</li>\n</ul>\n<h3 id=\"Contact-Me\"><a href=\"#Contact-Me\" class=\"headerlink\" title=\"Contact Me\"></a>Contact Me</h3><ul>\n<li>Email：qiaoxiaoxi621@gmail.com </li>\n<li>微博：@Mobius_迷猫</li>\n</ul>\n","categories":["杂谈"],"tags":[]},{"title":"RxJava 源码学习笔记","url":"https://joesteven.github.io/rxjava_source/","content":"<p>转载请附原文链接： <a href=\"http://extremej.itscoder.com/rxjava_source/\" target=\"_blank\" rel=\"external\">RxJava 源码学习笔记</a></p>\n<p><a href=\"http://extremej.itscoder.com/how_to_use_rxjava/\" target=\"_blank\" rel=\"external\">RxJava 使用简介</a><br>学习了 RxJava有一段时间了，也在自己的项目中全面替换使用，整个项目的代码结构和质量确实有很大的改观，这么牛逼的一个框架，不仅要知其然，更要知其所以然。阅读源码学习原理也是很有必要的，这篇文章算是学习记录吧，圈内已有很多大神的文章深入分析了RxJava的原理，吾等小辈，不敢造次。</p>\n<p>如果你还在学习RxJava的使用，可以看看我上一篇文章，希望能有所帮助</p>\n<h4 id=\"一次完整订阅\"><a href=\"#一次完整订阅\" class=\"headerlink\" title=\"一次完整订阅\"></a>一次完整订阅</h4><p>observable被create创建的时候，传入一个OnSubscribe对象</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">Observable&lt;T&gt; <span class=\"title\">create</span><span class=\"params\">(OnSubscribe&lt;T&gt; f)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Observable&lt;T&gt;(hook.onCreate(f));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>至于这个hook，是RxJavaObservableExecutionHook，RxJavaPlugins中的一个类，用于插入一些你所需要的代码，记录，测试等，在默认的情况下，没有做任何事情,以下是官方文档给出的解释：</p>\n<blockquote>\n<p>This plugin allows you to register functions that RxJava will call upon certain regular RxJava activities, for instance for logging or metrics-collection purposes. </p>\n</blockquote>\n<p>所以目前不需要管这个钩子。在文章后面如果出现其他类型的hook不再作解释</p>\n<p>来看看OnSubscribe是个什么东西，继承了Action1接口，接口中只有一个方法call，这个方法什么时候被调用，我们慢慢来看。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * Invoked when Observable.subscribe is called.</div><div class=\"line\"> */</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">OnSubscribe</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">Action1</span>&lt;<span class=\"title\">Subscriber</span>&lt;? <span class=\"title\">super</span> <span class=\"title\">T</span>&gt;&gt; </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// cover for generics insanity</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们知道当调用了Observable的subscribe()方法后，Observable开始发送数据，那call应该就是在subscribe()时调用的，来看代码（onStart前面是判断参数为空抛异常的代码，没有放上来）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">Subscription <span class=\"title\">subscribe</span><span class=\"params\">(Subscriber&lt;? <span class=\"keyword\">super</span> T&gt; subscriber, Observable&lt;T&gt; observable)</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    subscriber.onStart();</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">if</span> (!(subscriber <span class=\"keyword\">instanceof</span> SafeSubscriber)) &#123;</div><div class=\"line\">        subscriber = <span class=\"keyword\">new</span> SafeSubscriber&lt;T&gt;(subscriber);</div><div class=\"line\">    &#125;</div><div class=\"line\">  </div><div class=\"line\">    <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">        hook.onSubscribeStart(observable, observable.onSubscribe).call(subscriber);</div><div class=\"line\">        <span class=\"keyword\">return</span> hook.onSubscribeReturn(subscriber);</div><div class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</div><div class=\"line\">        Exceptions.throwIfFatal(e);</div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">            subscriber.onError(hook.onSubscribeError(e));</div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable e2) &#123;</div><div class=\"line\">            Exceptions.throwIfFatal(e2);</div><div class=\"line\">            RuntimeException r = <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"Error occurred attempting to subscribe [\"</span> + e.getMessage() + <span class=\"string\">\"] and then again while trying to pass to onError.\"</span>, e2);</div><div class=\"line\">            hook.onSubscribeError(r);</div><div class=\"line\">            <span class=\"keyword\">throw</span> r;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> Subscriptions.unsubscribed();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>首先调用了Subscriber的onStart方法，我们的订阅前的准备代码就是在这里执行，接着判断subscriber是否是 SafeSubscriber的子类，如果不是的话，转成这个类，SafeSubscriber又是什么？</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&gt; SafeSubscriber is a wrapper around Subscriber that ensures that the Subscriber complies with the Observable contract</div><div class=\"line\">&gt; http://reactivex.io/documentation/contract.html</div><div class=\"line\">&gt;</div></pre></td></tr></table></figure>\n</blockquote>\n<p>简单翻译，是为了使 Subscriber遵守Observable的某种规则而进行的一次封装，保证onComplete和onError互斥，onNext在onComplete不再发送数据，对异常做了一些操作等等。</p>\n<p>接着往下看调用了OnSubscribe.call(),开始执行call中的代码，并且做了一些异常处理，返回一个Subscription对象用于管理这次订阅</p>\n<p>用过RxJava的同学应该知道，Subscriber是实现自Observer接口的抽象类，在subscribe时也可以就传入一个observer对象，其实RxJava还是会使用一个subscriber去订阅事件，然后将数据简单的向前传递给这个observer，其他的不同参数的subscribe都是同样的处理方式；</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Subscription <span class=\"title\">subscribe</span><span class=\"params\">(<span class=\"keyword\">final</span> Observer&lt;? <span class=\"keyword\">super</span> T&gt; observer)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (observer <span class=\"keyword\">instanceof</span> Subscriber) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> subscribe((Subscriber&lt;? <span class=\"keyword\">super</span> T&gt;)observer);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> subscribe(<span class=\"keyword\">new</span> Subscriber&lt;T&gt;() &#123;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"meta\">@Override</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCompleted</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">            observer.onCompleted();</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"meta\">@Override</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onError</span><span class=\"params\">(Throwable e)</span> </span>&#123;</div><div class=\"line\">            observer.onError(e);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"meta\">@Override</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onNext</span><span class=\"params\">(T t)</span> </span>&#123;</div><div class=\"line\">            observer.onNext(t);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>知道了一个完整订阅流程在内部时怎么实现的之后，我们来看一下通过其他的方法创建Observable进行发射数据有什么不同。</p>\n<ul>\n<li>just()<ul>\n<li>一个参数 </li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>多个参数 — 实际是执行了from()</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//一个参数</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">Observable&lt;T&gt; <span class=\"title\">just</span><span class=\"params\">(<span class=\"keyword\">final</span> T value)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> ScalarSynchronousObservable.create(value);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//ScalarSynchronousObservable的构造方法</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"title\">ScalarSynchronousObservable</span><span class=\"params\">(<span class=\"keyword\">final</span> T t)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>(<span class=\"keyword\">new</span> OnSubscribe&lt;T&gt;() &#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">(Subscriber&lt;? <span class=\"keyword\">super</span> T&gt; s)</span> </span>&#123;</div><div class=\"line\">                s.setProducer(createProducer(s, t));</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div><div class=\"line\">        <span class=\"keyword\">this</span>.t = t;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>一颗赛艇，重写了call方法，调用了subscriber.setProducer(),所以这是个什么方法？干什么用的？从方法名上理解，是给当前的 Subscriber设置了一个producer（提供者）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setProducer</span><span class=\"params\">(Producer p)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">long</span> toRequest;</div><div class=\"line\">    <span class=\"keyword\">boolean</span> passToSubscriber = <span class=\"keyword\">false</span>;</div><div class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</div><div class=\"line\">        toRequest = requested;</div><div class=\"line\">        producer = p;</div><div class=\"line\">        <span class=\"keyword\">if</span> (subscriber != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            <span class=\"comment\">// middle operator ... we pass thru unless a request has been made</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (toRequest == NOT_SET) &#123;</div><div class=\"line\">                <span class=\"comment\">// we pass-thru to the next producer as nothing has been requested</span></div><div class=\"line\">                passToSubscriber = <span class=\"keyword\">true</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">// do after releasing lock</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (passToSubscriber) &#123;</div><div class=\"line\">        subscriber.setProducer(producer);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"comment\">// we execute the request with whatever has been requested (or Long.MAX_VALUE)</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (toRequest == NOT_SET) &#123;</div><div class=\"line\">            producer.request(Long.MAX_VALUE);<span class=\"comment\">//执行到这句</span></div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            producer.request(toRequest);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>从上面的代码会执行到producer.request(Long.MAX_VALUE),Producer是一个接口，里面只有一个方法request(long n) — n 是你希望该Producer所提供数据数量的最大值，我们再回到just()中所用到的SingleProducer来看看它是怎么实现的</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**注意这里贴出的只是核心代码，并不是完整的源代码*/</span></div><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">request</span><span class=\"params\">(<span class=\"keyword\">long</span> n)</span> </span>&#123;</div><div class=\"line\">           <span class=\"keyword\">final</span> Subscriber&lt;? <span class=\"keyword\">super</span> T&gt; c = child;</div><div class=\"line\">           T v = value;</div><div class=\"line\">           <span class=\"comment\">// eagerly check for unsubscription</span></div><div class=\"line\">           <span class=\"keyword\">if</span> (c.isUnsubscribed()) &#123;</div><div class=\"line\">               <span class=\"keyword\">return</span>;</div><div class=\"line\">           &#125;</div><div class=\"line\">           <span class=\"comment\">// emit the value</span></div><div class=\"line\">           <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">               c.onNext(v);</div><div class=\"line\">           &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</div><div class=\"line\">               Exceptions.throwOrReport(e, c, v);</div><div class=\"line\">               <span class=\"keyword\">return</span>;</div><div class=\"line\">           &#125;</div><div class=\"line\">           <span class=\"comment\">// eagerly check for unsubscription</span></div><div class=\"line\">           <span class=\"keyword\">if</span> (c.isUnsubscribed()) &#123;</div><div class=\"line\">               <span class=\"keyword\">return</span>;</div><div class=\"line\">           &#125;</div><div class=\"line\">           <span class=\"comment\">// complete the child</span></div><div class=\"line\">           c.onCompleted();</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<p>这段代码看懂的难度不大</p>\n<ul>\n<li>from()</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">Observable&lt;T&gt; <span class=\"title\">from</span><span class=\"params\">(T[] array)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> n = array.length;</div><div class=\"line\">    <span class=\"keyword\">if</span> (n == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> empty();</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (n == <span class=\"number\">1</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> just(array[<span class=\"number\">0</span>]);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> create(<span class=\"keyword\">new</span> OnSubscribeFromArray&lt;T&gt;(array));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>from方法传入一个数组，如果数组长度为0，则返回empty()— 一个不发射数据的Observable,如果数组只有一个元素，就返回just方法创建的Observable，我们稍后看just，最后一句代码，create时创建了一个OnSubscribeFromArray对象，这个类是OnSubscribe的一个实现类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">(Subscriber&lt;? <span class=\"keyword\">super</span> T&gt; child)</span> </span>&#123;</div><div class=\"line\">    child.setProducer(<span class=\"keyword\">new</span> FromArrayProducer&lt;T&gt;(child, array));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>同just()一样也是通过setProducer的方法来发射数据，但是FromArrayProducer的request()方法里面用到了一个BackpressureUtils来处理，关于<a href=\"http://www.dundunwen.com/article/275b1d92-f9da-4bb8-b111-3aa8a6ace245.html\" target=\"_blank\" rel=\"external\">Backpressure</a> ，大概是一种处理堆积消息的策略，有兴趣的可以看看这篇文章。</p>\n<h4 id=\"Observable的转换-—-lift-compose\"><a href=\"#Observable的转换-—-lift-compose\" class=\"headerlink\" title=\"Observable的转换 — lift(),compose()\"></a>Observable的转换 — lift(),compose()</h4><ul>\n<li><p>map()</p>\n<p>先从我们最熟悉的操作符map开始，map实际调用了一个方法lift()</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> &lt;R&gt; <span class=\"function\">Observable&lt;R&gt; <span class=\"title\">map</span><span class=\"params\">(Func1&lt;? <span class=\"keyword\">super</span> T, ? extends R&gt; func)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> lift(<span class=\"keyword\">new</span> OperatorMap&lt;T, R&gt;(func));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>flatMap()</p>\n<p>然后来看看flatMap(),调用了merge()，传入了一个参数lift()</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> &lt;U, R&gt; <span class=\"function\">Observable&lt;R&gt; <span class=\"title\">flatMap</span><span class=\"params\">(<span class=\"keyword\">final</span> Func1&lt;? <span class=\"keyword\">super</span> T, ? extends Observable&lt;? extends U&gt;&gt; collectionSelector,</span></span></div><div class=\"line\">        <span class=\"keyword\">final</span> Func2&lt;? <span class=\"keyword\">super</span> T, ? <span class=\"keyword\">super</span> U, ? extends R&gt; resultSelector) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> merge(lift(<span class=\"keyword\">new</span> OperatorMapPair&lt;T, U, R&gt;(collectionSelector, resultSelector)));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>merge()</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">Observable&lt;T&gt; <span class=\"title\">merge</span><span class=\"params\">(Observable&lt;? extends Observable&lt;? extends T&gt;&gt; source)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (source.getClass() == ScalarSynchronousObservable.class) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> ((ScalarSynchronousObservable&lt;T&gt;)source).scalarFlatMap((Func1)UtilityFunctions.identity());</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> source.lift(OperatorMerge.&lt;T&gt;instance(<span class=\"keyword\">false</span>));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>merge中也调用了lift()函数，实际上大部分对Observable进行操作的操作符几乎都是用到了这个函数，那么我们来看看lift()到底做了什么</p>\n</li>\n<li><p><strong>lift()</strong> </p>\n<blockquote>\n<p>Lifts a function to the current Observable and returns a new Observable that when subscribed to will pass  the values of the current Observable through the Operator function.</p>\n</blockquote>\n<p>源码中的注释，简单翻译一下，这段话大概的意思是按照这个操作符的规则来将当前的Observable替换为一个新的Observable</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//部分注释被删掉了</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> &lt;R&gt; <span class=\"function\">Observable&lt;R&gt; <span class=\"title\">lift</span><span class=\"params\">(<span class=\"keyword\">final</span> Operator&lt;? extends R, ? <span class=\"keyword\">super</span> T&gt; operator)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Observable&lt;R&gt;(<span class=\"keyword\">new</span> OnSubscribe&lt;R&gt;() &#123;</div><div class=\"line\">        <span class=\"meta\">@Override</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">(Subscriber&lt;? <span class=\"keyword\">super</span> R&gt; o)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                Subscriber&lt;? <span class=\"keyword\">super</span> T&gt; st = hook.onLift(operator).call(o);</div><div class=\"line\">                <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">      <span class=\"comment\">// new Subscriber created and being subscribed with so 'onStart' it</span></div><div class=\"line\">                    st.onStart();</div><div class=\"line\">                    onSubscribe.call(st);</div><div class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</div><div class=\"line\">                    Exceptions.throwIfFatal(e);</div><div class=\"line\">                    st.onError(e);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</div><div class=\"line\">                Exceptions.throwIfFatal(e);</div><div class=\"line\">                o.onError(e);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这段代码乍一看一脸懵逼，我们先看看Operator是个什么鬼</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Operator</span>&lt;<span class=\"title\">R</span>, <span class=\"title\">T</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">Func1</span>&lt;<span class=\"title\">Subscriber</span>&lt;? <span class=\"title\">super</span> <span class=\"title\">R</span>&gt;, <span class=\"title\">Subscriber</span>&lt;? <span class=\"title\">super</span> <span class=\"title\">T</span>&gt;&gt; </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// cover for generics insanity</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Operator接口继承自Func1接口，做了一件事情，将泛型指定为两个Subscriber,这时候我们再去看lift中的代码，好像明白怎么回事了</p>\n<p>首先new了一个新的OnSubscribe对象，泛型指定为转换后的数据类型，注意了，<strong>operator.call返回了一个Subscriber对象，泛型是原始的Observable所发射的数据，然后调用了原始的Observable中的onSubscribe.call()将数据发射出去</strong>。</p>\n<p>原始的数据发射到哪儿去了呢？来看OperatorMap中的代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OperatorMap</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">R</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Operator</span>&lt;<span class=\"title\">R</span>, <span class=\"title\">T</span>&gt; </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">final</span> Func1&lt;? <span class=\"keyword\">super</span> T, ? extends R&gt; transformer;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">OperatorMap</span><span class=\"params\">(Func1&lt;? <span class=\"keyword\">super</span> T, ? extends R&gt; transformer)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.transformer = transformer;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"keyword\">public</span> Subscriber&lt;? <span class=\"keyword\">super</span> T&gt; call(<span class=\"keyword\">final</span> Subscriber&lt;? <span class=\"keyword\">super</span> R&gt; o) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Subscriber&lt;T&gt;(o) &#123;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCompleted</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">                o.onCompleted();</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onError</span><span class=\"params\">(Throwable e)</span> </span>&#123;</div><div class=\"line\">                o.onError(e);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onNext</span><span class=\"params\">(T t)</span> </span>&#123;</div><div class=\"line\">                <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                    o.onNext(transformer.call(t));</div><div class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</div><div class=\"line\">                    Exceptions.throwOrReport(e, <span class=\"keyword\">this</span>, t);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">        &#125;;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我看到这段代码的时候有种醍醐灌顶的感觉啊，是不是很6，subscriber将数据传递给transformer，让我们在Func1中处理相关逻辑</p>\n</li>\n</ul>\n<p>关于lift的原理，看看扔物线大神的文章<a href=\"http://gank.io/post/560e15be2dca930e00da1083#toc_19\" target=\"_blank\" rel=\"external\">变换的原理</a> ,里面的图解很好的解释了lift的流程</p>\n<ul>\n<li>compose() — 上一篇用法学习的时候已经讲过，不再赘述，<a href=\"http://extremej.itscoder.com/how_to_use_rxjava/\" target=\"_blank\" rel=\"external\">传送门</a> </li>\n</ul>\n<h4 id=\"线程转换\"><a href=\"#线程转换\" class=\"headerlink\" title=\"线程转换\"></a>线程转换</h4><p>线程转换的原理其实也是使用lift()去转换，关于流程原理可以参考<a href=\"http://gank.io/post/560e15be2dca930e00da1083#toc_22\" target=\"_blank\" rel=\"external\">Scheduler的原理</a>,线程转换的内部实现，代码较多，打算放到下一篇文章中，专门分析学习。</p>\n","categories":["Android源码学习"],"tags":[]},{"title":"RxJava 使用简介","url":"https://joesteven.github.io/how_to_use_rxjava/","content":"<p>注：本系列文章主要用于博主个人学习记录，本文末尾附上了一些较好的文章提供学习。<br>转载请附原文链接： <a href=\"http://extremej.itscoder.com/how_to_use_rxjava/\" target=\"_blank\" rel=\"external\">RxJava 使用简介</a><br>如果你对 RxJava 的原理感兴趣，可以看看下面这篇文章<br><a href=\"http://extremej.itscoder.com/rxjava_source/\" target=\"_blank\" rel=\"external\">RxJava 源码学习笔记</a></p>\n<p>RxJava利用响应式编程思想，专注于异步任务的处理，通过操作符进行流式操作，可以极大的去除多层嵌套，达到逻辑的简洁明了。</p>\n<p>举个栗子🌰 </p>\n<p><img src=\"/img/RxJava栗子.jpg\" alt=\"模拟用户登陆注册\"></p>\n<p>RxJava的观察者模式与普通观察者模式有一个区别是分为“冷”启动和“热”启动，“热”启动即不管有没有观察者，观察者会按照自己的逻辑发送数据，而“冷”启动则是只有当观察者开启订阅时才开始发送数据。</p>\n<h3 id=\"基本概念及用法\"><a href=\"#基本概念及用法\" class=\"headerlink\" title=\"基本概念及用法\"></a>基本概念及用法</h3><ul>\n<li><p>三个重要的对象</p>\n<ul>\n<li>Observable-数据发送者</li>\n<li>Subscriber-订阅者</li>\n<li>OnSubscribe-事件</li>\n</ul>\n<p>一次事件订阅的流程：Observable持有一个 OnSubscribe对象，事件在OnSubscribe对象中被执行，当有Subscriber订阅了这个 Observable时，OnSubscribe中的事件开始执行，并由Observable发射数据给Subscriber </p>\n</li>\n</ul>\n<p><img src=\"/img/RxJava一次完整订阅.jpg\" alt=\"一次完整订阅\"></p>\n<ul>\n<li><p>Subscriber对象</p>\n<p>Subscriber是一个抽象类，需要实现三个方法</p>\n<blockquote>\n<ul>\n<li><code>onCompleted()</code>: 事件队列完结。RxJava 不仅把每个事件单独处理，还会把它们看做一个队列。RxJava 规定，当不会再有新的<code>onNext()</code> 发出时，需要触发 <code>onCompleted()</code> 方法作为标志。</li>\n<li><code>onError()</code>: 事件队列异常。在事件处理过程中出异常时，<code>onError()</code> 会被触发，同时队列自动终止，不允许再有事件发出。</li>\n<li>在一个正确运行的事件序列中, <code>onCompleted()</code> 和 <code>onError()</code> 有且只有一个，并且是事件序列中的最后一个。需要注意的是，<code>onCompleted()</code> 和 <code>onError()</code> 二者也是互斥的，即在队列中调用了其中一个，就不应该再调用另一个。</li>\n</ul>\n<p>引用自扔物线</p>\n</blockquote>\n<p><strong>在代码中调用了onComplete后再调用onNext，依然可以发送数据，onComplete会在发送完所有的数据后才被调用</strong> </p>\n<p><strong>当onError被调用了，即使在出现错误之前调用onNext依然不会成功，只会触发onError</strong></p>\n<p>​</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Subscriber&lt;String&gt; subscriber = <span class=\"keyword\">new</span> Subscriber&lt;String&gt;() &#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCompleted</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t\t\t<span class=\"comment\">//数据发送完毕</span></div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onError</span><span class=\"params\">(Throwable e)</span> </span>&#123;</div><div class=\"line\">\t\t\t\t<span class=\"comment\">//数据发送出错</span></div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onNext</span><span class=\"params\">(String data)</span> </span>&#123;</div><div class=\"line\">\t\t\t\t<span class=\"comment\">//数据发送成功</span></div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;;</div></pre></td></tr></table></figure>\n<p>通过泛型指定Subscriber所能接收的数据，在onNext 中处理相应的逻辑，此处需要注意的是： <strong>onNext方法调用的次数取决于OnSubscribe中被调用的次数</strong> </p>\n<ul>\n<li><p>Action1<t></t></p>\n<p>在某些情况下我们不需要在每一个回调中都处理逻辑，可能只需要订阅onNext，就可以实现Action1<t></t></p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> Action1&lt;Object&gt;() &#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">(Object obj)</span> </span>&#123;</div><div class=\"line\">              <span class=\"comment\">//有参数的回调onError和onNext</span></div><div class=\"line\">            &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"keyword\">new</span> Action0()&#123;</div><div class=\"line\">  \t<span class=\"meta\">@override</span></div><div class=\"line\">  \t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">  \t\t<span class=\"comment\">//onComplete</span></div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n</li>\n<li><p>Observable对象</p>\n<ul>\n<li>Observable.create(OnSubscribe<t> onSubscribe);</t></li>\n</ul>\n<p>create方法传入一个OnSubscribe对象，在call方法中发送数据，这是最基础的创建方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Observable.create(<span class=\"keyword\">new</span> Observable.OnSubscribe&lt;String&gt;() &#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">(Subscriber&lt;? <span class=\"keyword\">super</span> String&gt; subscriber)</span> </span>&#123;</div><div class=\"line\">                subscriber.onNext(<span class=\"string\">\"create success\"</span>);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div></pre></td></tr></table></figure>\n<ul>\n<li>Observable.just（ T1 t1, T2 t2, T3 t3,…)</li>\n</ul>\n<p>just方法允许快速创建队列，每一个参数会调用onNext方法传递一次(最多10个），且按顺序发送,just在发送完数据后，会调用onComplete</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Observable.just(<span class=\"string\">\"one\"</span>,<span class=\"string\">\"two\"</span>,<span class=\"string\">\"three\"</span>);</div></pre></td></tr></table></figure>\n<ul>\n<li>from</li>\n</ul>\n<p>from可以将数组,Iterable,Future对象转换为 Observable对象，发送数据</p>\n<blockquote>\n<ul>\n<li>Javadoc: <a href=\"http://reactivex.io/RxJava/javadoc/rx/Observable.html#from(T%5B%5D\" target=\"_blank\" rel=\"external\">from(array)</a>)</li>\n<li>Javadoc: <a href=\"http://reactivex.io/RxJava/javadoc/rx/Observable.html#from(java.lang.Iterable\" target=\"_blank\" rel=\"external\">from(Iterable)</a>)</li>\n<li>Javadoc: <a href=\"http://reactivex.io/RxJava/javadoc/rx/Observable.html#from(java.util.concurrent.Future\" target=\"_blank\" rel=\"external\">from(Future)</a>)</li>\n<li>Javadoc: <a href=\"http://reactivex.io/RxJava/javadoc/rx/Observable.html#from(java.util.concurrent.Future,%20rx.Scheduler\" target=\"_blank\" rel=\"external\">from(Future,Scheduler)</a>)</li>\n<li>Javadoc: <a href=\"http://reactivex.io/RxJava/javadoc/rx/Observable.html#from(java.util.concurrent.Future,%20long,%20java.util.concurrent.TimeUnit\" target=\"_blank\" rel=\"external\">from(Future,timeout, timeUnit)</a>)</li>\n</ul>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">String [] array = <span class=\"keyword\">new</span> String[]&#123;<span class=\"string\">\"one-from\"</span>,<span class=\"string\">\"two-from\"</span>,<span class=\"string\">\"three-from\"</span>&#125;;</div><div class=\"line\">Observable.from(array);</div></pre></td></tr></table></figure>\n<p>创建一个Observable的方法有很多，不一一列举<br><img src=\"/img/创建Observable.jpg\" alt=\"创建Observable\"></p>\n</li>\n</ul>\n<ul>\n<li><p>订阅事件</p>\n<ul>\n<li>Observable.subcribe()－－return   Subscription;</li>\n</ul>\n<p>通过subscribe来开启订阅，此时Observable开始发送数据，并且返回一个Subscription对象</p>\n<ul>\n<li>Subscription</li>\n</ul>\n<p>Subscription是一个接口，有两个方法unsubscribe()和isUnsubscribe(),在订阅事件时返回这个对象，可以在需要的时候取消掉订阅，在android开发中能简单有效的避免内存溢出。</p>\n</li>\n</ul>\n<h3 id=\"线程控制\"><a href=\"#线程控制\" class=\"headerlink\" title=\"线程控制\"></a>线程控制</h3><p>上面所提到的订阅会默认在当前线程中执行，然并卵，既然是专注于异步操作，就一定有线程控制的方法</p>\n<ul>\n<li>Schedulers—线程调度<br><img src=\"/img/RxJava各种线程.jpg\" alt=\"Sckedulers的各种线程\"></li>\n</ul>\n<ul>\n<li><p>subscribeOn—被观察事件执行线程（事实上，在该方法调用之前，以及调用后，observeOn之前的代码都会在subscribeOn所在的线程中执行）</p>\n</li>\n<li><p>observeOn— 观察线程（可以多次转换，observeOn指定在它之后的代码线程）</p>\n</li>\n<li><p>实践</p>\n<p>该方法只应该被调用一次，如果调用多次，只有第一个会生效 !<br><img src=\"/img/多次调用subscribeOn.jpg\" alt=\"多次调用subscribeOn\"></p>\n</li>\n</ul>\n<p>  如上图，首先指定了subscribeOn的线程为io线程，然后又指定了计算线程，打印日志<br><img src=\"/img/logcat1.jpg\" alt=\"logcat 1\"></p>\n<p>通过日志打印可以发现，只有第一个subscribeOn生效，并且在observeOn之前的代码也都在io线程中执行，而在observeOn之后的代码，在每一次调用该方法后都改变了线程</p>\n<p>有好事的同学说了，那如果我先调用observeOn再调用subscribeOn呢？虽然没有人这么做，但严谨的我还是要试试<br><img src=\"/img/observerOn.jpg\" alt=\"observeOn\"></p>\n<p>先调用observeOn指定为主线程，然后subscribeOn指定为ui线程<br><img src=\"/img/logcat2.jpg\" alt=\"logcat 2\"></p>\n<p>可以看到第一条日志在io线程中执行，而第二条日志在主线程中，似乎可以得到一个结论</p>\n<p><strong>observeOn指定在它之后的代码的执行线程，而其余代码均在第一个subscribeOn指定的线程中执行</strong></p>\n<h3 id=\"操作符\"><a href=\"#操作符\" class=\"headerlink\" title=\"操作符\"></a>操作符</h3><h4 id=\"A-转换操作\"><a href=\"#A-转换操作\" class=\"headerlink\" title=\"A.转换操作\"></a>A.转换操作</h4><ul>\n<li><p>map()— 将发射的数据转化为subscriber所需要的数据</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Observable.create(<span class=\"keyword\">new</span> Observable.OnSubscribe&lt;Integer&gt;() &#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">(Subscriber&lt;? <span class=\"keyword\">super</span> Integer&gt; subscriber)</span> </span>&#123;</div><div class=\"line\">                subscriber.onNext(random());</div><div class=\"line\">                subscriber.onCompleted();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;).map(<span class=\"keyword\">new</span> Func1&lt;Integer, String&gt;() &#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">call</span><span class=\"params\">(Integer integer)</span></span>&#123;</div><div class=\"line\">                <span class=\"keyword\">if</span>(integer == <span class=\"number\">0</span>)&#123;</div><div class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"string\">\"the number is 1\"</span>;</div><div class=\"line\">                &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"string\">\"the number is not 1\"</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div></pre></td></tr></table></figure>\n<p>栗子中的代码是在原始的Observable中发射类型为Integer的数据，通过map操作后，subscriber所接收到的数据为 String 类型，map中需要传入Fun1<t,e>,参数1表示<strong>上一个操作符操作后所发送的数据</strong>，一个Observable可以进行多次转化操作，subscriber接收到的数据为最后一次转化发射的数据。</t,e></p>\n<p><strong>注意：map操作转换的是发射的数据，Observable本身并不会被转换</strong></p>\n</li>\n</ul>\n<ul>\n<li><p>flatmap()— 将一个Observable转换为一个新的Observable，并且由这个新的Observable发射数据</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Observable.create(<span class=\"keyword\">new</span> Observable.OnSubscribe&lt;Integer&gt;() &#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">(Subscriber&lt;? <span class=\"keyword\">super</span> Integer&gt; subscriber)</span> </span>&#123;</div><div class=\"line\">                subscriber.onNext(random());</div><div class=\"line\">                subscriber.onCompleted();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;).flatMap(<span class=\"keyword\">new</span> Func1&lt;Integer, Observable&lt;String&gt;&gt;() &#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> Observable&lt;String&gt; <span class=\"title\">call</span><span class=\"params\">(Integer integer)</span> </span>&#123;</div><div class=\"line\">                <span class=\"keyword\">return</span> Observable.just(<span class=\"string\">\"new Observable\"</span>+integer);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div></pre></td></tr></table></figure>\n<p>flatMap 同样需要传入Func1<t,e> 与map不同的是，返回的是一个Observable对象，而subscriber所订阅的应该是这个新的Observable，flatmap也可以多次调用多次转换，问题来了～subscriber只关心接收到的数据，并不关心订阅的具体是哪一个Observable，那flatMap和map的应用场景是什么呢？</t,e></p>\n</li>\n<li><p>应用场景</p>\n<ul>\n<li><p>map比较简单，一个Observable可能被多个subscriber订阅，而不同的订阅所需要的最终数据不同，但事件的操作逻辑是相同的，就可以利用map来满足不同的数据需求</p>\n</li>\n<li><p>flatmap的用处就比较多了，文章最开头举的栗子，一次复杂的注册逻辑，首先要请求服务器获取token，获取token后注册请求，注册请求完成后，登录请求，每一次请求利用Retrofit封装返回一个 Observable对象.我们只关心最后登录成功后告知用户，并刷新UI。这样原本用回调至少嵌套两次的逻辑，变得清晰明了（这样的注册逻辑本身是有问题的～）</p>\n<p><img src=\"/img/RxJava栗子.jpg\" alt=\"模拟一次注册请求\"></p>\n</li>\n</ul>\n</li>\n</ul>\n<p><strong>注意：只有每一个Observable都成功发射数据后，才会调用onNext方法，如果出现异常会直接调用onError</strong></p>\n<p>这样看来，好像很鸡肋，后面会讲到错误操作，你会发现RxJava确实是很牛逼的啊～</p>\n<ul>\n<li>其它转换操作<br><img src=\"/img/转换操作符.jpg\" alt=\"转换操作符\"></li>\n</ul>\n<h4 id=\"B-合并操作\"><a href=\"#B-合并操作\" class=\"headerlink\" title=\"B.合并操作\"></a>B.合并操作</h4><ul>\n<li><p>merge— 将多个Observable合并为一个Observable发射数据</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Observable.merge(observable1,observable2,observable3,observable4);</div></pre></td></tr></table></figure>\n<p>官方文档说明：merge可能会导致交错发射数据，即不是按照合并顺序来发射数据</p>\n<p><strong>同样，一旦有一个Observable发射异常，会立即触发onError，RxJava的实现中有一个mergeDelayError— 只有当所有的数据都发射完毕后才会调用onError</strong></p>\n</li>\n<li><p>concat— 将多个Observable合并为一个Observable并且按顺序发射数据</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Observable.concat(observable1,observable2,observable3,observable4)</div></pre></td></tr></table></figure>\n</li>\n<li><p>zip— 将多个Observables的发射物结合到一起，基于这个函数的结果为每个结合体发射单个数据项。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Observable.zip(</div><div class=\"line\">                Observable.just(<span class=\"string\">\"1\"</span>), </div><div class=\"line\">                Observable.just(<span class=\"string\">\"2\"</span>), </div><div class=\"line\">                Observable.just(<span class=\"string\">\"3\"</span>), </div><div class=\"line\">                Observable.just(<span class=\"string\">\"4\"</span>), </div><div class=\"line\">                <span class=\"keyword\">new</span> Func4&lt;String, String, String, String, String&gt;() &#123;</div><div class=\"line\">                    <span class=\"meta\">@Override</span></div><div class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">call</span><span class=\"params\">(String s, String s2, String s3, String s4)</span> </span>&#123;</div><div class=\"line\">                        <span class=\"keyword\">return</span> s+s2+s3+s4;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;);</div></pre></td></tr></table></figure>\n<p>zip传入需要合并的Observable对象，以及  Func4<t,...,object>,与merge不同的是，zip是将所有发射的数据拿到后，进行整合，最后发射这个整合后的数据。call中的参数是严格按照合并顺序所发射的数据，return的即为最终发射的数据</t,...,object></p>\n<p><strong>zip的不仅可以合并发射源，并且可以根据需要转换最终发射的数据类型</strong></p>\n</li>\n</ul>\n<h4 id=\"C-过滤操作\"><a href=\"#C-过滤操作\" class=\"headerlink\" title=\"C.过滤操作\"></a>C.过滤操作</h4><p>假设这样一种场景，加载数据的时候先向服务器请求，如果成功就显示，如果失败就查找缓存数据。很容易想到可以利用合并操作符来处理，但是合并操作会依次发射数据，这不是我们所希望的。这里就需要用的过滤操作了</p>\n<ul>\n<li><p>filter — 只发射通过了谓词测试的数据项</p>\n<p>filter根据规则去检验数据，只要通过了检验的数据都会被发射，直到检验完最后一个 Observable</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">.filter(<span class=\"keyword\">new</span> Func1&lt;Integer, Boolean&gt;() &#123;</div><div class=\"line\">                    <span class=\"meta\">@Override</span></div><div class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> Boolean <span class=\"title\">call</span><span class=\"params\">(Integer i)</span> </span>&#123;</div><div class=\"line\">                      <span class=\"comment\">//只发射小于等于5的数据</span></div><div class=\"line\">                    \t<span class=\"keyword\">return</span> i&lt;=<span class=\"number\">5</span>;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;)</div></pre></td></tr></table></figure>\n</li>\n<li><p>first — 只发射第一项（或者满足某个条件的第一项）数据</p>\n<p>first类似于filter，不同的是，只发射第一个通过检验的数据</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">first()<span class=\"comment\">//只发射第一个数据</span></div><div class=\"line\">first(Func1)<span class=\"comment\">//满足某个条件的第一个发射成功的数据</span></div><div class=\"line\">.first(<span class=\"keyword\">new</span> Func1&lt;String, Boolean&gt;() &#123;</div><div class=\"line\">                    <span class=\"meta\">@Override</span></div><div class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> Boolean <span class=\"title\">call</span><span class=\"params\">(String s)</span> </span>&#123;</div><div class=\"line\">                        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;)</div></pre></td></tr></table></figure>\n<p>所有发射的数据，会在call中按照规则进行检验，比如当第一个传过来的字符串不为空时，就认为发射数据成功，那么应该return true，当return为true的时候会调用onNext方法，而还没有发射数据的Observable将不再发射数据，如果return为false，那么会依次检验后面的Observable是否发射数据成功，直到return true或者全部不符合调onError</p>\n</li>\n<li><p>last — 只发射最后一条（或者满足某个条件的最后一项）数据</p>\n<p>last的用法跟frist一毛一样。</p>\n</li>\n<li><p>其它过滤操作<br><img src=\"/img/过滤操作符.jpg\" alt=\"过滤操作符\"></p>\n<h4 id=\"D-异常处理\"><a href=\"#D-异常处理\" class=\"headerlink\" title=\"D.异常处理\"></a>D.异常处理</h4><p><img src=\"/img/异常处理.jpg\" alt=\"异常处理\"></p>\n</li>\n</ul>\n<p>onErrorReturn可以在异常发生时发射一个默认的数据，结合过滤操作，可以发射一个不符合规则的数据，避免中断数据发射</p>\n<h4 id=\"E-doOn\"><a href=\"#E-doOn\" class=\"headerlink\" title=\"E.doOn\"></a>E.doOn</h4><p>有一种场景，比如说请求到数据后写入缓存，但是不希望订阅者去处理，因为如果多处订阅必然会产生重复代码并且可能阻塞主线程，doOn的系列操作就派上了用场</p>\n<ul>\n<li><p>doOnNext —  当数据发射成功时调用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Observable.just(<span class=\"string\">\"data to shoot\"</span>)</div><div class=\"line\">                .doOnNext(<span class=\"keyword\">new</span> Action1&lt;String&gt;() &#123;</div><div class=\"line\">                    <span class=\"meta\">@Override</span></div><div class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">(String s)</span> </span>&#123;</div><div class=\"line\">                        <span class=\"comment\">//发射成功后需要的操作</span></div><div class=\"line\">                      \twriteToCache(s);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;)</div></pre></td></tr></table></figure>\n<p>在使用的时候注意判断doOnNext当前在哪个线程执行</p>\n</li>\n</ul>\n<ul>\n<li>doOnError —  当发生异常时调用</li>\n<li>doOnSubscribe — 当被订阅时调用</li>\n<li>doOnTerminate — 发射数据完毕后调用</li>\n</ul>\n<h4 id=\"F-封装-compose\"><a href=\"#F-封装-compose\" class=\"headerlink\" title=\"F.封装-compose\"></a>F.封装-compose</h4><p>当我们真正开始使用RxJava来替换之前的逻辑代码时，我们发现仅用现有的操作符无法做到完全的简洁，依然会出现一些不必要的重复代码和逻辑。适度的封装也是必要的，RxJava早就想到了这点，提供了一个操作符来封装一些通用代码</p>\n<ul>\n<li><p>compose(@NotNull Transformer<t,r>)</t,r></p>\n<p>compose方法需要传入一个变形金刚对象,其中泛型T为原始的Observable所发射的数据类型，R为变形后所发射的数据类型，举个栗子，比如封装一个方法在io线程中发射数据，在ui线程中观察接收数据。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> &lt;T&gt; Observable.<span class=\"function\">Transformer&lt;T,T&gt; <span class=\"title\">io_main</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Observable.Transformer&lt;T, T&gt;() &#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> Observable&lt;T&gt; <span class=\"title\">call</span><span class=\"params\">(Observable&lt;T&gt; tObservable)</span> </span>&#123;</div><div class=\"line\">                <span class=\"keyword\">return</span> tObservable.subscribeOn(Schedulers.io())</div><div class=\"line\">                        .observeOn(AndroidSchedulers.mainThread());</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>创建一个Transformer对象，需要实现call方法，return一个新的Observable，然后传入到compose（）中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Observable.just(<span class=\"string\">\"123\"</span>)</div><div class=\"line\">                .compose(<span class=\"keyword\">this</span>.&lt;String&gt;io_main())</div><div class=\"line\">                .subscribe();</div></pre></td></tr></table></figure>\n<p>查看一下compose的源码发现，它其实就做了一件事情，调用 Transformer的call方法，并把当前的Observable对象作为参数传进去，返回call方法得到的新的Observable</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> &lt;R&gt; <span class=\"function\">Observable&lt;R&gt; <span class=\"title\">compose</span><span class=\"params\">(Transformer&lt;? <span class=\"keyword\">super</span> T, ? extends R&gt; transformer)</span> </span>&#123;</div><div class=\"line\">       <span class=\"keyword\">return</span> ((Transformer&lt;T, R&gt;) transformer).call(<span class=\"keyword\">this</span>);</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"RxBus\"><a href=\"#RxBus\" class=\"headerlink\" title=\"RxBus\"></a>RxBus</h3><p>EventBus让模块间的耦合更低，利用 RxJava实现EventBus简直是容易，且便于管理</p>\n<p>在实现RxBus之前介绍两个很重要的类</p>\n<ul>\n<li><p>CompositeSubscription— Subscription that represents a group of Subscriptions that are unsubscribed together.</p>\n<p>是Subscription的一个实习类，用于管理一组订阅，当取消订阅时，会将这一组订阅全部取消，在Android中可以利用该类管理一个Activity中所有的异步任务，当Activity被销毁时，取消订阅，避免内存泄漏</p>\n<ul>\n<li>add — 将一个订阅加入到一个订阅组中</li>\n<li>remove — 将一个订阅从该组中移除</li>\n<li>clear — 清空订阅组</li>\n<li>unsubscribe — 取消改组中正在进行的所有订阅</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>Subject — 一个神奇的类，在 RxJava中它同时充当了Observer和Observable的角色。</p>\n<p>文章一开头提到了“冷”启动和“热”启动，而一个Subject可以将一个“冷”Observer变成一个“热”的，因为它是一个Observer，它可以订阅一个或多个Observable；又因为它是一个Observable，它可以转发它收到(Observe)的数据，也可以发射新的数据。</p>\n<p>subject.subscribe(subscriber) — 订阅事件</p>\n<p>subject.onNext(obj) — 发射数据</p>\n<p>Subject 在RxJava中总共有7个子类，这里不一一介绍（因为我也没用过…）</p>\n<ul>\n<li><p>PublishSubject — 一个“热”的Observable,这个对象会在onNext被调用的时候就开始发射数据，无论有没有订阅者，当一个Observer订阅了这个对象时，只会收到订阅时间点之后所发射的数据。官方给出的栗子：</p>\n<p>两个observer分别订阅了同一个subject，observer1会收到所有的数据，而observer2只能收到最后一条数据</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">PublishSubject&lt;Object&gt; subject = PublishSubject.create();</div><div class=\"line\">  <span class=\"comment\">// observer1 will receive all onNext and onCompleted events</span></div><div class=\"line\">  subject.subscribe(observer1);</div><div class=\"line\">  subject.onNext(<span class=\"string\">\"one\"</span>);</div><div class=\"line\">  subject.onNext(<span class=\"string\">\"two\"</span>);</div><div class=\"line\">  <span class=\"comment\">// observer2 will only receive \"three\" and onCompleted</span></div><div class=\"line\">  subject.subscribe(observer2);</div><div class=\"line\">  subject.onNext(<span class=\"string\">\"three\"</span>);</div><div class=\"line\">  subject.onCompleted();</div></pre></td></tr></table></figure>\n<p>再想想EventBus的原理，我们所需要的正是这样一个“热”Observable。这里是较为复杂的一种实现，先上原理图<br><img src=\"/img/RxBus原理.jpeg\" alt=\"RxBus原理\"></p>\n</li>\n</ul>\n<p>再贴代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> ConcurrentHashMap&lt;Object, List&lt;Subject&gt;&gt; subjectMapper </div><div class=\"line\">  = <span class=\"keyword\">new</span> ConcurrentHashMap&lt;Object, List&lt;Subject&gt;&gt;();</div><div class=\"line\"><span class=\"comment\">//订阅事件</span></div><div class=\"line\"><span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\">Observable&lt;T&gt; <span class=\"title\">subscribe</span><span class=\"params\">(@NonNull Object tag)</span> </span>&#123;</div><div class=\"line\">        List&lt;Subject&gt; subjectList = subjectMapper.get(tag);</div><div class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == subjectList) &#123;</div><div class=\"line\">            subjectList = <span class=\"keyword\">new</span> ArrayList&lt;Subject&gt;();</div><div class=\"line\">            subjectMapper.put(tag, subjectList);</div><div class=\"line\">        &#125;</div><div class=\"line\">        Subject&lt;T, T&gt; subject;</div><div class=\"line\">        subjectList.add(subject = PublishSubject.create());</div><div class=\"line\">        <span class=\"keyword\">return</span> subject;</div><div class=\"line\">    &#125;</div><div class=\"line\"><span class=\"comment\">//发布事件－－发射数据</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">post</span><span class=\"params\">(@NonNull Object tag, @NonNull Object content)</span> </span>&#123;</div><div class=\"line\">        List&lt;Subject&gt; subjectList = subjectMapper.get(tag);</div><div class=\"line\">        <span class=\"keyword\">if</span> (!isEmpty(subjectList)) &#123;</div><div class=\"line\">            <span class=\"keyword\">for</span> (Subject subject : subjectList) &#123;</div><div class=\"line\">                subject.onNext(content);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>RxBus的核心逻辑就完成了，当然还需要加上取消订阅，清空事件等代码，比较简单不再赘述，在我实际的项目开发中，我将 RxBus交由 RxJavaManager进行管理，所有的订阅事件全部经过 RxJavaManager来操作，在需要取消订阅的地方统一unsubscribe</p>\n<h3 id=\"资料\"><a href=\"#资料\" class=\"headerlink\" title=\"资料\"></a>资料</h3><ul>\n<li><a href=\"https://github.com/mcxiaoke/RxDocs\" target=\"_blank\" rel=\"external\">RxDocs</a> — ReactiveX中文文档</li>\n<li><a href=\"http://gank.io/post/560e15be2dca930e00da1083#toc_24\" target=\"_blank\" rel=\"external\">给 Android 开发者的 RxJava 详解</a> — 扔物线大神的文章</li>\n<li><a href=\"https://asce1885.gitbooks.io/android-rd-senior-advanced/content/index.html\" target=\"_blank\" rel=\"external\">什么是函数响应式编程</a> — android中响应式编程介绍</li>\n<li><a href=\"https://github.com/north2014/T-MVP\" target=\"_blank\" rel=\"external\">T-MVP</a> — 一个不错的开源项目 RxJava+MVP</li>\n<li><a href=\"http://reactivex.io/\" target=\"_blank\" rel=\"external\">ReactiveX.io</a> — 官方网站</li>\n<li><a href=\"http://imxie.cc/2016/06/02/deep-understanding-of-RxBus/\" target=\"_blank\" rel=\"external\">从 RxBus 这辆兰博基尼深入进去</a> — 我的好基友谢三弟的Subject源码分析</li>\n</ul>\n","categories":["Android"],"tags":[]},{"title":"about","url":"https://joesteven.github.io/about/index.html","content":"","categories":[],"tags":[]},{"title":"分类","url":"https://joesteven.github.io/category/index.html","content":"","categories":[],"tags":[]},{"title":"工作室","url":"https://joesteven.github.io/studio/index.html","content":"","categories":[],"tags":[]},{"title":"search","url":"https://joesteven.github.io/search/index.html","content":"","categories":[],"tags":[]},{"title":"优秀的朋友们","url":"https://joesteven.github.io/friends/index.html","content":"<h3 id=\"友情链接\"><a href=\"#友情链接\" class=\"headerlink\" title=\"友情链接\"></a>友情链接</h3><ul>\n<li><a href=\"https://itscoder.com/\" target=\"_blank\" rel=\"external\">itsCoder</a> — 一个神奇的组织</li>\n<li><a href=\"https://cassieran.github.io/\" target=\"_blank\" rel=\"external\">FaFa’s Site</a> — 前端，我的另一半</li>\n<li><a href=\"http://laobie.github.io/\" target=\"_blank\" rel=\"external\">写代码的猴子</a> — Android/前端，itsCoder创始人</li>\n<li><a href=\"http://imxie.itscoder.com/\" target=\"_blank\" rel=\"external\">谢三弟</a> — Android，即刻大佬</li>\n<li><a href=\"http://brucezz.github.io/\" target=\"_blank\" rel=\"external\">Brucezz</a> — Android/Python，天哥，即刻大佬</li>\n<li><a href=\"http://allenwu.itscoder.com/\" target=\"_blank\" rel=\"external\">小刚</a> — Android，腾讯大佬</li>\n<li><a href=\"http://manjusaka.itscoder.com/\" target=\"_blank\" rel=\"external\">Manjusaka</a> — Python大神，正义使者</li>\n<li><a href=\"https://itscoder.com/members/\" target=\"_blank\" rel=\"external\">itsCoder全体成员</a></li>\n</ul>\n","categories":[],"tags":[]}]
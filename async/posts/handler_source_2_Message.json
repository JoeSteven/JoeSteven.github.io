{"tags":[],"categories":[{"name":"Android源码学习","permalink":"https://joesteven.github.io/categories/Android源码学习/","url":"/async/categories/Android源码学习.json","count":11}],"url":"/async/posts/handler_source_2_Message.json","date":1471342737000,"path":{"year":2016,"month":8,"day":16,"name":"handler_source_2_Message"},"title":"Handler源码学习（二）Message对象池","permalink":"https://joesteven.github.io/handler_source_2_Message/","content":"<p><a href=\"http://extremej.itscoder.com/handler_source_1/\" target=\"_blank\" rel=\"external\">Handler源码学习（一）流程</a><br>Handler源码学习（二）Message对象池<br><a href=\"http://extremej.itscoder.com/handler_source_3_MessageQueue/\" target=\"_blank\" rel=\"external\">Handler源码学习（三）MessageQueue入队插队</a><br>消息池是全系统共用，上限为50个</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MAX_POOL_SIZE = <span class=\"number\">50</span>;</div></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// sometimes we store linked lists of these things</span></div><div class=\"line\"><span class=\"comment\">/*package*/</span> Message next;</div><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Message sPool;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//假设现在消息池为空，从new message开始，到这个message被取出使用后，准备回收</span></div><div class=\"line\"><span class=\"comment\">//准备工作：拿到同步锁，避免线程不安全</span></div><div class=\"line\"><span class=\"comment\">//1.next ＝ sPool,因为池中是空的，所以此时sPool其实是null</span></div><div class=\"line\"><span class=\"comment\">//2.spool = this,将当前这个message作为池中下一个应该被复用的对象</span></div><div class=\"line\"><span class=\"comment\">//3.sPoolSize ++;将池子中的数量增加一，这个数量依然是全系统共享</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">recycleUnchecked</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">synchronized</span> (sPoolSync) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (sPoolSize &lt; MAX_POOL_SIZE) &#123;</div><div class=\"line\">                next = sPool;</div><div class=\"line\">                sPool = <span class=\"keyword\">this</span>;</div><div class=\"line\">                sPoolSize++;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"><span class=\"comment\">//上面已经回收了一个message，在这里来获取message，看看会发生什么</span></div><div class=\"line\"><span class=\"comment\">//同样进入同步代码块</span></div><div class=\"line\"><span class=\"comment\">//1.判断sPool是否是为空，如果池子为空，就直接new一个message</span></div><div class=\"line\"><span class=\"comment\">//上面已经回收过一个message了，这里应该不为空</span></div><div class=\"line\"><span class=\"comment\">//m ＝sPool；把池子里的这个message取出来</span></div><div class=\"line\"><span class=\"comment\">//2.sPool = m.next 将池中下一个复用的对象赋值为m.next,但是我们通过上面的代码发现这个是null，先</span></div><div class=\"line\"><span class=\"comment\">//不管</span></div><div class=\"line\"><span class=\"comment\">//3.将m.next置为空,m.flags = 0 给了一个标记使用中</span></div><div class=\"line\"><span class=\"comment\">//4.从池子中减去</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Message <span class=\"title\">obtain</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">synchronized</span> (sPoolSync) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (sPool != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            Message m = sPool;</div><div class=\"line\">            sPool = m.next;</div><div class=\"line\">            m.next = <span class=\"keyword\">null</span>;</div><div class=\"line\">            m.flags = <span class=\"number\">0</span>; <span class=\"comment\">// clear in-use flag</span></div><div class=\"line\">            sPoolSize--;</div><div class=\"line\">            <span class=\"keyword\">return</span> m;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Message();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面的过程只有一个mesage，详细解释一下sPool和next，将sPool看成一个指针，通过next来将对象组成了一个链表，因为每次只需要从池子里拿一个对象，所以不需要关心池子里具体有多少个对象，而是拿出当前这个sPool所指向的这个对象就可以了，sPool从思路上理解就是通过左右移动来完成复用和回收</p>\n<h4 id=\"Obtain-–-复用\"><a href=\"#Obtain-–-复用\" class=\"headerlink\" title=\"Obtain() – 复用\"></a>Obtain() – 复用</h4><p><img src=\"http://upload-images.jianshu.io/upload_images/1473110-2c0dcf654d397a72.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"MessageObtain(1).jpg\"></p>\n<p>当调用Obtain()的时候让sPool＝next，因为第一个message.next就等于第二个message，从图上看相当于sPool这个指针向后移动了一位，随后会将第一个message.next的值置为空</p>\n<p>如下图<br><img src=\"http://upload-images.jianshu.io/upload_images/1473110-600f714bdbc236f8.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"MessageObtain(2).jpg\"></p>\n<p>现在这个链表看上去就断了，如果in-use这个message使用完毕了，怎么回到链表中？</p>\n<h4 id=\"recycleUnchecked-–-回收\"><a href=\"#recycleUnchecked-–-回收\" class=\"headerlink\" title=\"recycleUnchecked() – 回收\"></a>recycleUnchecked() – 回收</h4><p>再看回收的方法中的代码，next ＝ sPool，将当前sPool所指向的message对象赋值给in－use的next，然后sPool = this，将sPool指向第一个message对象<br><img src=\"http://upload-images.jianshu.io/upload_images/1473110-3557f637c794f14b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"MessageRecycle.jpg\"></p>\n<p>这样，就将链表又恢复了～，而且不管是复用还是回收都是保证线程同步的，所以始终会形成一条链式结构</p>\n"}